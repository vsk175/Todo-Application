{"version":3,"sources":["node_modules/@angular/common/fesm2022/module.mjs","node_modules/@angular/common/fesm2022/http.mjs","node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs","node_modules/@angular/material/fesm2022/icon-registry-CwOTJ7YM.mjs","node_modules/@angular/material/fesm2022/icon.mjs"],"sourcesContent":["/**\n * @license Angular v20.1.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { ɵRuntimeError as _RuntimeError, Injectable, InjectionToken, inject, NgZone, DestroyRef, ɵformatRuntimeError as _formatRuntimeError, PendingTasks, ɵConsole as _Console, runInInjectionContext, DOCUMENT, Inject, makeEnvironmentProviders, NgModule } from '@angular/core';\nimport { concatMap, filter, map, finalize, switchMap } from 'rxjs/operators';\nimport { of, Observable, from } from 'rxjs';\nimport { XhrFactory, parseCookieValue } from './xhr.mjs';\n\n/**\n * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a\n * `HttpResponse`.\n *\n * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the\n * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the\n * `HttpBackend`.\n *\n * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.\n *\n * @publicApi\n */\nclass HttpHandler {\n}\n/**\n * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.\n *\n * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.\n *\n * When injected, `HttpBackend` dispatches requests directly to the backend, without going\n * through the interceptor chain.\n *\n * @publicApi\n */\nclass HttpBackend {\n}\n\n/**\n * Represents the header configuration options for an HTTP request.\n * Instances are immutable. Modifying methods return a cloned\n * instance with the change. The original object is never changed.\n *\n * @publicApi\n */\nclass HttpHeaders {\n    /**\n     * Internal map of lowercase header names to values.\n     */\n    headers;\n    /**\n     * Internal map of lowercased header names to the normalized\n     * form of the name (the form seen first).\n     */\n    normalizedNames = new Map();\n    /**\n     * Complete the lazy initialization of this object (needed before reading).\n     */\n    lazyInit;\n    /**\n     * Queued updates to be materialized the next initialization.\n     */\n    lazyUpdate = null;\n    /**  Constructs a new HTTP header object with the given values.*/\n    constructor(headers) {\n        if (!headers) {\n            this.headers = new Map();\n        }\n        else if (typeof headers === 'string') {\n            this.lazyInit = () => {\n                this.headers = new Map();\n                headers.split('\\n').forEach((line) => {\n                    const index = line.indexOf(':');\n                    if (index > 0) {\n                        const name = line.slice(0, index);\n                        const value = line.slice(index + 1).trim();\n                        this.addHeaderEntry(name, value);\n                    }\n                });\n            };\n        }\n        else if (typeof Headers !== 'undefined' && headers instanceof Headers) {\n            this.headers = new Map();\n            headers.forEach((value, name) => {\n                this.addHeaderEntry(name, value);\n            });\n        }\n        else {\n            this.lazyInit = () => {\n                if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                    assertValidHeaders(headers);\n                }\n                this.headers = new Map();\n                Object.entries(headers).forEach(([name, values]) => {\n                    this.setHeaderEntries(name, values);\n                });\n            };\n        }\n    }\n    /**\n     * Checks for existence of a given header.\n     *\n     * @param name The header name to check for existence.\n     *\n     * @returns True if the header exists, false otherwise.\n     */\n    has(name) {\n        this.init();\n        return this.headers.has(name.toLowerCase());\n    }\n    /**\n     * Retrieves the first value of a given header.\n     *\n     * @param name The header name.\n     *\n     * @returns The value string if the header exists, null otherwise\n     */\n    get(name) {\n        this.init();\n        const values = this.headers.get(name.toLowerCase());\n        return values && values.length > 0 ? values[0] : null;\n    }\n    /**\n     * Retrieves the names of the headers.\n     *\n     * @returns A list of header names.\n     */\n    keys() {\n        this.init();\n        return Array.from(this.normalizedNames.values());\n    }\n    /**\n     * Retrieves a list of values for a given header.\n     *\n     * @param name The header name from which to retrieve values.\n     *\n     * @returns A string of values if the header exists, null otherwise.\n     */\n    getAll(name) {\n        this.init();\n        return this.headers.get(name.toLowerCase()) || null;\n    }\n    /**\n     * Appends a new value to the existing set of values for a header\n     * and returns them in a clone of the original instance.\n     *\n     * @param name The header name for which to append the values.\n     * @param value The value to append.\n     *\n     * @returns A clone of the HTTP headers object with the value appended to the given header.\n     */\n    append(name, value) {\n        return this.clone({ name, value, op: 'a' });\n    }\n    /**\n     * Sets or modifies a value for a given header in a clone of the original instance.\n     * If the header already exists, its value is replaced with the given value\n     * in the returned object.\n     *\n     * @param name The header name.\n     * @param value The value or values to set or override for the given header.\n     *\n     * @returns A clone of the HTTP headers object with the newly set header value.\n     */\n    set(name, value) {\n        return this.clone({ name, value, op: 's' });\n    }\n    /**\n     * Deletes values for a given header in a clone of the original instance.\n     *\n     * @param name The header name.\n     * @param value The value or values to delete for the given header.\n     *\n     * @returns A clone of the HTTP headers object with the given value deleted.\n     */\n    delete(name, value) {\n        return this.clone({ name, value, op: 'd' });\n    }\n    maybeSetNormalizedName(name, lcName) {\n        if (!this.normalizedNames.has(lcName)) {\n            this.normalizedNames.set(lcName, name);\n        }\n    }\n    init() {\n        if (!!this.lazyInit) {\n            if (this.lazyInit instanceof HttpHeaders) {\n                this.copyFrom(this.lazyInit);\n            }\n            else {\n                this.lazyInit();\n            }\n            this.lazyInit = null;\n            if (!!this.lazyUpdate) {\n                this.lazyUpdate.forEach((update) => this.applyUpdate(update));\n                this.lazyUpdate = null;\n            }\n        }\n    }\n    copyFrom(other) {\n        other.init();\n        Array.from(other.headers.keys()).forEach((key) => {\n            this.headers.set(key, other.headers.get(key));\n            this.normalizedNames.set(key, other.normalizedNames.get(key));\n        });\n    }\n    clone(update) {\n        const clone = new HttpHeaders();\n        clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof HttpHeaders ? this.lazyInit : this;\n        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\n        return clone;\n    }\n    applyUpdate(update) {\n        const key = update.name.toLowerCase();\n        switch (update.op) {\n            case 'a':\n            case 's':\n                let value = update.value;\n                if (typeof value === 'string') {\n                    value = [value];\n                }\n                if (value.length === 0) {\n                    return;\n                }\n                this.maybeSetNormalizedName(update.name, key);\n                const base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];\n                base.push(...value);\n                this.headers.set(key, base);\n                break;\n            case 'd':\n                const toDelete = update.value;\n                if (!toDelete) {\n                    this.headers.delete(key);\n                    this.normalizedNames.delete(key);\n                }\n                else {\n                    let existing = this.headers.get(key);\n                    if (!existing) {\n                        return;\n                    }\n                    existing = existing.filter((value) => toDelete.indexOf(value) === -1);\n                    if (existing.length === 0) {\n                        this.headers.delete(key);\n                        this.normalizedNames.delete(key);\n                    }\n                    else {\n                        this.headers.set(key, existing);\n                    }\n                }\n                break;\n        }\n    }\n    addHeaderEntry(name, value) {\n        const key = name.toLowerCase();\n        this.maybeSetNormalizedName(name, key);\n        if (this.headers.has(key)) {\n            this.headers.get(key).push(value);\n        }\n        else {\n            this.headers.set(key, [value]);\n        }\n    }\n    setHeaderEntries(name, values) {\n        const headerValues = (Array.isArray(values) ? values : [values]).map((value) => value.toString());\n        const key = name.toLowerCase();\n        this.headers.set(key, headerValues);\n        this.maybeSetNormalizedName(name, key);\n    }\n    /**\n     * @internal\n     */\n    forEach(fn) {\n        this.init();\n        Array.from(this.normalizedNames.keys()).forEach((key) => fn(this.normalizedNames.get(key), this.headers.get(key)));\n    }\n}\n/**\n * Verifies that the headers object has the right shape: the values\n * must be either strings, numbers or arrays. Throws an error if an invalid\n * header value is present.\n */\nfunction assertValidHeaders(headers) {\n    for (const [key, value] of Object.entries(headers)) {\n        if (!(typeof value === 'string' || typeof value === 'number') && !Array.isArray(value)) {\n            throw new Error(`Unexpected value of the \\`${key}\\` header provided. ` +\n                `Expecting either a string, a number or an array, but got: \\`${value}\\`.`);\n        }\n    }\n}\n\n/**\n * Provides encoding and decoding of URL parameter and query-string values.\n *\n * Serializes and parses URL parameter keys and values to encode and decode them.\n * If you pass URL query parameters without encoding,\n * the query parameters can be misinterpreted at the receiving end.\n *\n *\n * @publicApi\n */\nclass HttpUrlEncodingCodec {\n    /**\n     * Encodes a key name for a URL parameter or query-string.\n     * @param key The key name.\n     * @returns The encoded key name.\n     */\n    encodeKey(key) {\n        return standardEncoding(key);\n    }\n    /**\n     * Encodes the value of a URL parameter or query-string.\n     * @param value The value.\n     * @returns The encoded value.\n     */\n    encodeValue(value) {\n        return standardEncoding(value);\n    }\n    /**\n     * Decodes an encoded URL parameter or query-string key.\n     * @param key The encoded key name.\n     * @returns The decoded key name.\n     */\n    decodeKey(key) {\n        return decodeURIComponent(key);\n    }\n    /**\n     * Decodes an encoded URL parameter or query-string value.\n     * @param value The encoded value.\n     * @returns The decoded value.\n     */\n    decodeValue(value) {\n        return decodeURIComponent(value);\n    }\n}\nfunction paramParser(rawParams, codec) {\n    const map = new Map();\n    if (rawParams.length > 0) {\n        // The `window.location.search` can be used while creating an instance of the `HttpParams` class\n        // (e.g. `new HttpParams({ fromString: window.location.search })`). The `window.location.search`\n        // may start with the `?` char, so we strip it if it's present.\n        const params = rawParams.replace(/^\\?/, '').split('&');\n        params.forEach((param) => {\n            const eqIdx = param.indexOf('=');\n            const [key, val] = eqIdx == -1\n                ? [codec.decodeKey(param), '']\n                : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];\n            const list = map.get(key) || [];\n            list.push(val);\n            map.set(key, list);\n        });\n    }\n    return map;\n}\n/**\n * Encode input string with standard encodeURIComponent and then un-encode specific characters.\n */\nconst STANDARD_ENCODING_REGEX = /%(\\d[a-f0-9])/gi;\nconst STANDARD_ENCODING_REPLACEMENTS = {\n    '40': '@',\n    '3A': ':',\n    '24': '$',\n    '2C': ',',\n    '3B': ';',\n    '3D': '=',\n    '3F': '?',\n    '2F': '/',\n};\nfunction standardEncoding(v) {\n    return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s);\n}\nfunction valueToString(value) {\n    return `${value}`;\n}\n/**\n * An HTTP request/response body that represents serialized parameters,\n * per the MIME type `application/x-www-form-urlencoded`.\n *\n * This class is immutable; all mutation operations return a new instance.\n *\n * @publicApi\n */\nclass HttpParams {\n    map;\n    encoder;\n    updates = null;\n    cloneFrom = null;\n    constructor(options = {}) {\n        this.encoder = options.encoder || new HttpUrlEncodingCodec();\n        if (options.fromString) {\n            if (options.fromObject) {\n                throw new _RuntimeError(2805 /* RuntimeErrorCode.CANNOT_SPECIFY_BOTH_FROM_STRING_AND_FROM_OBJECT */, ngDevMode && 'Cannot specify both fromString and fromObject.');\n            }\n            this.map = paramParser(options.fromString, this.encoder);\n        }\n        else if (!!options.fromObject) {\n            this.map = new Map();\n            Object.keys(options.fromObject).forEach((key) => {\n                const value = options.fromObject[key];\n                // convert the values to strings\n                const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];\n                this.map.set(key, values);\n            });\n        }\n        else {\n            this.map = null;\n        }\n    }\n    /**\n     * Reports whether the body includes one or more values for a given parameter.\n     * @param param The parameter name.\n     * @returns True if the parameter has one or more values,\n     * false if it has no value or is not present.\n     */\n    has(param) {\n        this.init();\n        return this.map.has(param);\n    }\n    /**\n     * Retrieves the first value for a parameter.\n     * @param param The parameter name.\n     * @returns The first value of the given parameter,\n     * or `null` if the parameter is not present.\n     */\n    get(param) {\n        this.init();\n        const res = this.map.get(param);\n        return !!res ? res[0] : null;\n    }\n    /**\n     * Retrieves all values for a  parameter.\n     * @param param The parameter name.\n     * @returns All values in a string array,\n     * or `null` if the parameter not present.\n     */\n    getAll(param) {\n        this.init();\n        return this.map.get(param) || null;\n    }\n    /**\n     * Retrieves all the parameters for this body.\n     * @returns The parameter names in a string array.\n     */\n    keys() {\n        this.init();\n        return Array.from(this.map.keys());\n    }\n    /**\n     * Appends a new value to existing values for a parameter.\n     * @param param The parameter name.\n     * @param value The new value to add.\n     * @return A new body with the appended value.\n     */\n    append(param, value) {\n        return this.clone({ param, value, op: 'a' });\n    }\n    /**\n     * Constructs a new body with appended values for the given parameter name.\n     * @param params parameters and values\n     * @return A new body with the new value.\n     */\n    appendAll(params) {\n        const updates = [];\n        Object.keys(params).forEach((param) => {\n            const value = params[param];\n            if (Array.isArray(value)) {\n                value.forEach((_value) => {\n                    updates.push({ param, value: _value, op: 'a' });\n                });\n            }\n            else {\n                updates.push({ param, value: value, op: 'a' });\n            }\n        });\n        return this.clone(updates);\n    }\n    /**\n     * Replaces the value for a parameter.\n     * @param param The parameter name.\n     * @param value The new value.\n     * @return A new body with the new value.\n     */\n    set(param, value) {\n        return this.clone({ param, value, op: 's' });\n    }\n    /**\n     * Removes a given value or all values from a parameter.\n     * @param param The parameter name.\n     * @param value The value to remove, if provided.\n     * @return A new body with the given value removed, or with all values\n     * removed if no value is specified.\n     */\n    delete(param, value) {\n        return this.clone({ param, value, op: 'd' });\n    }\n    /**\n     * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are\n     * separated by `&`s.\n     */\n    toString() {\n        this.init();\n        return (this.keys()\n            .map((key) => {\n            const eKey = this.encoder.encodeKey(key);\n            // `a: ['1']` produces `'a=1'`\n            // `b: []` produces `''`\n            // `c: ['1', '2']` produces `'c=1&c=2'`\n            return this.map.get(key)\n                .map((value) => eKey + '=' + this.encoder.encodeValue(value))\n                .join('&');\n        })\n            // filter out empty values because `b: []` produces `''`\n            // which results in `a=1&&c=1&c=2` instead of `a=1&c=1&c=2` if we don't\n            .filter((param) => param !== '')\n            .join('&'));\n    }\n    clone(update) {\n        const clone = new HttpParams({ encoder: this.encoder });\n        clone.cloneFrom = this.cloneFrom || this;\n        clone.updates = (this.updates || []).concat(update);\n        return clone;\n    }\n    init() {\n        if (this.map === null) {\n            this.map = new Map();\n        }\n        if (this.cloneFrom !== null) {\n            this.cloneFrom.init();\n            this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));\n            this.updates.forEach((update) => {\n                switch (update.op) {\n                    case 'a':\n                    case 's':\n                        const base = (update.op === 'a' ? this.map.get(update.param) : undefined) || [];\n                        base.push(valueToString(update.value));\n                        this.map.set(update.param, base);\n                        break;\n                    case 'd':\n                        if (update.value !== undefined) {\n                            let base = this.map.get(update.param) || [];\n                            const idx = base.indexOf(valueToString(update.value));\n                            if (idx !== -1) {\n                                base.splice(idx, 1);\n                            }\n                            if (base.length > 0) {\n                                this.map.set(update.param, base);\n                            }\n                            else {\n                                this.map.delete(update.param);\n                            }\n                        }\n                        else {\n                            this.map.delete(update.param);\n                            break;\n                        }\n                }\n            });\n            this.cloneFrom = this.updates = null;\n        }\n    }\n}\n\n/**\n * A token used to manipulate and access values stored in `HttpContext`.\n *\n * @publicApi\n */\nclass HttpContextToken {\n    defaultValue;\n    constructor(defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n}\n/**\n * Http context stores arbitrary user defined values and ensures type safety without\n * actually knowing the types. It is backed by a `Map` and guarantees that keys do not clash.\n *\n * This context is mutable and is shared between cloned requests unless explicitly specified.\n *\n * @usageNotes\n *\n * ### Usage Example\n *\n * ```ts\n * // inside cache.interceptors.ts\n * export const IS_CACHE_ENABLED = new HttpContextToken<boolean>(() => false);\n *\n * export class CacheInterceptor implements HttpInterceptor {\n *\n *   intercept(req: HttpRequest<any>, delegate: HttpHandler): Observable<HttpEvent<any>> {\n *     if (req.context.get(IS_CACHE_ENABLED) === true) {\n *       return ...;\n *     }\n *     return delegate.handle(req);\n *   }\n * }\n *\n * // inside a service\n *\n * this.httpClient.get('/api/weather', {\n *   context: new HttpContext().set(IS_CACHE_ENABLED, true)\n * }).subscribe(...);\n * ```\n *\n * @publicApi\n */\nclass HttpContext {\n    map = new Map();\n    /**\n     * Store a value in the context. If a value is already present it will be overwritten.\n     *\n     * @param token The reference to an instance of `HttpContextToken`.\n     * @param value The value to store.\n     *\n     * @returns A reference to itself for easy chaining.\n     */\n    set(token, value) {\n        this.map.set(token, value);\n        return this;\n    }\n    /**\n     * Retrieve the value associated with the given token.\n     *\n     * @param token The reference to an instance of `HttpContextToken`.\n     *\n     * @returns The stored value or default if one is defined.\n     */\n    get(token) {\n        if (!this.map.has(token)) {\n            this.map.set(token, token.defaultValue());\n        }\n        return this.map.get(token);\n    }\n    /**\n     * Delete the value associated with the given token.\n     *\n     * @param token The reference to an instance of `HttpContextToken`.\n     *\n     * @returns A reference to itself for easy chaining.\n     */\n    delete(token) {\n        this.map.delete(token);\n        return this;\n    }\n    /**\n     * Checks for existence of a given token.\n     *\n     * @param token The reference to an instance of `HttpContextToken`.\n     *\n     * @returns True if the token exists, false otherwise.\n     */\n    has(token) {\n        return this.map.has(token);\n    }\n    /**\n     * @returns a list of tokens currently stored in the context.\n     */\n    keys() {\n        return this.map.keys();\n    }\n}\n\n/**\n * Determine whether the given HTTP method may include a body.\n */\nfunction mightHaveBody(method) {\n    switch (method) {\n        case 'DELETE':\n        case 'GET':\n        case 'HEAD':\n        case 'OPTIONS':\n        case 'JSONP':\n            return false;\n        default:\n            return true;\n    }\n}\n/**\n * Safely assert whether the given value is an ArrayBuffer.\n *\n * In some execution environments ArrayBuffer is not defined.\n */\nfunction isArrayBuffer(value) {\n    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n/**\n * Safely assert whether the given value is a Blob.\n *\n * In some execution environments Blob is not defined.\n */\nfunction isBlob(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\n/**\n * Safely assert whether the given value is a FormData instance.\n *\n * In some execution environments FormData is not defined.\n */\nfunction isFormData(value) {\n    return typeof FormData !== 'undefined' && value instanceof FormData;\n}\n/**\n * Safely assert whether the given value is a URLSearchParams instance.\n *\n * In some execution environments URLSearchParams is not defined.\n */\nfunction isUrlSearchParams(value) {\n    return typeof URLSearchParams !== 'undefined' && value instanceof URLSearchParams;\n}\n/**\n * `Content-Type` is an HTTP header used to indicate the media type\n * (also known as MIME type) of the resource being sent to the client\n * or received from the server.\n */\nconst CONTENT_TYPE_HEADER = 'Content-Type';\n/**\n * The `Accept` header is an HTTP request header that indicates the media types\n * (or content types) the client is willing to receive from the server.\n */\nconst ACCEPT_HEADER = 'Accept';\n/**\n * `X-Request-URL` is a custom HTTP header used in older browser versions,\n * including Firefox (< 32), Chrome (< 37), Safari (< 8), and Internet Explorer,\n * to include the full URL of the request in cross-origin requests.\n */\nconst X_REQUEST_URL_HEADER = 'X-Request-URL';\n/**\n * `text/plain` is a content type used to indicate that the content being\n * sent is plain text with no special formatting or structured data\n * like HTML, XML, or JSON.\n */\nconst TEXT_CONTENT_TYPE = 'text/plain';\n/**\n * `application/json` is a content type used to indicate that the content\n * being sent is in the JSON format.\n */\nconst JSON_CONTENT_TYPE = 'application/json';\n/**\n * `application/json, text/plain, *\\/*` is a content negotiation string often seen in the\n * Accept header of HTTP requests. It indicates the types of content the client is willing\n * to accept from the server, with a preference for `application/json` and `text/plain`,\n * but also accepting any other type (*\\/*).\n */\nconst ACCEPT_HEADER_VALUE = `${JSON_CONTENT_TYPE}, ${TEXT_CONTENT_TYPE}, */*`;\n/**\n * An outgoing HTTP request with an optional typed body.\n *\n * `HttpRequest` represents an outgoing request, including URL, method,\n * headers, body, and other request configuration options. Instances should be\n * assumed to be immutable. To modify a `HttpRequest`, the `clone`\n * method should be used.\n *\n * @publicApi\n */\nclass HttpRequest {\n    url;\n    /**\n     * The request body, or `null` if one isn't set.\n     *\n     * Bodies are not enforced to be immutable, as they can include a reference to any\n     * user-defined data type. However, interceptors should take care to preserve\n     * idempotence by treating them as such.\n     */\n    body = null;\n    /**\n     * Outgoing headers for this request.\n     */\n    headers;\n    /**\n     * Shared and mutable context that can be used by interceptors\n     */\n    context;\n    /**\n     * Whether this request should be made in a way that exposes progress events.\n     *\n     * Progress events are expensive (change detection runs on each event) and so\n     * they should only be requested if the consumer intends to monitor them.\n     *\n     * Note: The `FetchBackend` doesn't support progress report on uploads.\n     */\n    reportProgress = false;\n    /**\n     * Whether this request should be sent with outgoing credentials (cookies).\n     */\n    withCredentials = false;\n    /**\n     *  The credentials mode of the request, which determines how cookies and HTTP authentication are handled.\n     *  This can affect whether cookies are sent with the request, and how authentication is handled.\n     */\n    credentials;\n    /**\n     * When using the fetch implementation and set to `true`, the browser will not abort the associated request if the page that initiated it is unloaded before the request is complete.\n     */\n    keepalive = false;\n    /**\n     * Controls how the request will interact with the browser's HTTP cache.\n     * This affects whether a response is retrieved from the cache, how it is stored, or if it bypasses the cache altogether.\n     */\n    cache;\n    /**\n     * Indicates the relative priority of the request. This may be used by the browser to decide the order in which requests are dispatched and resources fetched.\n     */\n    priority;\n    /**\n     * The mode of the request, which determines how the request will interact with the browser's security model.\n     * This can affect things like CORS (Cross-Origin Resource Sharing) and same-origin policies.\n     */\n    mode;\n    /**\n     * The redirect mode of the request, which determines how redirects are handled.\n     * This can affect whether the request follows redirects automatically, or if it fails when a redirect occurs.\n     */\n    redirect;\n    /**\n     * The expected response type of the server.\n     *\n     * This is used to parse the response appropriately before returning it to\n     * the requestee.\n     */\n    responseType = 'json';\n    /**\n     * The outgoing HTTP request method.\n     */\n    method;\n    /**\n     * Outgoing URL parameters.\n     *\n     * To pass a string representation of HTTP parameters in the URL-query-string format,\n     * the `HttpParamsOptions`' `fromString` may be used. For example:\n     *\n     * ```ts\n     * new HttpParams({fromString: 'angular=awesome'})\n     * ```\n     */\n    params;\n    /**\n     * The outgoing URL with all URL parameters set.\n     */\n    urlWithParams;\n    /**\n     * The HttpTransferCache option for the request\n     */\n    transferCache;\n    /**\n     * The timeout for the backend HTTP request in ms.\n     */\n    timeout;\n    constructor(method, url, third, fourth) {\n        this.url = url;\n        this.method = method.toUpperCase();\n        // Next, need to figure out which argument holds the HttpRequestInit\n        // options, if any.\n        let options;\n        // Check whether a body argument is expected. The only valid way to omit\n        // the body argument is to use a known no-body method like GET.\n        if (mightHaveBody(this.method) || !!fourth) {\n            // Body is the third argument, options are the fourth.\n            this.body = third !== undefined ? third : null;\n            options = fourth;\n        }\n        else {\n            // No body required, options are the third argument. The body stays null.\n            options = third;\n        }\n        // If options have been passed, interpret them.\n        if (options) {\n            // Normalize reportProgress and withCredentials.\n            this.reportProgress = !!options.reportProgress;\n            this.withCredentials = !!options.withCredentials;\n            this.keepalive = !!options.keepalive;\n            // Override default response type of 'json' if one is provided.\n            if (!!options.responseType) {\n                this.responseType = options.responseType;\n            }\n            // Override headers if they're provided.\n            if (options.headers) {\n                this.headers = options.headers;\n            }\n            if (options.context) {\n                this.context = options.context;\n            }\n            if (options.params) {\n                this.params = options.params;\n            }\n            if (options.priority) {\n                this.priority = options.priority;\n            }\n            if (options.cache) {\n                this.cache = options.cache;\n            }\n            if (options.credentials) {\n                this.credentials = options.credentials;\n            }\n            if (typeof options.timeout === 'number') {\n                // XHR will ignore any value below 1. AbortSignals only accept unsigned integers.\n                if (options.timeout < 1 || !Number.isInteger(options.timeout)) {\n                    // TODO: create a runtime error\n                    throw new Error(ngDevMode ? '`timeout` must be a positive integer value' : '');\n                }\n                this.timeout = options.timeout;\n            }\n            if (options.mode) {\n                this.mode = options.mode;\n            }\n            if (options.redirect) {\n                this.redirect = options.redirect;\n            }\n            // We do want to assign transferCache even if it's falsy (false is valid value)\n            this.transferCache = options.transferCache;\n        }\n        // If no headers have been passed in, construct a new HttpHeaders instance.\n        this.headers ??= new HttpHeaders();\n        // If no context have been passed in, construct a new HttpContext instance.\n        this.context ??= new HttpContext();\n        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.\n        if (!this.params) {\n            this.params = new HttpParams();\n            this.urlWithParams = url;\n        }\n        else {\n            // Encode the parameters to a string in preparation for inclusion in the URL.\n            const params = this.params.toString();\n            if (params.length === 0) {\n                // No parameters, the visible URL is just the URL given at creation time.\n                this.urlWithParams = url;\n            }\n            else {\n                // Does the URL already have query parameters? Look for '?'.\n                const qIdx = url.indexOf('?');\n                // There are 3 cases to handle:\n                // 1) No existing parameters -> append '?' followed by params.\n                // 2) '?' exists and is followed by existing query string ->\n                //    append '&' followed by params.\n                // 3) '?' exists at the end of the url -> append params directly.\n                // This basically amounts to determining the character, if any, with\n                // which to join the URL and parameters.\n                const sep = qIdx === -1 ? '?' : qIdx < url.length - 1 ? '&' : '';\n                this.urlWithParams = url + sep + params;\n            }\n        }\n    }\n    /**\n     * Transform the free-form body into a serialized format suitable for\n     * transmission to the server.\n     */\n    serializeBody() {\n        // If no body is present, no need to serialize it.\n        if (this.body === null) {\n            return null;\n        }\n        // Check whether the body is already in a serialized form. If so,\n        // it can just be returned directly.\n        if (typeof this.body === 'string' ||\n            isArrayBuffer(this.body) ||\n            isBlob(this.body) ||\n            isFormData(this.body) ||\n            isUrlSearchParams(this.body)) {\n            return this.body;\n        }\n        // Check whether the body is an instance of HttpUrlEncodedParams.\n        if (this.body instanceof HttpParams) {\n            return this.body.toString();\n        }\n        // Check whether the body is an object or array, and serialize with JSON if so.\n        if (typeof this.body === 'object' ||\n            typeof this.body === 'boolean' ||\n            Array.isArray(this.body)) {\n            return JSON.stringify(this.body);\n        }\n        // Fall back on toString() for everything else.\n        return this.body.toString();\n    }\n    /**\n     * Examine the body and attempt to infer an appropriate MIME type\n     * for it.\n     *\n     * If no such type can be inferred, this method will return `null`.\n     */\n    detectContentTypeHeader() {\n        // An empty body has no content type.\n        if (this.body === null) {\n            return null;\n        }\n        // FormData bodies rely on the browser's content type assignment.\n        if (isFormData(this.body)) {\n            return null;\n        }\n        // Blobs usually have their own content type. If it doesn't, then\n        // no type can be inferred.\n        if (isBlob(this.body)) {\n            return this.body.type || null;\n        }\n        // Array buffers have unknown contents and thus no type can be inferred.\n        if (isArrayBuffer(this.body)) {\n            return null;\n        }\n        // Technically, strings could be a form of JSON data, but it's safe enough\n        // to assume they're plain strings.\n        if (typeof this.body === 'string') {\n            return TEXT_CONTENT_TYPE;\n        }\n        // `HttpUrlEncodedParams` has its own content-type.\n        if (this.body instanceof HttpParams) {\n            return 'application/x-www-form-urlencoded;charset=UTF-8';\n        }\n        // Arrays, objects, boolean and numbers will be encoded as JSON.\n        if (typeof this.body === 'object' ||\n            typeof this.body === 'number' ||\n            typeof this.body === 'boolean') {\n            return JSON_CONTENT_TYPE;\n        }\n        // No type could be inferred.\n        return null;\n    }\n    clone(update = {}) {\n        // For method, url, and responseType, take the current value unless\n        // it is overridden in the update hash.\n        const method = update.method || this.method;\n        const url = update.url || this.url;\n        const responseType = update.responseType || this.responseType;\n        const keepalive = update.keepalive ?? this.keepalive;\n        const priority = update.priority || this.priority;\n        const cache = update.cache || this.cache;\n        const mode = update.mode || this.mode;\n        const redirect = update.redirect || this.redirect;\n        const credentials = update.credentials || this.credentials;\n        // Carefully handle the transferCache to differentiate between\n        // `false` and `undefined` in the update args.\n        const transferCache = update.transferCache ?? this.transferCache;\n        const timeout = update.timeout ?? this.timeout;\n        // The body is somewhat special - a `null` value in update.body means\n        // whatever current body is present is being overridden with an empty\n        // body, whereas an `undefined` value in update.body implies no\n        // override.\n        const body = update.body !== undefined ? update.body : this.body;\n        // Carefully handle the boolean options to differentiate between\n        // `false` and `undefined` in the update args.\n        const withCredentials = update.withCredentials ?? this.withCredentials;\n        const reportProgress = update.reportProgress ?? this.reportProgress;\n        // Headers and params may be appended to if `setHeaders` or\n        // `setParams` are used.\n        let headers = update.headers || this.headers;\n        let params = update.params || this.params;\n        // Pass on context if needed\n        const context = update.context ?? this.context;\n        // Check whether the caller has asked to add headers.\n        if (update.setHeaders !== undefined) {\n            // Set every requested header.\n            headers = Object.keys(update.setHeaders).reduce((headers, name) => headers.set(name, update.setHeaders[name]), headers);\n        }\n        // Check whether the caller has asked to set params.\n        if (update.setParams) {\n            // Set every requested param.\n            params = Object.keys(update.setParams).reduce((params, param) => params.set(param, update.setParams[param]), params);\n        }\n        // Finally, construct the new HttpRequest using the pieces from above.\n        return new HttpRequest(method, url, body, {\n            params,\n            headers,\n            context,\n            reportProgress,\n            responseType,\n            withCredentials,\n            transferCache,\n            keepalive,\n            cache,\n            priority,\n            timeout,\n            mode,\n            redirect,\n            credentials,\n        });\n    }\n}\n\n/**\n * Type enumeration for the different kinds of `HttpEvent`.\n *\n * @publicApi\n */\nvar HttpEventType;\n(function (HttpEventType) {\n    /**\n     * The request was sent out over the wire.\n     */\n    HttpEventType[HttpEventType[\"Sent\"] = 0] = \"Sent\";\n    /**\n     * An upload progress event was received.\n     *\n     * Note: The `FetchBackend` doesn't support progress report on uploads.\n     */\n    HttpEventType[HttpEventType[\"UploadProgress\"] = 1] = \"UploadProgress\";\n    /**\n     * The response status code and headers were received.\n     */\n    HttpEventType[HttpEventType[\"ResponseHeader\"] = 2] = \"ResponseHeader\";\n    /**\n     * A download progress event was received.\n     */\n    HttpEventType[HttpEventType[\"DownloadProgress\"] = 3] = \"DownloadProgress\";\n    /**\n     * The full response including the body was received.\n     */\n    HttpEventType[HttpEventType[\"Response\"] = 4] = \"Response\";\n    /**\n     * A custom event from an interceptor or a backend.\n     */\n    HttpEventType[HttpEventType[\"User\"] = 5] = \"User\";\n})(HttpEventType || (HttpEventType = {}));\n/**\n * Base class for both `HttpResponse` and `HttpHeaderResponse`.\n *\n * @publicApi\n */\nclass HttpResponseBase {\n    /**\n     * All response headers.\n     */\n    headers;\n    /**\n     * Response status code.\n     */\n    status;\n    /**\n     * Textual description of response status code, defaults to OK.\n     *\n     * Do not depend on this.\n     */\n    statusText;\n    /**\n     * URL of the resource retrieved, or null if not available.\n     */\n    url;\n    /**\n     * Whether the status code falls in the 2xx range.\n     */\n    ok;\n    /**\n     * Type of the response, narrowed to either the full response or the header.\n     */\n    type;\n    /**\n     * Super-constructor for all responses.\n     *\n     * The single parameter accepted is an initialization hash. Any properties\n     * of the response passed there will override the default values.\n     */\n    constructor(init, defaultStatus = 200, defaultStatusText = 'OK') {\n        // If the hash has values passed, use them to initialize the response.\n        // Otherwise use the default values.\n        this.headers = init.headers || new HttpHeaders();\n        this.status = init.status !== undefined ? init.status : defaultStatus;\n        this.statusText = init.statusText || defaultStatusText;\n        this.url = init.url || null;\n        // Cache the ok value to avoid defining a getter.\n        this.ok = this.status >= 200 && this.status < 300;\n    }\n}\n/**\n * A partial HTTP response which only includes the status and header data,\n * but no response body.\n *\n * `HttpHeaderResponse` is a `HttpEvent` available on the response\n * event stream, only when progress events are requested.\n *\n * @publicApi\n */\nclass HttpHeaderResponse extends HttpResponseBase {\n    /**\n     * Create a new `HttpHeaderResponse` with the given parameters.\n     */\n    constructor(init = {}) {\n        super(init);\n    }\n    type = HttpEventType.ResponseHeader;\n    /**\n     * Copy this `HttpHeaderResponse`, overriding its contents with the\n     * given parameter hash.\n     */\n    clone(update = {}) {\n        // Perform a straightforward initialization of the new HttpHeaderResponse,\n        // overriding the current parameters with new ones if given.\n        return new HttpHeaderResponse({\n            headers: update.headers || this.headers,\n            status: update.status !== undefined ? update.status : this.status,\n            statusText: update.statusText || this.statusText,\n            url: update.url || this.url || undefined,\n        });\n    }\n}\n/**\n * A full HTTP response, including a typed response body (which may be `null`\n * if one was not returned).\n *\n * `HttpResponse` is a `HttpEvent` available on the response event\n * stream.\n *\n * @publicApi\n */\nclass HttpResponse extends HttpResponseBase {\n    /**\n     * The response body, or `null` if one was not returned.\n     */\n    body;\n    /**\n     * Construct a new `HttpResponse`.\n     */\n    constructor(init = {}) {\n        super(init);\n        this.body = init.body !== undefined ? init.body : null;\n    }\n    type = HttpEventType.Response;\n    clone(update = {}) {\n        return new HttpResponse({\n            body: update.body !== undefined ? update.body : this.body,\n            headers: update.headers || this.headers,\n            status: update.status !== undefined ? update.status : this.status,\n            statusText: update.statusText || this.statusText,\n            url: update.url || this.url || undefined,\n        });\n    }\n}\n/**\n * A response that represents an error or failure, either from a\n * non-successful HTTP status, an error while executing the request,\n * or some other failure which occurred during the parsing of the response.\n *\n * Any error returned on the `Observable` response stream will be\n * wrapped in an `HttpErrorResponse` to provide additional context about\n * the state of the HTTP layer when the error occurred. The error property\n * will contain either a wrapped Error object or the error response returned\n * from the server.\n *\n * @publicApi\n */\nclass HttpErrorResponse extends HttpResponseBase {\n    name = 'HttpErrorResponse';\n    message;\n    error;\n    /**\n     * Errors are never okay, even when the status code is in the 2xx success range.\n     */\n    ok = false;\n    constructor(init) {\n        // Initialize with a default status of 0 / Unknown Error.\n        super(init, 0, 'Unknown Error');\n        // If the response was successful, then this was a parse error. Otherwise, it was\n        // a protocol-level failure of some sort. Either the request failed in transit\n        // or the server returned an unsuccessful status code.\n        if (this.status >= 200 && this.status < 300) {\n            this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;\n        }\n        else {\n            this.message = `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${init.statusText}`;\n        }\n        this.error = init.error || null;\n    }\n}\n/**\n * We use these constant to prevent pulling the whole HttpStatusCode enum\n * Those are the only ones referenced directly by the framework\n */\nconst HTTP_STATUS_CODE_OK = 200;\nconst HTTP_STATUS_CODE_NO_CONTENT = 204;\n/**\n * Http status codes.\n * As per https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n * @publicApi\n */\nvar HttpStatusCode;\n(function (HttpStatusCode) {\n    HttpStatusCode[HttpStatusCode[\"Continue\"] = 100] = \"Continue\";\n    HttpStatusCode[HttpStatusCode[\"SwitchingProtocols\"] = 101] = \"SwitchingProtocols\";\n    HttpStatusCode[HttpStatusCode[\"Processing\"] = 102] = \"Processing\";\n    HttpStatusCode[HttpStatusCode[\"EarlyHints\"] = 103] = \"EarlyHints\";\n    HttpStatusCode[HttpStatusCode[\"Ok\"] = 200] = \"Ok\";\n    HttpStatusCode[HttpStatusCode[\"Created\"] = 201] = \"Created\";\n    HttpStatusCode[HttpStatusCode[\"Accepted\"] = 202] = \"Accepted\";\n    HttpStatusCode[HttpStatusCode[\"NonAuthoritativeInformation\"] = 203] = \"NonAuthoritativeInformation\";\n    HttpStatusCode[HttpStatusCode[\"NoContent\"] = 204] = \"NoContent\";\n    HttpStatusCode[HttpStatusCode[\"ResetContent\"] = 205] = \"ResetContent\";\n    HttpStatusCode[HttpStatusCode[\"PartialContent\"] = 206] = \"PartialContent\";\n    HttpStatusCode[HttpStatusCode[\"MultiStatus\"] = 207] = \"MultiStatus\";\n    HttpStatusCode[HttpStatusCode[\"AlreadyReported\"] = 208] = \"AlreadyReported\";\n    HttpStatusCode[HttpStatusCode[\"ImUsed\"] = 226] = \"ImUsed\";\n    HttpStatusCode[HttpStatusCode[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpStatusCode[HttpStatusCode[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpStatusCode[HttpStatusCode[\"Found\"] = 302] = \"Found\";\n    HttpStatusCode[HttpStatusCode[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpStatusCode[HttpStatusCode[\"NotModified\"] = 304] = \"NotModified\";\n    HttpStatusCode[HttpStatusCode[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpStatusCode[HttpStatusCode[\"Unused\"] = 306] = \"Unused\";\n    HttpStatusCode[HttpStatusCode[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpStatusCode[HttpStatusCode[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpStatusCode[HttpStatusCode[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpStatusCode[HttpStatusCode[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpStatusCode[HttpStatusCode[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpStatusCode[HttpStatusCode[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpStatusCode[HttpStatusCode[\"NotFound\"] = 404] = \"NotFound\";\n    HttpStatusCode[HttpStatusCode[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpStatusCode[HttpStatusCode[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpStatusCode[HttpStatusCode[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpStatusCode[HttpStatusCode[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpStatusCode[HttpStatusCode[\"Conflict\"] = 409] = \"Conflict\";\n    HttpStatusCode[HttpStatusCode[\"Gone\"] = 410] = \"Gone\";\n    HttpStatusCode[HttpStatusCode[\"LengthRequired\"] = 411] = \"LengthRequired\";\n    HttpStatusCode[HttpStatusCode[\"PreconditionFailed\"] = 412] = \"PreconditionFailed\";\n    HttpStatusCode[HttpStatusCode[\"PayloadTooLarge\"] = 413] = \"PayloadTooLarge\";\n    HttpStatusCode[HttpStatusCode[\"UriTooLong\"] = 414] = \"UriTooLong\";\n    HttpStatusCode[HttpStatusCode[\"UnsupportedMediaType\"] = 415] = \"UnsupportedMediaType\";\n    HttpStatusCode[HttpStatusCode[\"RangeNotSatisfiable\"] = 416] = \"RangeNotSatisfiable\";\n    HttpStatusCode[HttpStatusCode[\"ExpectationFailed\"] = 417] = \"ExpectationFailed\";\n    HttpStatusCode[HttpStatusCode[\"ImATeapot\"] = 418] = \"ImATeapot\";\n    HttpStatusCode[HttpStatusCode[\"MisdirectedRequest\"] = 421] = \"MisdirectedRequest\";\n    HttpStatusCode[HttpStatusCode[\"UnprocessableEntity\"] = 422] = \"UnprocessableEntity\";\n    HttpStatusCode[HttpStatusCode[\"Locked\"] = 423] = \"Locked\";\n    HttpStatusCode[HttpStatusCode[\"FailedDependency\"] = 424] = \"FailedDependency\";\n    HttpStatusCode[HttpStatusCode[\"TooEarly\"] = 425] = \"TooEarly\";\n    HttpStatusCode[HttpStatusCode[\"UpgradeRequired\"] = 426] = \"UpgradeRequired\";\n    HttpStatusCode[HttpStatusCode[\"PreconditionRequired\"] = 428] = \"PreconditionRequired\";\n    HttpStatusCode[HttpStatusCode[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpStatusCode[HttpStatusCode[\"RequestHeaderFieldsTooLarge\"] = 431] = \"RequestHeaderFieldsTooLarge\";\n    HttpStatusCode[HttpStatusCode[\"UnavailableForLegalReasons\"] = 451] = \"UnavailableForLegalReasons\";\n    HttpStatusCode[HttpStatusCode[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpStatusCode[HttpStatusCode[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpStatusCode[HttpStatusCode[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpStatusCode[HttpStatusCode[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpStatusCode[HttpStatusCode[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n    HttpStatusCode[HttpStatusCode[\"HttpVersionNotSupported\"] = 505] = \"HttpVersionNotSupported\";\n    HttpStatusCode[HttpStatusCode[\"VariantAlsoNegotiates\"] = 506] = \"VariantAlsoNegotiates\";\n    HttpStatusCode[HttpStatusCode[\"InsufficientStorage\"] = 507] = \"InsufficientStorage\";\n    HttpStatusCode[HttpStatusCode[\"LoopDetected\"] = 508] = \"LoopDetected\";\n    HttpStatusCode[HttpStatusCode[\"NotExtended\"] = 510] = \"NotExtended\";\n    HttpStatusCode[HttpStatusCode[\"NetworkAuthenticationRequired\"] = 511] = \"NetworkAuthenticationRequired\";\n})(HttpStatusCode || (HttpStatusCode = {}));\n\n/**\n * Constructs an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. This function clones the object and adds the body.\n *\n * Note that the `responseType` *options* value is a String that identifies the\n * single data type of the response.\n * A single overload version of the method handles each response type.\n * The value of `responseType` cannot be a union, as the combined signature could imply.\n *\n */\nfunction addBody(options, body) {\n    return {\n        body,\n        headers: options.headers,\n        context: options.context,\n        observe: options.observe,\n        params: options.params,\n        reportProgress: options.reportProgress,\n        responseType: options.responseType,\n        withCredentials: options.withCredentials,\n        transferCache: options.transferCache,\n        keepalive: options.keepalive,\n        priority: options.priority,\n        cache: options.cache,\n        mode: options.mode,\n        redirect: options.redirect,\n    };\n}\n/**\n * Performs HTTP requests.\n * This service is available as an injectable class, with methods to perform HTTP requests.\n * Each request method has multiple signatures, and the return type varies based on\n * the signature that is called (mainly the values of `observe` and `responseType`).\n *\n * Note that the `responseType` *options* value is a String that identifies the\n * single data type of the response.\n * A single overload version of the method handles each response type.\n * The value of `responseType` cannot be a union, as the combined signature could imply.\n *\n * @usageNotes\n *\n * ### HTTP Request Example\n *\n * ```ts\n *  // GET heroes whose name contains search term\n * searchHeroes(term: string): observable<Hero[]>{\n *\n *  const params = new HttpParams({fromString: 'name=term'});\n *    return this.httpClient.request('GET', this.heroesUrl, {responseType:'json', params});\n * }\n * ```\n *\n * Alternatively, the parameter string can be used without invoking HttpParams\n * by directly joining to the URL.\n * ```ts\n * this.httpClient.request('GET', this.heroesUrl + '?' + 'name=term', {responseType:'json'});\n * ```\n *\n *\n * ### JSONP Example\n * ```ts\n * requestJsonp(url, callback = 'callback') {\n *  return this.httpClient.jsonp(this.heroesURL, callback);\n * }\n * ```\n *\n * ### PATCH Example\n * ```ts\n * // PATCH one of the heroes' name\n * patchHero (id: number, heroName: string): Observable<{}> {\n * const url = `${this.heroesUrl}/${id}`;   // PATCH api/heroes/42\n *  return this.httpClient.patch(url, {name: heroName}, httpOptions)\n *    .pipe(catchError(this.handleError('patchHero')));\n * }\n * ```\n *\n * @see [HTTP Guide](guide/http)\n * @see [HTTP Request](api/common/http/HttpRequest)\n *\n * @publicApi\n */\nclass HttpClient {\n    handler;\n    constructor(handler) {\n        this.handler = handler;\n    }\n    /**\n     * Constructs an observable for a generic HTTP request that, when subscribed,\n     * fires the request through the chain of registered interceptors and on to the\n     * server.\n     *\n     * You can pass an `HttpRequest` directly as the only parameter. In this case,\n     * the call returns an observable of the raw `HttpEvent` stream.\n     *\n     * Alternatively you can pass an HTTP method as the first parameter,\n     * a URL string as the second, and an options hash containing the request body as the third.\n     * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the\n     * type of returned observable.\n     *   * The `responseType` value determines how a successful response body is parsed.\n     *   * If `responseType` is the default `json`, you can pass a type interface for the resulting\n     * object as a type parameter to the call.\n     *\n     * The `observe` value determines the return type, according to what you are interested in\n     * observing.\n     *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including\n     * progress events by default.\n     *   * An `observe` value of response returns an observable of `HttpResponse<T>`,\n     * where the `T` parameter depends on the `responseType` and any optionally provided type\n     * parameter.\n     *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.\n     *\n     */\n    request(first, url, options = {}) {\n        let req;\n        // First, check whether the primary argument is an instance of `HttpRequest`.\n        if (first instanceof HttpRequest) {\n            // It is. The other arguments must be undefined (per the signatures) and can be\n            // ignored.\n            req = first;\n        }\n        else {\n            // It's a string, so it represents a URL. Construct a request based on it,\n            // and incorporate the remaining arguments (assuming `GET` unless a method is\n            // provided.\n            // Figure out the headers.\n            let headers = undefined;\n            if (options.headers instanceof HttpHeaders) {\n                headers = options.headers;\n            }\n            else {\n                headers = new HttpHeaders(options.headers);\n            }\n            // Sort out parameters.\n            let params = undefined;\n            if (!!options.params) {\n                if (options.params instanceof HttpParams) {\n                    params = options.params;\n                }\n                else {\n                    params = new HttpParams({ fromObject: options.params });\n                }\n            }\n            // Construct the request.\n            req = new HttpRequest(first, url, options.body !== undefined ? options.body : null, {\n                headers,\n                context: options.context,\n                params,\n                reportProgress: options.reportProgress,\n                // By default, JSON is assumed to be returned for all calls.\n                responseType: options.responseType || 'json',\n                withCredentials: options.withCredentials,\n                transferCache: options.transferCache,\n                keepalive: options.keepalive,\n                priority: options.priority,\n                cache: options.cache,\n                mode: options.mode,\n                redirect: options.redirect,\n                credentials: options.credentials,\n            });\n        }\n        // Start with an Observable.of() the initial request, and run the handler (which\n        // includes all interceptors) inside a concatMap(). This way, the handler runs\n        // inside an Observable chain, which causes interceptors to be re-run on every\n        // subscription (this also makes retries re-run the handler, including interceptors).\n        const events$ = of(req).pipe(concatMap((req) => this.handler.handle(req)));\n        // If coming via the API signature which accepts a previously constructed HttpRequest,\n        // the only option is to get the event stream. Otherwise, return the event stream if\n        // that is what was requested.\n        if (first instanceof HttpRequest || options.observe === 'events') {\n            return events$;\n        }\n        // The requested stream contains either the full response or the body. In either\n        // case, the first step is to filter the event stream to extract a stream of\n        // responses(s).\n        const res$ = (events$.pipe(filter((event) => event instanceof HttpResponse)));\n        // Decide which stream to return.\n        switch (options.observe || 'body') {\n            case 'body':\n                // The requested stream is the body. Map the response stream to the response\n                // body. This could be done more simply, but a misbehaving interceptor might\n                // transform the response body into a different format and ignore the requested\n                // responseType. Guard against this by validating that the response is of the\n                // requested type.\n                switch (req.responseType) {\n                    case 'arraybuffer':\n                        return res$.pipe(map((res) => {\n                            // Validate that the body is an ArrayBuffer.\n                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                                throw new _RuntimeError(2806 /* RuntimeErrorCode.RESPONSE_IS_NOT_AN_ARRAY_BUFFER */, ngDevMode && 'Response is not an ArrayBuffer.');\n                            }\n                            return res.body;\n                        }));\n                    case 'blob':\n                        return res$.pipe(map((res) => {\n                            // Validate that the body is a Blob.\n                            if (res.body !== null && !(res.body instanceof Blob)) {\n                                throw new _RuntimeError(2807 /* RuntimeErrorCode.RESPONSE_IS_NOT_A_BLOB */, ngDevMode && 'Response is not a Blob.');\n                            }\n                            return res.body;\n                        }));\n                    case 'text':\n                        return res$.pipe(map((res) => {\n                            // Validate that the body is a string.\n                            if (res.body !== null && typeof res.body !== 'string') {\n                                throw new _RuntimeError(2808 /* RuntimeErrorCode.RESPONSE_IS_NOT_A_STRING */, ngDevMode && 'Response is not a string.');\n                            }\n                            return res.body;\n                        }));\n                    case 'json':\n                    default:\n                        // No validation needed for JSON responses, as they can be of any type.\n                        return res$.pipe(map((res) => res.body));\n                }\n            case 'response':\n                // The response stream was requested directly, so return it.\n                return res$;\n            default:\n                // Guard against new future observe types being added.\n                throw new _RuntimeError(2809 /* RuntimeErrorCode.UNHANDLED_OBSERVE_TYPE */, ngDevMode && `Unreachable: unhandled observe type ${options.observe}}`);\n        }\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `DELETE` request to execute on the server. See the individual overloads for\n     * details on the return type.\n     *\n     * @param url     The endpoint URL.\n     * @param options The HTTP options to send with the request.\n     *\n     */\n    delete(url, options = {}) {\n        return this.request('DELETE', url, options);\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `GET` request to execute on the server. See the individual overloads for\n     * details on the return type.\n     */\n    get(url, options = {}) {\n        return this.request('GET', url, options);\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `HEAD` request to execute on the server. The `HEAD` method returns\n     * meta information about the resource without transferring the\n     * resource itself. See the individual overloads for\n     * details on the return type.\n     */\n    head(url, options = {}) {\n        return this.request('HEAD', url, options);\n    }\n    /**\n     * Constructs an `Observable` that, when subscribed, causes a request with the special method\n     * `JSONP` to be dispatched via the interceptor pipeline.\n     * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain\n     * API endpoints that don't support newer,\n     * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.\n     * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the\n     * requests even if the API endpoint is not located on the same domain (origin) as the client-side\n     * application making the request.\n     * The endpoint API must support JSONP callback for JSONP requests to work.\n     * The resource API returns the JSON response wrapped in a callback function.\n     * You can pass the callback function name as one of the query parameters.\n     * Note that JSONP requests can only be used with `GET` requests.\n     *\n     * @param url The resource URL.\n     * @param callbackParam The callback function name.\n     *\n     */\n    jsonp(url, callbackParam) {\n        return this.request('JSONP', url, {\n            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n            observe: 'body',\n            responseType: 'json',\n        });\n    }\n    /**\n     * Constructs an `Observable` that, when subscribed, causes the configured\n     * `OPTIONS` request to execute on the server. This method allows the client\n     * to determine the supported HTTP methods and other capabilities of an endpoint,\n     * without implying a resource action. See the individual overloads for\n     * details on the return type.\n     */\n    options(url, options = {}) {\n        return this.request('OPTIONS', url, options);\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `PATCH` request to execute on the server. See the individual overloads for\n     * details on the return type.\n     */\n    patch(url, body, options = {}) {\n        return this.request('PATCH', url, addBody(options, body));\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `POST` request to execute on the server. The server responds with the location of\n     * the replaced resource. See the individual overloads for\n     * details on the return type.\n     */\n    post(url, body, options = {}) {\n        return this.request('POST', url, addBody(options, body));\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `PUT` request to execute on the server. The `PUT` method replaces an existing resource\n     * with a new set of values.\n     * See the individual overloads for details on the return type.\n     */\n    put(url, body, options = {}) {\n        return this.request('PUT', url, addBody(options, body));\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClient, deps: [{ token: HttpHandler }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClient });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClient, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: HttpHandler }] });\n\nconst XSSI_PREFIX$1 = /^\\)\\]\\}',?\\n/;\n/**\n * Determine an appropriate URL for the response, by checking either\n * response url or the X-Request-URL header.\n */\nfunction getResponseUrl$1(response) {\n    if (response.url) {\n        return response.url;\n    }\n    // stored as lowercase in the map\n    const xRequestUrl = X_REQUEST_URL_HEADER.toLocaleLowerCase();\n    return response.headers.get(xRequestUrl);\n}\n/**\n * An internal injection token to reference `FetchBackend` implementation\n * in a tree-shakable way.\n */\nconst FETCH_BACKEND = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'FETCH_BACKEND' : '');\n/**\n * Uses `fetch` to send requests to a backend server.\n *\n * This `FetchBackend` requires the support of the\n * [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) which is available on all\n * supported browsers and on Node.js v18 or later.\n *\n * @see {@link HttpHandler}\n *\n * @publicApi\n */\nclass FetchBackend {\n    // We use an arrow function to always reference the current global implementation of `fetch`.\n    // This is helpful for cases when the global `fetch` implementation is modified by external code,\n    // see https://github.com/angular/angular/issues/57527.\n    fetchImpl = inject(FetchFactory, { optional: true })?.fetch ?? ((...args) => globalThis.fetch(...args));\n    ngZone = inject(NgZone);\n    destroyRef = inject(DestroyRef);\n    destroyed = false;\n    constructor() {\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    handle(request) {\n        return new Observable((observer) => {\n            const aborter = new AbortController();\n            this.doRequest(request, aborter.signal, observer).then(noop, (error) => observer.error(new HttpErrorResponse({ error })));\n            let timeoutId;\n            if (request.timeout) {\n                // TODO: Replace with AbortSignal.any([aborter.signal, AbortSignal.timeout(request.timeout)])\n                // when AbortSignal.any support is Baseline widely available (NET nov. 2026)\n                timeoutId = this.ngZone.runOutsideAngular(() => setTimeout(() => {\n                    if (!aborter.signal.aborted) {\n                        aborter.abort(new DOMException('signal timed out', 'TimeoutError'));\n                    }\n                }, request.timeout));\n            }\n            return () => {\n                if (timeoutId !== undefined) {\n                    clearTimeout(timeoutId);\n                }\n                aborter.abort();\n            };\n        });\n    }\n    async doRequest(request, signal, observer) {\n        const init = this.createRequestInit(request);\n        let response;\n        try {\n            // Run fetch outside of Angular zone.\n            // This is due to Node.js fetch implementation (Undici) which uses a number of setTimeouts to check if\n            // the response should eventually timeout which causes extra CD cycles every 500ms\n            const fetchPromise = this.ngZone.runOutsideAngular(() => this.fetchImpl(request.urlWithParams, { signal, ...init }));\n            // Make sure Zone.js doesn't trigger false-positive unhandled promise\n            // error in case the Promise is rejected synchronously. See function\n            // description for additional information.\n            silenceSuperfluousUnhandledPromiseRejection(fetchPromise);\n            // Send the `Sent` event before awaiting the response.\n            observer.next({ type: HttpEventType.Sent });\n            response = await fetchPromise;\n        }\n        catch (error) {\n            observer.error(new HttpErrorResponse({\n                error,\n                status: error.status ?? 0,\n                statusText: error.statusText,\n                url: request.urlWithParams,\n                headers: error.headers,\n            }));\n            return;\n        }\n        const headers = new HttpHeaders(response.headers);\n        const statusText = response.statusText;\n        const url = getResponseUrl$1(response) ?? request.urlWithParams;\n        let status = response.status;\n        let body = null;\n        if (request.reportProgress) {\n            observer.next(new HttpHeaderResponse({ headers, status, statusText, url }));\n        }\n        if (response.body) {\n            // Read Progress\n            const contentLength = response.headers.get('content-length');\n            const chunks = [];\n            const reader = response.body.getReader();\n            let receivedLength = 0;\n            let decoder;\n            let partialText;\n            // We have to check whether the Zone is defined in the global scope because this may be called\n            // when the zone is nooped.\n            const reqZone = typeof Zone !== 'undefined' && Zone.current;\n            let canceled = false;\n            // Perform response processing outside of Angular zone to\n            // ensure no excessive change detection runs are executed\n            // Here calling the async ReadableStreamDefaultReader.read() is responsible for triggering CD\n            await this.ngZone.runOutsideAngular(async () => {\n                while (true) {\n                    // Prevent reading chunks if the app is destroyed. Otherwise, we risk doing\n                    // unnecessary work or triggering side effects after teardown.\n                    // This may happen if the app was explicitly destroyed before\n                    // the response returned entirely.\n                    if (this.destroyed) {\n                        // Streams left in a pending state (due to `break` without cancel) may\n                        // continue consuming or holding onto data behind the scenes.\n                        // Calling `reader.cancel()` allows the browser or the underlying\n                        // system to release any network or memory resources associated with the stream.\n                        await reader.cancel();\n                        canceled = true;\n                        break;\n                    }\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    chunks.push(value);\n                    receivedLength += value.length;\n                    if (request.reportProgress) {\n                        partialText =\n                            request.responseType === 'text'\n                                ? (partialText ?? '') +\n                                    (decoder ??= new TextDecoder()).decode(value, { stream: true })\n                                : undefined;\n                        const reportProgress = () => observer.next({\n                            type: HttpEventType.DownloadProgress,\n                            total: contentLength ? +contentLength : undefined,\n                            loaded: receivedLength,\n                            partialText,\n                        });\n                        reqZone ? reqZone.run(reportProgress) : reportProgress();\n                    }\n                }\n            });\n            // We need to manage the canceled state — because the Streams API does not\n            // expose a direct `.state` property on the reader.\n            // We need to `return` because `parseBody` may not be able to parse chunks\n            // that were only partially read (due to cancellation caused by app destruction).\n            if (canceled) {\n                observer.complete();\n                return;\n            }\n            // Combine all chunks.\n            const chunksAll = this.concatChunks(chunks, receivedLength);\n            try {\n                const contentType = response.headers.get(CONTENT_TYPE_HEADER) ?? '';\n                body = this.parseBody(request, chunksAll, contentType, status);\n            }\n            catch (error) {\n                // Body loading or parsing failed\n                observer.error(new HttpErrorResponse({\n                    error,\n                    headers: new HttpHeaders(response.headers),\n                    status: response.status,\n                    statusText: response.statusText,\n                    url: getResponseUrl$1(response) ?? request.urlWithParams,\n                }));\n                return;\n            }\n        }\n        // Same behavior as the XhrBackend\n        if (status === 0) {\n            status = body ? HTTP_STATUS_CODE_OK : 0;\n        }\n        // ok determines whether the response will be transmitted on the event or\n        // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n        // but a successful status code can still result in an error if the user\n        // asked for JSON data and the body cannot be parsed as such.\n        const ok = status >= 200 && status < 300;\n        if (ok) {\n            observer.next(new HttpResponse({\n                body,\n                headers,\n                status,\n                statusText,\n                url,\n            }));\n            // The full body has been received and delivered, no further events\n            // are possible. This request is complete.\n            observer.complete();\n        }\n        else {\n            observer.error(new HttpErrorResponse({\n                error: body,\n                headers,\n                status,\n                statusText,\n                url,\n            }));\n        }\n    }\n    parseBody(request, binContent, contentType, status) {\n        switch (request.responseType) {\n            case 'json':\n                // stripping the XSSI when present\n                const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, '');\n                if (text === '') {\n                    return null;\n                }\n                try {\n                    return JSON.parse(text);\n                }\n                catch (e) {\n                    // Allow handling non-JSON errors (!) as plain text, same as the XHR\n                    // backend. Without this special sauce, any non-JSON error would be\n                    // completely inaccessible downstream as the `HttpErrorResponse.error`\n                    // would be set to the `SyntaxError` from then failing `JSON.parse`.\n                    if (status < 200 || status >= 300) {\n                        return text;\n                    }\n                    throw e;\n                }\n            case 'text':\n                return new TextDecoder().decode(binContent);\n            case 'blob':\n                return new Blob([binContent], { type: contentType });\n            case 'arraybuffer':\n                return binContent.buffer;\n        }\n    }\n    createRequestInit(req) {\n        // We could share some of this logic with the XhrBackend\n        const headers = {};\n        let credentials;\n        // If the request has a credentials property, use it.\n        // Otherwise, if the request has withCredentials set to true, use 'include'.\n        credentials = req.credentials;\n        // If withCredentials is true should be set to 'include', for compatibility\n        if (req.withCredentials) {\n            // A warning is logged in development mode if the request has both\n            (typeof ngDevMode === 'undefined' || ngDevMode) && warningOptionsMessage(req);\n            credentials = 'include';\n        }\n        // Setting all the requested headers.\n        req.headers.forEach((name, values) => (headers[name] = values.join(',')));\n        // Add an Accept header if one isn't present already.\n        if (!req.headers.has(ACCEPT_HEADER)) {\n            headers[ACCEPT_HEADER] = ACCEPT_HEADER_VALUE;\n        }\n        // Auto-detect the Content-Type header if one isn't present already.\n        if (!req.headers.has(CONTENT_TYPE_HEADER)) {\n            const detectedType = req.detectContentTypeHeader();\n            // Sometimes Content-Type detection fails.\n            if (detectedType !== null) {\n                headers[CONTENT_TYPE_HEADER] = detectedType;\n            }\n        }\n        return {\n            body: req.serializeBody(),\n            method: req.method,\n            headers,\n            credentials,\n            keepalive: req.keepalive,\n            cache: req.cache,\n            priority: req.priority,\n            mode: req.mode,\n            redirect: req.redirect,\n        };\n    }\n    concatChunks(chunks, totalLength) {\n        const chunksAll = new Uint8Array(totalLength);\n        let position = 0;\n        for (const chunk of chunks) {\n            chunksAll.set(chunk, position);\n            position += chunk.length;\n        }\n        return chunksAll;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: FetchBackend, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: FetchBackend });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: FetchBackend, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [] });\n/**\n * Abstract class to provide a mocked implementation of `fetch()`\n */\nclass FetchFactory {\n}\nfunction noop() { }\nfunction warningOptionsMessage(req) {\n    if (req.credentials && req.withCredentials) {\n        console.warn(_formatRuntimeError(2819 /* RuntimeErrorCode.WITH_CREDENTIALS_OVERRIDES_EXPLICIT_CREDENTIALS */, `Angular detected that a \\`HttpClient\\` request has both \\`withCredentials: true\\` and \\`credentials: '${req.credentials}'\\` options. The \\`withCredentials\\` option is overriding the explicit \\`credentials\\` setting to 'include'. Consider removing \\`withCredentials\\` and using \\`credentials: '${req.credentials}'\\` directly for clarity.`));\n    }\n}\n/**\n * Zone.js treats a rejected promise that has not yet been awaited\n * as an unhandled error. This function adds a noop `.then` to make\n * sure that Zone.js doesn't throw an error if the Promise is rejected\n * synchronously.\n */\nfunction silenceSuperfluousUnhandledPromiseRejection(promise) {\n    promise.then(noop, noop);\n}\n\nfunction interceptorChainEndFn(req, finalHandlerFn) {\n    return finalHandlerFn(req);\n}\n/**\n * Constructs a `ChainedInterceptorFn` which adapts a legacy `HttpInterceptor` to the\n * `ChainedInterceptorFn` interface.\n */\nfunction adaptLegacyInterceptorToChain(chainTailFn, interceptor) {\n    return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {\n        handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn),\n    });\n}\n/**\n * Constructs a `ChainedInterceptorFn` which wraps and invokes a functional interceptor in the given\n * injector.\n */\nfunction chainedInterceptorFn(chainTailFn, interceptorFn, injector) {\n    return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)));\n}\n/**\n * A multi-provider token that represents the array of registered\n * `HttpInterceptor` objects.\n *\n * @publicApi\n */\nconst HTTP_INTERCEPTORS = new InjectionToken(ngDevMode ? 'HTTP_INTERCEPTORS' : '');\n/**\n * A multi-provided token of `HttpInterceptorFn`s.\n */\nconst HTTP_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? 'HTTP_INTERCEPTOR_FNS' : '');\n/**\n * A multi-provided token of `HttpInterceptorFn`s that are only set in root.\n */\nconst HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? 'HTTP_ROOT_INTERCEPTOR_FNS' : '');\n// TODO(atscott): We need a larger discussion about stability and what should contribute to stability.\n// Should the whole interceptor chain contribute to stability or just the backend request #55075?\n// Should HttpClient contribute to stability automatically at all?\nconst REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken(ngDevMode ? 'REQUESTS_CONTRIBUTE_TO_STABILITY' : '', { providedIn: 'root', factory: () => true });\n/**\n * Creates an `HttpInterceptorFn` which lazily initializes an interceptor chain from the legacy\n * class-based interceptors and runs the request through it.\n */\nfunction legacyInterceptorFnFactory() {\n    let chain = null;\n    return (req, handler) => {\n        if (chain === null) {\n            const interceptors = inject(HTTP_INTERCEPTORS, { optional: true }) ?? [];\n            // Note: interceptors are wrapped right-to-left so that final execution order is\n            // left-to-right. That is, if `interceptors` is the array `[a, b, c]`, we want to\n            // produce a chain that is conceptually `c(b(a(end)))`, which we build from the inside\n            // out.\n            chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);\n        }\n        const pendingTasks = inject(PendingTasks);\n        const contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);\n        if (contributeToStability) {\n            const removeTask = pendingTasks.add();\n            return chain(req, handler).pipe(finalize(removeTask));\n        }\n        else {\n            return chain(req, handler);\n        }\n    };\n}\nlet fetchBackendWarningDisplayed = false;\nclass HttpInterceptorHandler extends HttpHandler {\n    backend;\n    injector;\n    chain = null;\n    pendingTasks = inject(PendingTasks);\n    contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);\n    constructor(backend, injector) {\n        super();\n        this.backend = backend;\n        this.injector = injector;\n        // We strongly recommend using fetch backend for HTTP calls when SSR is used\n        // for an application. The logic below checks if that's the case and produces\n        // a warning otherwise.\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !fetchBackendWarningDisplayed) {\n            // This flag is necessary because provideHttpClientTesting() overrides the backend\n            // even if `withFetch()` is used within the test. When the testing HTTP backend is provided,\n            // no HTTP calls are actually performed during the test, so producing a warning would be\n            // misleading.\n            const isTestingBackend = this.backend.isTestingBackend;\n            if (typeof ngServerMode !== 'undefined' &&\n                ngServerMode &&\n                !(this.backend instanceof FetchBackend) &&\n                !isTestingBackend) {\n                fetchBackendWarningDisplayed = true;\n                injector\n                    .get(_Console)\n                    .warn(_formatRuntimeError(2801 /* RuntimeErrorCode.NOT_USING_FETCH_BACKEND_IN_SSR */, 'Angular detected that `HttpClient` is not configured ' +\n                    \"to use `fetch` APIs. It's strongly recommended to \" +\n                    'enable `fetch` for applications that use Server-Side Rendering ' +\n                    'for better performance and compatibility. ' +\n                    'To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` ' +\n                    'call at the root of the application.'));\n            }\n        }\n    }\n    handle(initialRequest) {\n        if (this.chain === null) {\n            const dedupedInterceptorFns = Array.from(new Set([\n                ...this.injector.get(HTTP_INTERCEPTOR_FNS),\n                ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, []),\n            ]));\n            // Note: interceptors are wrapped right-to-left so that final execution order is\n            // left-to-right. That is, if `dedupedInterceptorFns` is the array `[a, b, c]`, we want to\n            // produce a chain that is conceptually `c(b(a(end)))`, which we build from the inside\n            // out.\n            this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);\n        }\n        if (this.contributeToStability) {\n            const removeTask = this.pendingTasks.add();\n            return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest)).pipe(finalize(removeTask));\n        }\n        else {\n            return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest));\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpInterceptorHandler, deps: [{ token: HttpBackend }, { token: i0.EnvironmentInjector }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpInterceptorHandler });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpInterceptorHandler, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: HttpBackend }, { type: i0.EnvironmentInjector }] });\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet nextRequestId = 0;\n/**\n * When a pending <script> is unsubscribed we'll move it to this document, so it won't be\n * executed.\n */\nlet foreignDocument;\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nconst JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nconst JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nconst JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n// Error text given when a request is passed to the JsonpClientBackend that has\n// headers set\nconst JSONP_ERR_HEADERS_NOT_SUPPORTED = 'JSONP requests do not support headers.';\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n *\n * In the browser, this should always be the `window` object.\n *\n *\n */\nclass JsonpCallbackContext {\n}\n/**\n * Factory function that determines where to store JSONP callbacks.\n *\n * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist\n * in test environments. In that case, callbacks are stored on an anonymous object instead.\n *\n *\n */\nfunction jsonpCallbackContext() {\n    if (typeof window === 'object') {\n        return window;\n    }\n    return {};\n}\n/**\n * Processes an `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n * @see {@link HttpHandler}\n * @see {@link HttpXhrBackend}\n *\n * @publicApi\n */\nclass JsonpClientBackend {\n    callbackMap;\n    document;\n    /**\n     * A resolved promise that can be used to schedule microtasks in the event handlers.\n     */\n    resolvedPromise = Promise.resolve();\n    constructor(callbackMap, document) {\n        this.callbackMap = callbackMap;\n        this.document = document;\n    }\n    /**\n     * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n     */\n    nextCallback() {\n        return `ng_jsonp_callback_${nextRequestId++}`;\n    }\n    /**\n     * Processes a JSONP request and returns an event stream of the results.\n     * @param req The request object.\n     * @returns An observable of the response events.\n     *\n     */\n    handle(req) {\n        // Firstly, check both the method and response type. If either doesn't match\n        // then the request was improperly routed here and cannot be handled.\n        if (req.method !== 'JSONP') {\n            throw new _RuntimeError(2810 /* RuntimeErrorCode.JSONP_WRONG_METHOD */, ngDevMode && JSONP_ERR_WRONG_METHOD);\n        }\n        else if (req.responseType !== 'json') {\n            throw new _RuntimeError(2811 /* RuntimeErrorCode.JSONP_WRONG_RESPONSE_TYPE */, ngDevMode && JSONP_ERR_WRONG_RESPONSE_TYPE);\n        }\n        // Check the request headers. JSONP doesn't support headers and\n        // cannot set any that were supplied.\n        if (req.headers.keys().length > 0) {\n            throw new _RuntimeError(2812 /* RuntimeErrorCode.JSONP_HEADERS_NOT_SUPPORTED */, ngDevMode && JSONP_ERR_HEADERS_NOT_SUPPORTED);\n        }\n        // Everything else happens inside the Observable boundary.\n        return new Observable((observer) => {\n            // The first step to make a request is to generate the callback name, and replace the\n            // callback placeholder in the URL with the name. Care has to be taken here to ensure\n            // a trailing &, if matched, gets inserted back into the URL in the correct place.\n            const callback = this.nextCallback();\n            const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n            // Construct the <script> tag and point it at the URL.\n            const node = this.document.createElement('script');\n            node.src = url;\n            // A JSONP request requires waiting for multiple callbacks. These variables\n            // are closed over and track state across those callbacks.\n            // The response object, if one has been received, or null otherwise.\n            let body = null;\n            // Whether the response callback has been called.\n            let finished = false;\n            // Set the response callback in this.callbackMap (which will be the window\n            // object in the browser. The script being loaded via the <script> tag will\n            // eventually call this callback.\n            this.callbackMap[callback] = (data) => {\n                // Data has been received from the JSONP script. Firstly, delete this callback.\n                delete this.callbackMap[callback];\n                // Set state to indicate data was received.\n                body = data;\n                finished = true;\n            };\n            // cleanup() is a utility closure that removes the <script> from the page and\n            // the response callback from the window. This logic is used in both the\n            // success, error, and cancellation paths, so it's extracted out for convenience.\n            const cleanup = () => {\n                node.removeEventListener('load', onLoad);\n                node.removeEventListener('error', onError);\n                // Remove the <script> tag if it's still on the page.\n                node.remove();\n                // Remove the response callback from the callbackMap (window object in the\n                // browser).\n                delete this.callbackMap[callback];\n            };\n            // onLoad() is the success callback which runs after the response callback\n            // if the JSONP script loads successfully. The event itself is unimportant.\n            // If something went wrong, onLoad() may run without the response callback\n            // having been invoked.\n            const onLoad = () => {\n                // We wrap it in an extra Promise, to ensure the microtask\n                // is scheduled after the loaded endpoint has executed any potential microtask itself,\n                // which is not guaranteed in Internet Explorer and EdgeHTML. See issue #39496\n                this.resolvedPromise.then(() => {\n                    // Cleanup the page.\n                    cleanup();\n                    // Check whether the response callback has run.\n                    if (!finished) {\n                        // It hasn't, something went wrong with the request. Return an error via\n                        // the Observable error path. All JSONP errors have status 0.\n                        observer.error(new HttpErrorResponse({\n                            url,\n                            status: 0,\n                            statusText: 'JSONP Error',\n                            error: new Error(JSONP_ERR_NO_CALLBACK),\n                        }));\n                        return;\n                    }\n                    // Success. body either contains the response body or null if none was\n                    // returned.\n                    observer.next(new HttpResponse({\n                        body,\n                        status: HTTP_STATUS_CODE_OK,\n                        statusText: 'OK',\n                        url,\n                    }));\n                    // Complete the stream, the response is over.\n                    observer.complete();\n                });\n            };\n            // onError() is the error callback, which runs if the script returned generates\n            // a Javascript error. It emits the error via the Observable error channel as\n            // a HttpErrorResponse.\n            const onError = (error) => {\n                cleanup();\n                // Wrap the error in a HttpErrorResponse.\n                observer.error(new HttpErrorResponse({\n                    error,\n                    status: 0,\n                    statusText: 'JSONP Error',\n                    url,\n                }));\n            };\n            // Subscribe to both the success (load) and error events on the <script> tag,\n            // and add it to the page.\n            node.addEventListener('load', onLoad);\n            node.addEventListener('error', onError);\n            this.document.body.appendChild(node);\n            // The request has now been successfully sent.\n            observer.next({ type: HttpEventType.Sent });\n            // Cancellation handler.\n            return () => {\n                if (!finished) {\n                    this.removeListeners(node);\n                }\n                // And finally, clean up the page.\n                cleanup();\n            };\n        });\n    }\n    removeListeners(script) {\n        // Issue #34818\n        // Changing <script>'s ownerDocument will prevent it from execution.\n        // https://html.spec.whatwg.org/multipage/scripting.html#execute-the-script-block\n        foreignDocument ??= this.document.implementation.createHTMLDocument();\n        foreignDocument.adoptNode(script);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: JsonpClientBackend, deps: [{ token: JsonpCallbackContext }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: JsonpClientBackend });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: JsonpClientBackend, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: JsonpCallbackContext }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n/**\n * Identifies requests with the method JSONP and shifts them to the `JsonpClientBackend`.\n */\nfunction jsonpInterceptorFn(req, next) {\n    if (req.method === 'JSONP') {\n        return inject(JsonpClientBackend).handle(req);\n    }\n    // Fall through for normal HTTP requests.\n    return next(req);\n}\n/**\n * Identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n *\n * @see {@link HttpInterceptor}\n *\n * @publicApi\n */\nclass JsonpInterceptor {\n    injector;\n    constructor(injector) {\n        this.injector = injector;\n    }\n    /**\n     * Identifies and handles a given JSONP request.\n     * @param initialRequest The outgoing request object to handle.\n     * @param next The next interceptor in the chain, or the backend\n     * if no interceptors remain in the chain.\n     * @returns An observable of the event stream.\n     */\n    intercept(initialRequest, next) {\n        return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: JsonpInterceptor, deps: [{ token: i0.EnvironmentInjector }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: JsonpInterceptor });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: JsonpInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: i0.EnvironmentInjector }] });\n\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\nconst X_REQUEST_URL_REGEXP = RegExp(`^${X_REQUEST_URL_HEADER}:`, 'm');\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n */\nfunction getResponseUrl(xhr) {\n    if ('responseURL' in xhr && xhr.responseURL) {\n        return xhr.responseURL;\n    }\n    if (X_REQUEST_URL_REGEXP.test(xhr.getAllResponseHeaders())) {\n        return xhr.getResponseHeader(X_REQUEST_URL_HEADER);\n    }\n    return null;\n}\n/**\n * Validates whether the request is compatible with the XHR backend.\n * Show a warning if the request contains options that are not supported by XHR.\n */\nfunction validateXhrCompatibility(req) {\n    const unsupportedOptions = [\n        {\n            property: 'keepalive',\n            errorCode: 2813 /* RuntimeErrorCode.KEEPALIVE_NOT_SUPPORTED_WITH_XHR */,\n        },\n        {\n            property: 'cache',\n            errorCode: 2814 /* RuntimeErrorCode.CACHE_NOT_SUPPORTED_WITH_XHR */,\n        },\n        {\n            property: 'priority',\n            errorCode: 2815 /* RuntimeErrorCode.PRIORITY_NOT_SUPPORTED_WITH_XHR */,\n        },\n        {\n            property: 'mode',\n            errorCode: 2816 /* RuntimeErrorCode.MODE_NOT_SUPPORTED_WITH_XHR */,\n        },\n        {\n            property: 'redirect',\n            errorCode: 2817 /* RuntimeErrorCode.REDIRECT_NOT_SUPPORTED_WITH_XHR */,\n        },\n        {\n            property: 'credentials',\n            errorCode: 2818 /* RuntimeErrorCode.CREDENTIALS_NOT_SUPPORTED_WITH_XHR */,\n        },\n    ];\n    // Check each unsupported option and warn if present\n    for (const { property, errorCode } of unsupportedOptions) {\n        if (req[property]) {\n            console.warn(_formatRuntimeError(errorCode, `Angular detected that a \\`HttpClient\\` request with the \\`${property}\\` option was sent using XHR, which does not support it. To use the \\`${property}\\` option, enable Fetch API support by passing \\`withFetch()\\` as an argument to \\`provideHttpClient()\\`.`));\n        }\n    }\n}\n/**\n * Uses `XMLHttpRequest` to send requests to a backend server.\n * @see {@link HttpHandler}\n * @see {@link JsonpClientBackend}\n *\n * @publicApi\n */\nclass HttpXhrBackend {\n    xhrFactory;\n    constructor(xhrFactory) {\n        this.xhrFactory = xhrFactory;\n    }\n    /**\n     * Processes a request and returns a stream of response events.\n     * @param req The request object.\n     * @returns An observable of the response events.\n     */\n    handle(req) {\n        // Quick check to give a better error message when a user attempts to use\n        // HttpClient.jsonp() without installing the HttpClientJsonpModule\n        if (req.method === 'JSONP') {\n            throw new _RuntimeError(-2800 /* RuntimeErrorCode.MISSING_JSONP_MODULE */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \\`withJsonpSupport()\\` call (if \\`provideHttpClient()\\` is used) or import the \\`HttpClientJsonpModule\\` in the root NgModule.`);\n        }\n        // Validate that the request is compatible with the XHR backend.\n        ngDevMode && validateXhrCompatibility(req);\n        // Check whether this factory has a special function to load an XHR implementation\n        // for various non-browser environments. We currently limit it to only `ServerXhr`\n        // class, which needs to load an XHR implementation.\n        const xhrFactory = this.xhrFactory;\n        const source = \n        // Note that `ɵloadImpl` is never defined in client bundles and can be\n        // safely dropped whenever we're running in the browser.\n        // This branching is redundant.\n        // The `ngServerMode` guard also enables tree-shaking of the `from()`\n        // function from the common bundle, as it's only used in server code.\n        typeof ngServerMode !== 'undefined' && ngServerMode && xhrFactory.ɵloadImpl\n            ? from(xhrFactory.ɵloadImpl())\n            : of(null);\n        return source.pipe(switchMap(() => {\n            // Everything happens on Observable subscription.\n            return new Observable((observer) => {\n                // Start by setting up the XHR object with request method, URL, and withCredentials\n                // flag.\n                const xhr = xhrFactory.build();\n                xhr.open(req.method, req.urlWithParams);\n                if (req.withCredentials) {\n                    xhr.withCredentials = true;\n                }\n                // Add all the requested headers.\n                req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n                // Add an Accept header if one isn't present already.\n                if (!req.headers.has(ACCEPT_HEADER)) {\n                    xhr.setRequestHeader(ACCEPT_HEADER, ACCEPT_HEADER_VALUE);\n                }\n                // Auto-detect the Content-Type header if one isn't present already.\n                if (!req.headers.has(CONTENT_TYPE_HEADER)) {\n                    const detectedType = req.detectContentTypeHeader();\n                    // Sometimes Content-Type detection fails.\n                    if (detectedType !== null) {\n                        xhr.setRequestHeader(CONTENT_TYPE_HEADER, detectedType);\n                    }\n                }\n                if (req.timeout) {\n                    xhr.timeout = req.timeout;\n                }\n                // Set the responseType if one was requested.\n                if (req.responseType) {\n                    const responseType = req.responseType.toLowerCase();\n                    // JSON responses need to be processed as text. This is because if the server\n                    // returns an XSSI-prefixed JSON response, the browser will fail to parse it,\n                    // xhr.response will be null, and xhr.responseText cannot be accessed to\n                    // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON\n                    // is parsed by first requesting text and then applying JSON.parse.\n                    xhr.responseType = (responseType !== 'json' ? responseType : 'text');\n                }\n                // Serialize the request body if one is present. If not, this will be set to null.\n                const reqBody = req.serializeBody();\n                // If progress events are enabled, response headers will be delivered\n                // in two events - the HttpHeaderResponse event and the full HttpResponse\n                // event. However, since response headers don't change in between these\n                // two events, it doesn't make sense to parse them twice. So headerResponse\n                // caches the data extracted from the response whenever it's first parsed,\n                // to ensure parsing isn't duplicated.\n                let headerResponse = null;\n                // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n                // state, and memoizes it into headerResponse.\n                const partialFromXhr = () => {\n                    if (headerResponse !== null) {\n                        return headerResponse;\n                    }\n                    const statusText = xhr.statusText || 'OK';\n                    // Parse headers from XMLHttpRequest - this step is lazy.\n                    const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n                    // Read the response URL from the XMLHttpResponse instance and fall back on the\n                    // request URL.\n                    const url = getResponseUrl(xhr) || req.url;\n                    // Construct the HttpHeaderResponse and memoize it.\n                    headerResponse = new HttpHeaderResponse({ headers, status: xhr.status, statusText, url });\n                    return headerResponse;\n                };\n                // Next, a few closures are defined for the various events which XMLHttpRequest can\n                // emit. This allows them to be unregistered as event listeners later.\n                // First up is the load event, which represents a response being fully available.\n                const onLoad = () => {\n                    // Read response state from the memoized partial data.\n                    let { headers, status, statusText, url } = partialFromXhr();\n                    // The body will be read out if present.\n                    let body = null;\n                    if (status !== HTTP_STATUS_CODE_NO_CONTENT) {\n                        // Use XMLHttpRequest.response if set, responseText otherwise.\n                        body = typeof xhr.response === 'undefined' ? xhr.responseText : xhr.response;\n                    }\n                    // Normalize another potential bug (this one comes from CORS).\n                    if (status === 0) {\n                        status = !!body ? HTTP_STATUS_CODE_OK : 0;\n                    }\n                    // ok determines whether the response will be transmitted on the event or\n                    // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n                    // but a successful status code can still result in an error if the user\n                    // asked for JSON data and the body cannot be parsed as such.\n                    let ok = status >= 200 && status < 300;\n                    // Check whether the body needs to be parsed as JSON (in many cases the browser\n                    // will have done that already).\n                    if (req.responseType === 'json' && typeof body === 'string') {\n                        // Save the original body, before attempting XSSI prefix stripping.\n                        const originalBody = body;\n                        body = body.replace(XSSI_PREFIX, '');\n                        try {\n                            // Attempt the parse. If it fails, a parse error should be delivered to the\n                            // user.\n                            body = body !== '' ? JSON.parse(body) : null;\n                        }\n                        catch (error) {\n                            // Since the JSON.parse failed, it's reasonable to assume this might not have\n                            // been a JSON response. Restore the original body (including any XSSI prefix)\n                            // to deliver a better error response.\n                            body = originalBody;\n                            // If this was an error request to begin with, leave it as a string, it\n                            // probably just isn't JSON. Otherwise, deliver the parsing error to the user.\n                            if (ok) {\n                                // Even though the response status was 2xx, this is still an error.\n                                ok = false;\n                                // The parse error contains the text of the body that failed to parse.\n                                body = { error, text: body };\n                            }\n                        }\n                    }\n                    if (ok) {\n                        // A successful response is delivered on the event stream.\n                        observer.next(new HttpResponse({\n                            body,\n                            headers,\n                            status,\n                            statusText,\n                            url: url || undefined,\n                        }));\n                        // The full body has been received and delivered, no further events\n                        // are possible. This request is complete.\n                        observer.complete();\n                    }\n                    else {\n                        // An unsuccessful request is delivered on the error channel.\n                        observer.error(new HttpErrorResponse({\n                            // The error in this case is the response body (error from the server).\n                            error: body,\n                            headers,\n                            status,\n                            statusText,\n                            url: url || undefined,\n                        }));\n                    }\n                };\n                // The onError callback is called when something goes wrong at the network level.\n                // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n                // transmitted on the error channel.\n                const onError = (error) => {\n                    const { url } = partialFromXhr();\n                    const res = new HttpErrorResponse({\n                        error,\n                        status: xhr.status || 0,\n                        statusText: xhr.statusText || 'Unknown Error',\n                        url: url || undefined,\n                    });\n                    observer.error(res);\n                };\n                let onTimeout = onError;\n                if (req.timeout) {\n                    onTimeout = (_) => {\n                        const { url } = partialFromXhr();\n                        const res = new HttpErrorResponse({\n                            error: new DOMException('Request timed out', 'TimeoutError'),\n                            status: xhr.status || 0,\n                            statusText: xhr.statusText || 'Request timeout',\n                            url: url || undefined,\n                        });\n                        observer.error(res);\n                    };\n                }\n                // The sentHeaders flag tracks whether the HttpResponseHeaders event\n                // has been sent on the stream. This is necessary to track if progress\n                // is enabled since the event will be sent on only the first download\n                // progress event.\n                let sentHeaders = false;\n                // The download progress event handler, which is only registered if\n                // progress events are enabled.\n                const onDownProgress = (event) => {\n                    // Send the HttpResponseHeaders event if it hasn't been sent already.\n                    if (!sentHeaders) {\n                        observer.next(partialFromXhr());\n                        sentHeaders = true;\n                    }\n                    // Start building the download progress event to deliver on the response\n                    // event stream.\n                    let progressEvent = {\n                        type: HttpEventType.DownloadProgress,\n                        loaded: event.loaded,\n                    };\n                    // Set the total number of bytes in the event if it's available.\n                    if (event.lengthComputable) {\n                        progressEvent.total = event.total;\n                    }\n                    // If the request was for text content and a partial response is\n                    // available on XMLHttpRequest, include it in the progress event\n                    // to allow for streaming reads.\n                    if (req.responseType === 'text' && !!xhr.responseText) {\n                        progressEvent.partialText = xhr.responseText;\n                    }\n                    // Finally, fire the event.\n                    observer.next(progressEvent);\n                };\n                // The upload progress event handler, which is only registered if\n                // progress events are enabled.\n                const onUpProgress = (event) => {\n                    // Upload progress events are simpler. Begin building the progress\n                    // event.\n                    let progress = {\n                        type: HttpEventType.UploadProgress,\n                        loaded: event.loaded,\n                    };\n                    // If the total number of bytes being uploaded is available, include\n                    // it.\n                    if (event.lengthComputable) {\n                        progress.total = event.total;\n                    }\n                    // Send the event.\n                    observer.next(progress);\n                };\n                // By default, register for load and error events.\n                xhr.addEventListener('load', onLoad);\n                xhr.addEventListener('error', onError);\n                xhr.addEventListener('timeout', onTimeout);\n                xhr.addEventListener('abort', onError);\n                // Progress events are only enabled if requested.\n                if (req.reportProgress) {\n                    // Download progress is always enabled if requested.\n                    xhr.addEventListener('progress', onDownProgress);\n                    // Upload progress depends on whether there is a body to upload.\n                    if (reqBody !== null && xhr.upload) {\n                        xhr.upload.addEventListener('progress', onUpProgress);\n                    }\n                }\n                // Fire the request, and notify the event stream that it was fired.\n                xhr.send(reqBody);\n                observer.next({ type: HttpEventType.Sent });\n                // This is the return from the Observable function, which is the\n                // request cancellation handler.\n                return () => {\n                    // On a cancellation, remove all registered event listeners.\n                    xhr.removeEventListener('error', onError);\n                    xhr.removeEventListener('abort', onError);\n                    xhr.removeEventListener('load', onLoad);\n                    xhr.removeEventListener('timeout', onTimeout);\n                    if (req.reportProgress) {\n                        xhr.removeEventListener('progress', onDownProgress);\n                        if (reqBody !== null && xhr.upload) {\n                            xhr.upload.removeEventListener('progress', onUpProgress);\n                        }\n                    }\n                    // Finally, abort the in-flight request.\n                    if (xhr.readyState !== xhr.DONE) {\n                        xhr.abort();\n                    }\n                };\n            });\n        }));\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpXhrBackend, deps: [{ token: XhrFactory }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpXhrBackend });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpXhrBackend, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: XhrFactory }] });\n\nconst XSRF_ENABLED = new InjectionToken(ngDevMode ? 'XSRF_ENABLED' : '');\nconst XSRF_DEFAULT_COOKIE_NAME = 'XSRF-TOKEN';\nconst XSRF_COOKIE_NAME = new InjectionToken(ngDevMode ? 'XSRF_COOKIE_NAME' : '', {\n    providedIn: 'root',\n    factory: () => XSRF_DEFAULT_COOKIE_NAME,\n});\nconst XSRF_DEFAULT_HEADER_NAME = 'X-XSRF-TOKEN';\nconst XSRF_HEADER_NAME = new InjectionToken(ngDevMode ? 'XSRF_HEADER_NAME' : '', {\n    providedIn: 'root',\n    factory: () => XSRF_DEFAULT_HEADER_NAME,\n});\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n *\n * @publicApi\n */\nclass HttpXsrfTokenExtractor {\n}\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\nclass HttpXsrfCookieExtractor {\n    doc;\n    cookieName;\n    lastCookieString = '';\n    lastToken = null;\n    /**\n     * @internal for testing\n     */\n    parseCount = 0;\n    constructor(doc, cookieName) {\n        this.doc = doc;\n        this.cookieName = cookieName;\n    }\n    getToken() {\n        if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n            return null;\n        }\n        const cookieString = this.doc.cookie || '';\n        if (cookieString !== this.lastCookieString) {\n            this.parseCount++;\n            this.lastToken = parseCookieValue(cookieString, this.cookieName);\n            this.lastCookieString = cookieString;\n        }\n        return this.lastToken;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpXsrfCookieExtractor, deps: [{ token: DOCUMENT }, { token: XSRF_COOKIE_NAME }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpXsrfCookieExtractor });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpXsrfCookieExtractor, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [XSRF_COOKIE_NAME]\n                }] }] });\nfunction xsrfInterceptorFn(req, next) {\n    const lcUrl = req.url.toLowerCase();\n    // Skip both non-mutating requests and absolute URLs.\n    // Non-mutating requests don't require a token, and absolute URLs require special handling\n    // anyway as the cookie set\n    // on our origin is not the same as the token expected by another origin.\n    if (!inject(XSRF_ENABLED) ||\n        req.method === 'GET' ||\n        req.method === 'HEAD' ||\n        lcUrl.startsWith('http://') ||\n        lcUrl.startsWith('https://')) {\n        return next(req);\n    }\n    const token = inject(HttpXsrfTokenExtractor).getToken();\n    const headerName = inject(XSRF_HEADER_NAME);\n    // Be careful not to overwrite an existing header of the same name.\n    if (token != null && !req.headers.has(headerName)) {\n        req = req.clone({ headers: req.headers.set(headerName, token) });\n    }\n    return next(req);\n}\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\nclass HttpXsrfInterceptor {\n    injector;\n    constructor(injector) {\n        this.injector = injector;\n    }\n    intercept(initialRequest, next) {\n        return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpXsrfInterceptor, deps: [{ token: i0.EnvironmentInjector }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpXsrfInterceptor });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpXsrfInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: i0.EnvironmentInjector }] });\n\n/**\n * Identifies a particular kind of `HttpFeature`.\n *\n * @publicApi\n */\nvar HttpFeatureKind;\n(function (HttpFeatureKind) {\n    HttpFeatureKind[HttpFeatureKind[\"Interceptors\"] = 0] = \"Interceptors\";\n    HttpFeatureKind[HttpFeatureKind[\"LegacyInterceptors\"] = 1] = \"LegacyInterceptors\";\n    HttpFeatureKind[HttpFeatureKind[\"CustomXsrfConfiguration\"] = 2] = \"CustomXsrfConfiguration\";\n    HttpFeatureKind[HttpFeatureKind[\"NoXsrfProtection\"] = 3] = \"NoXsrfProtection\";\n    HttpFeatureKind[HttpFeatureKind[\"JsonpSupport\"] = 4] = \"JsonpSupport\";\n    HttpFeatureKind[HttpFeatureKind[\"RequestsMadeViaParent\"] = 5] = \"RequestsMadeViaParent\";\n    HttpFeatureKind[HttpFeatureKind[\"Fetch\"] = 6] = \"Fetch\";\n})(HttpFeatureKind || (HttpFeatureKind = {}));\nfunction makeHttpFeature(kind, providers) {\n    return {\n        ɵkind: kind,\n        ɵproviders: providers,\n    };\n}\n/**\n * Configures Angular's `HttpClient` service to be available for injection.\n *\n * By default, `HttpClient` will be configured for injection with its default options for XSRF\n * protection of outgoing requests. Additional configuration options can be provided by passing\n * feature functions to `provideHttpClient`. For example, HTTP interceptors can be added using the\n * `withInterceptors(...)` feature.\n *\n * <div class=\"docs-alert docs-alert-helpful\">\n *\n * It's strongly recommended to enable\n * [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) for applications that use\n * Server-Side Rendering for better performance and compatibility. To enable `fetch`, add\n * `withFetch()` feature to the `provideHttpClient()` call at the root of the application:\n *\n * ```ts\n * provideHttpClient(withFetch());\n * ```\n *\n * </div>\n *\n * @see {@link withInterceptors}\n * @see {@link withInterceptorsFromDi}\n * @see {@link withXsrfConfiguration}\n * @see {@link withNoXsrfProtection}\n * @see {@link withJsonpSupport}\n * @see {@link withRequestsMadeViaParent}\n * @see {@link withFetch}\n */\nfunction provideHttpClient(...features) {\n    if (ngDevMode) {\n        const featureKinds = new Set(features.map((f) => f.ɵkind));\n        if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) &&\n            featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {\n            throw new Error(ngDevMode\n                ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.`\n                : '');\n        }\n    }\n    const providers = [\n        HttpClient,\n        HttpXhrBackend,\n        HttpInterceptorHandler,\n        { provide: HttpHandler, useExisting: HttpInterceptorHandler },\n        {\n            provide: HttpBackend,\n            useFactory: () => {\n                return inject(FETCH_BACKEND, { optional: true }) ?? inject(HttpXhrBackend);\n            },\n        },\n        {\n            provide: HTTP_INTERCEPTOR_FNS,\n            useValue: xsrfInterceptorFn,\n            multi: true,\n        },\n        { provide: XSRF_ENABLED, useValue: true },\n        { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },\n    ];\n    for (const feature of features) {\n        providers.push(...feature.ɵproviders);\n    }\n    return makeEnvironmentProviders(providers);\n}\n/**\n * Adds one or more functional-style HTTP interceptors to the configuration of the `HttpClient`\n * instance.\n *\n * @see {@link HttpInterceptorFn}\n * @see {@link provideHttpClient}\n * @publicApi\n */\nfunction withInterceptors(interceptorFns) {\n    return makeHttpFeature(HttpFeatureKind.Interceptors, interceptorFns.map((interceptorFn) => {\n        return {\n            provide: HTTP_INTERCEPTOR_FNS,\n            useValue: interceptorFn,\n            multi: true,\n        };\n    }));\n}\nconst LEGACY_INTERCEPTOR_FN = new InjectionToken(ngDevMode ? 'LEGACY_INTERCEPTOR_FN' : '');\n/**\n * Includes class-based interceptors configured using a multi-provider in the current injector into\n * the configured `HttpClient` instance.\n *\n * Prefer `withInterceptors` and functional interceptors instead, as support for DI-provided\n * interceptors may be phased out in a later release.\n *\n * @see {@link HttpInterceptor}\n * @see {@link HTTP_INTERCEPTORS}\n * @see {@link provideHttpClient}\n */\nfunction withInterceptorsFromDi() {\n    // Note: the legacy interceptor function is provided here via an intermediate token\n    // (`LEGACY_INTERCEPTOR_FN`), using a pattern which guarantees that if these providers are\n    // included multiple times, all of the multi-provider entries will have the same instance of the\n    // interceptor function. That way, the `HttpINterceptorHandler` will dedup them and legacy\n    // interceptors will not run multiple times.\n    return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [\n        {\n            provide: LEGACY_INTERCEPTOR_FN,\n            useFactory: legacyInterceptorFnFactory,\n        },\n        {\n            provide: HTTP_INTERCEPTOR_FNS,\n            useExisting: LEGACY_INTERCEPTOR_FN,\n            multi: true,\n        },\n    ]);\n}\n/**\n * Customizes the XSRF protection for the configuration of the current `HttpClient` instance.\n *\n * This feature is incompatible with the `withNoXsrfProtection` feature.\n *\n * @see {@link provideHttpClient}\n */\nfunction withXsrfConfiguration({ cookieName, headerName, }) {\n    const providers = [];\n    if (cookieName !== undefined) {\n        providers.push({ provide: XSRF_COOKIE_NAME, useValue: cookieName });\n    }\n    if (headerName !== undefined) {\n        providers.push({ provide: XSRF_HEADER_NAME, useValue: headerName });\n    }\n    return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);\n}\n/**\n * Disables XSRF protection in the configuration of the current `HttpClient` instance.\n *\n * This feature is incompatible with the `withXsrfConfiguration` feature.\n *\n * @see {@link provideHttpClient}\n */\nfunction withNoXsrfProtection() {\n    return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [\n        {\n            provide: XSRF_ENABLED,\n            useValue: false,\n        },\n    ]);\n}\n/**\n * Add JSONP support to the configuration of the current `HttpClient` instance.\n *\n * @see {@link provideHttpClient}\n */\nfunction withJsonpSupport() {\n    return makeHttpFeature(HttpFeatureKind.JsonpSupport, [\n        JsonpClientBackend,\n        { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },\n        { provide: HTTP_INTERCEPTOR_FNS, useValue: jsonpInterceptorFn, multi: true },\n    ]);\n}\n/**\n * Configures the current `HttpClient` instance to make requests via the parent injector's\n * `HttpClient` instead of directly.\n *\n * By default, `provideHttpClient` configures `HttpClient` in its injector to be an independent\n * instance. For example, even if `HttpClient` is configured in the parent injector with\n * one or more interceptors, they will not intercept requests made via this instance.\n *\n * With this option enabled, once the request has passed through the current injector's\n * interceptors, it will be delegated to the parent injector's `HttpClient` chain instead of\n * dispatched directly, and interceptors in the parent configuration will be applied to the request.\n *\n * If there are several `HttpClient` instances in the injector hierarchy, it's possible for\n * `withRequestsMadeViaParent` to be used at multiple levels, which will cause the request to\n * \"bubble up\" until either reaching the root level or an `HttpClient` which was not configured with\n * this option.\n *\n * @see {@link provideHttpClient}\n * @publicApi 19.0\n */\nfunction withRequestsMadeViaParent() {\n    return makeHttpFeature(HttpFeatureKind.RequestsMadeViaParent, [\n        {\n            provide: HttpBackend,\n            useFactory: () => {\n                const handlerFromParent = inject(HttpHandler, { skipSelf: true, optional: true });\n                if (ngDevMode && handlerFromParent === null) {\n                    throw new Error('withRequestsMadeViaParent() can only be used when the parent injector also configures HttpClient');\n                }\n                return handlerFromParent;\n            },\n        },\n    ]);\n}\n/**\n * Configures the current `HttpClient` instance to make requests using the fetch API.\n *\n * Note: The Fetch API doesn't support progress report on uploads.\n *\n * @publicApi\n */\nfunction withFetch() {\n    return makeHttpFeature(HttpFeatureKind.Fetch, [\n        FetchBackend,\n        { provide: FETCH_BACKEND, useExisting: FetchBackend },\n        { provide: HttpBackend, useExisting: FetchBackend },\n    ]);\n}\n\n/**\n * Configures XSRF protection support for outgoing requests.\n *\n * For a server that supports a cookie-based XSRF protection system,\n * use directly to configure XSRF protection with the correct\n * cookie and header names.\n *\n * If no names are supplied, the default cookie name is `XSRF-TOKEN`\n * and the default header name is `X-XSRF-TOKEN`.\n *\n * @publicApi\n * @deprecated Use withXsrfConfiguration({cookieName: 'XSRF-TOKEN', headerName: 'X-XSRF-TOKEN'}) as\n *     providers instead or `withNoXsrfProtection` if you want to disabled XSRF protection.\n */\nclass HttpClientXsrfModule {\n    /**\n     * Disable the default XSRF protection.\n     */\n    static disable() {\n        return {\n            ngModule: HttpClientXsrfModule,\n            providers: [withNoXsrfProtection().ɵproviders],\n        };\n    }\n    /**\n     * Configure XSRF protection.\n     * @param options An object that can specify either or both\n     * cookie name or header name.\n     * - Cookie name default is `XSRF-TOKEN`.\n     * - Header name default is `X-XSRF-TOKEN`.\n     *\n     */\n    static withOptions(options = {}) {\n        return {\n            ngModule: HttpClientXsrfModule,\n            providers: withXsrfConfiguration(options).ɵproviders,\n        };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientXsrfModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientXsrfModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientXsrfModule, providers: [\n            HttpXsrfInterceptor,\n            { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },\n            { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },\n            withXsrfConfiguration({\n                cookieName: XSRF_DEFAULT_COOKIE_NAME,\n                headerName: XSRF_DEFAULT_HEADER_NAME,\n            }).ɵproviders,\n            { provide: XSRF_ENABLED, useValue: true },\n        ] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientXsrfModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [\n                        HttpXsrfInterceptor,\n                        { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },\n                        { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },\n                        withXsrfConfiguration({\n                            cookieName: XSRF_DEFAULT_COOKIE_NAME,\n                            headerName: XSRF_DEFAULT_HEADER_NAME,\n                        }).ɵproviders,\n                        { provide: XSRF_ENABLED, useValue: true },\n                    ],\n                }]\n        }] });\n/**\n * Configures the dependency injector for `HttpClient`\n * with supporting services for XSRF. Automatically imported by `HttpClientModule`.\n *\n * You can add interceptors to the chain behind `HttpClient` by binding them to the\n * multiprovider for built-in DI token `HTTP_INTERCEPTORS`.\n *\n * @publicApi\n * @deprecated use `provideHttpClient(withInterceptorsFromDi())` as providers instead\n */\nclass HttpClientModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientModule, providers: [provideHttpClient(withInterceptorsFromDi())] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    /**\n                     * Configures the dependency injector where it is imported\n                     * with supporting services for HTTP communications.\n                     */\n                    providers: [provideHttpClient(withInterceptorsFromDi())],\n                }]\n        }] });\n/**\n * Configures the dependency injector for `HttpClient`\n * with supporting services for JSONP.\n * Without this module, Jsonp requests reach the backend\n * with method JSONP, where they are rejected.\n *\n * @publicApi\n * @deprecated `withJsonpSupport()` as providers instead\n */\nclass HttpClientJsonpModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientJsonpModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientJsonpModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientJsonpModule, providers: [withJsonpSupport().ɵproviders] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HttpClientJsonpModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [withJsonpSupport().ɵproviders],\n                }]\n        }] });\n\nexport { FetchBackend, HTTP_INTERCEPTORS, HTTP_ROOT_INTERCEPTOR_FNS, HttpBackend, HttpClient, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpContext, HttpContextToken, HttpErrorResponse, HttpEventType, HttpFeatureKind, HttpHandler, HttpHeaderResponse, HttpHeaders, HttpInterceptorHandler, HttpParams, HttpRequest, HttpResponse, HttpResponseBase, HttpStatusCode, HttpUrlEncodingCodec, HttpXhrBackend, HttpXsrfTokenExtractor, JsonpClientBackend, JsonpInterceptor, REQUESTS_CONTRIBUTE_TO_STABILITY, provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, withJsonpSupport, withNoXsrfProtection, withRequestsMadeViaParent, withXsrfConfiguration };\n\n","/**\n * @license Angular v20.1.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { HttpHeaders, HttpParams, HttpRequest, HttpEventType, HttpErrorResponse, HttpClient, HTTP_ROOT_INTERCEPTOR_FNS, HttpResponse } from './module.mjs';\nexport { FetchBackend, HTTP_INTERCEPTORS, HttpBackend, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpContext, HttpContextToken, HttpFeatureKind, HttpHandler, HttpHeaderResponse, HttpResponseBase, HttpStatusCode, HttpUrlEncodingCodec, HttpXhrBackend, HttpXsrfTokenExtractor, JsonpClientBackend, JsonpInterceptor, provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, withJsonpSupport, withNoXsrfProtection, withRequestsMadeViaParent, withXsrfConfiguration, HttpInterceptorHandler as ɵHttpInterceptingHandler, HttpInterceptorHandler as ɵHttpInterceptorHandler, REQUESTS_CONTRIBUTE_TO_STABILITY as ɵREQUESTS_CONTRIBUTE_TO_STABILITY } from './module.mjs';\nimport { assertInInjectionContext, inject, Injector, ɵResourceImpl as _ResourceImpl, linkedSignal, computed, signal, ɵencapsulateResourceError as _encapsulateResourceError, ɵRuntimeError as _RuntimeError, InjectionToken, ɵperformanceMarkFeature as _performanceMarkFeature, APP_BOOTSTRAP_LISTENER, ApplicationRef, TransferState, makeStateKey, ɵtruncateMiddle as _truncateMiddle, ɵformatRuntimeError as _formatRuntimeError } from '@angular/core';\nimport { of } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport './xhr.mjs';\n\n/**\n * `httpResource` makes a reactive HTTP request and exposes the request status and response value as\n * a `WritableResource`. By default, it assumes that the backend will return JSON data. To make a\n * request that expects a different kind of data, you can use a sub-constructor of `httpResource`,\n * such as `httpResource.text`.\n *\n * @experimental 19.2\n * @initializerApiFunction\n */\nconst httpResource = (() => {\n    const jsonFn = makeHttpResourceFn('json');\n    jsonFn.arrayBuffer = makeHttpResourceFn('arraybuffer');\n    jsonFn.blob = makeHttpResourceFn('blob');\n    jsonFn.text = makeHttpResourceFn('text');\n    return jsonFn;\n})();\nfunction makeHttpResourceFn(responseType) {\n    return function httpResource(request, options) {\n        if (ngDevMode && !options?.injector) {\n            assertInInjectionContext(httpResource);\n        }\n        const injector = options?.injector ?? inject(Injector);\n        return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.parse, options?.equal);\n    };\n}\nfunction normalizeRequest(request, responseType) {\n    let unwrappedRequest = typeof request === 'function' ? request() : request;\n    if (unwrappedRequest === undefined) {\n        return undefined;\n    }\n    else if (typeof unwrappedRequest === 'string') {\n        unwrappedRequest = { url: unwrappedRequest };\n    }\n    const headers = unwrappedRequest.headers instanceof HttpHeaders\n        ? unwrappedRequest.headers\n        : new HttpHeaders(unwrappedRequest.headers);\n    const params = unwrappedRequest.params instanceof HttpParams\n        ? unwrappedRequest.params\n        : new HttpParams({ fromObject: unwrappedRequest.params });\n    return new HttpRequest(unwrappedRequest.method ?? 'GET', unwrappedRequest.url, unwrappedRequest.body ?? null, {\n        headers,\n        params,\n        reportProgress: unwrappedRequest.reportProgress,\n        withCredentials: unwrappedRequest.withCredentials,\n        keepalive: unwrappedRequest.keepalive,\n        cache: unwrappedRequest.cache,\n        priority: unwrappedRequest.priority,\n        mode: unwrappedRequest.mode,\n        redirect: unwrappedRequest.redirect,\n        responseType,\n        context: unwrappedRequest.context,\n        transferCache: unwrappedRequest.transferCache,\n        credentials: unwrappedRequest.credentials,\n        timeout: unwrappedRequest.timeout,\n    });\n}\nclass HttpResourceImpl extends _ResourceImpl {\n    client;\n    _headers = linkedSignal({\n        source: this.extRequest,\n        computation: () => undefined,\n    });\n    _progress = linkedSignal({\n        source: this.extRequest,\n        computation: () => undefined,\n    });\n    _statusCode = linkedSignal({\n        source: this.extRequest,\n        computation: () => undefined,\n    });\n    headers = computed(() => this.status() === 'resolved' || this.status() === 'error' ? this._headers() : undefined, ...(ngDevMode ? [{ debugName: \"headers\" }] : []));\n    progress = this._progress.asReadonly();\n    statusCode = this._statusCode.asReadonly();\n    constructor(injector, request, defaultValue, parse, equal) {\n        super(request, ({ params: request, abortSignal }) => {\n            let sub;\n            // Track the abort listener so it can be removed if the Observable completes (as a memory\n            // optimization).\n            const onAbort = () => sub.unsubscribe();\n            abortSignal.addEventListener('abort', onAbort);\n            // Start off stream as undefined.\n            const stream = signal({ value: undefined }, ...(ngDevMode ? [{ debugName: \"stream\" }] : []));\n            let resolve;\n            const promise = new Promise((r) => (resolve = r));\n            const send = (value) => {\n                stream.set(value);\n                resolve?.(stream);\n                resolve = undefined;\n            };\n            sub = this.client.request(request).subscribe({\n                next: (event) => {\n                    switch (event.type) {\n                        case HttpEventType.Response:\n                            this._headers.set(event.headers);\n                            this._statusCode.set(event.status);\n                            try {\n                                send({ value: parse ? parse(event.body) : event.body });\n                            }\n                            catch (error) {\n                                send({ error: _encapsulateResourceError(error) });\n                            }\n                            break;\n                        case HttpEventType.DownloadProgress:\n                            this._progress.set(event);\n                            break;\n                    }\n                },\n                error: (error) => {\n                    if (error instanceof HttpErrorResponse) {\n                        this._headers.set(error.headers);\n                        this._statusCode.set(error.status);\n                    }\n                    send({ error });\n                    abortSignal.removeEventListener('abort', onAbort);\n                },\n                complete: () => {\n                    if (resolve) {\n                        send({\n                            error: new _RuntimeError(991 /* ɵRuntimeErrorCode.RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE */, ngDevMode && 'Resource completed before producing a value'),\n                        });\n                    }\n                    abortSignal.removeEventListener('abort', onAbort);\n                },\n            });\n            return promise;\n        }, defaultValue, equal, injector);\n        this.client = injector.get(HttpClient);\n    }\n}\n\n/**\n * If your application uses different HTTP origins to make API calls (via `HttpClient`) on the server and\n * on the client, the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token allows you to establish a mapping\n * between those origins, so that `HttpTransferCache` feature can recognize those requests as the same\n * ones and reuse the data cached on the server during hydration on the client.\n *\n * **Important note**: the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token should *only* be provided in\n * the *server* code of your application (typically in the `app.server.config.ts` script). Angular throws an\n * error if it detects that the token is defined while running on the client.\n *\n * @usageNotes\n *\n * When the same API endpoint is accessed via `http://internal-domain.com:8080` on the server and\n * via `https://external-domain.com` on the client, you can use the following configuration:\n * ```ts\n * // in app.server.config.ts\n * {\n *     provide: HTTP_TRANSFER_CACHE_ORIGIN_MAP,\n *     useValue: {\n *         'http://internal-domain.com:8080': 'https://external-domain.com'\n *     }\n * }\n * ```\n *\n * @publicApi\n */\nconst HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(ngDevMode ? 'HTTP_TRANSFER_CACHE_ORIGIN_MAP' : '');\n/**\n * Keys within cached response data structure.\n */\nconst BODY = 'b';\nconst HEADERS = 'h';\nconst STATUS = 's';\nconst STATUS_TEXT = 'st';\nconst REQ_URL = 'u';\nconst RESPONSE_TYPE = 'rt';\nconst CACHE_OPTIONS = new InjectionToken(ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');\n/**\n * A list of allowed HTTP methods to cache.\n */\nconst ALLOWED_METHODS = ['GET', 'HEAD'];\nfunction transferCacheInterceptorFn(req, next) {\n    const { isCacheActive, ...globalOptions } = inject(CACHE_OPTIONS);\n    const { transferCache: requestOptions, method: requestMethod } = req;\n    // In the following situations we do not want to cache the request\n    if (!isCacheActive ||\n        requestOptions === false ||\n        // POST requests are allowed either globally or at request level\n        (requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions) ||\n        (requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod)) ||\n        // Do not cache request that require authorization when includeRequestsWithAuthHeaders is falsey\n        (!globalOptions.includeRequestsWithAuthHeaders && hasAuthHeaders(req)) ||\n        globalOptions.filter?.(req) === false) {\n        return next(req);\n    }\n    const transferState = inject(TransferState);\n    const originMap = inject(HTTP_TRANSFER_CACHE_ORIGIN_MAP, {\n        optional: true,\n    });\n    if (typeof ngServerMode !== 'undefined' && !ngServerMode && originMap) {\n        throw new _RuntimeError(2803 /* RuntimeErrorCode.HTTP_ORIGIN_MAP_USED_IN_CLIENT */, ngDevMode &&\n            'Angular detected that the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token is configured and ' +\n                'present in the client side code. Please ensure that this token is only provided in the ' +\n                'server code of the application.');\n    }\n    const requestUrl = typeof ngServerMode !== 'undefined' && ngServerMode && originMap\n        ? mapRequestOriginUrl(req.url, originMap)\n        : req.url;\n    const storeKey = makeCacheKey(req, requestUrl);\n    const response = transferState.get(storeKey, null);\n    let headersToInclude = globalOptions.includeHeaders;\n    if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {\n        // Request-specific config takes precedence over the global config.\n        headersToInclude = requestOptions.includeHeaders;\n    }\n    if (response) {\n        const { [BODY]: undecodedBody, [RESPONSE_TYPE]: responseType, [HEADERS]: httpHeaders, [STATUS]: status, [STATUS_TEXT]: statusText, [REQ_URL]: url, } = response;\n        // Request found in cache. Respond using it.\n        let body = undecodedBody;\n        switch (responseType) {\n            case 'arraybuffer':\n                body = new TextEncoder().encode(undecodedBody).buffer;\n                break;\n            case 'blob':\n                body = new Blob([undecodedBody]);\n                break;\n        }\n        // We want to warn users accessing a header provided from the cache\n        // That HttpTransferCache alters the headers\n        // The warning will be logged a single time by HttpHeaders instance\n        let headers = new HttpHeaders(httpHeaders);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            // Append extra logic in dev mode to produce a warning when a header\n            // that was not transferred to the client is accessed in the code via `get`\n            // and `has` calls.\n            headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);\n        }\n        return of(new HttpResponse({\n            body,\n            headers,\n            status,\n            statusText,\n            url,\n        }));\n    }\n    const event$ = next(req);\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n        // Request not found in cache. Make the request and cache it if on the server.\n        return event$.pipe(tap((event) => {\n            // Only cache successful HTTP responses.\n            if (event instanceof HttpResponse) {\n                transferState.set(storeKey, {\n                    [BODY]: event.body,\n                    [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),\n                    [STATUS]: event.status,\n                    [STATUS_TEXT]: event.statusText,\n                    [REQ_URL]: requestUrl,\n                    [RESPONSE_TYPE]: req.responseType,\n                });\n            }\n        }));\n    }\n    return event$;\n}\n/** @returns true when the requests contains autorization related headers. */\nfunction hasAuthHeaders(req) {\n    return req.headers.has('authorization') || req.headers.has('proxy-authorization');\n}\nfunction getFilteredHeaders(headers, includeHeaders) {\n    if (!includeHeaders) {\n        return {};\n    }\n    const headersMap = {};\n    for (const key of includeHeaders) {\n        const values = headers.getAll(key);\n        if (values !== null) {\n            headersMap[key] = values;\n        }\n    }\n    return headersMap;\n}\nfunction sortAndConcatParams(params) {\n    return [...params.keys()]\n        .sort()\n        .map((k) => `${k}=${params.getAll(k)}`)\n        .join('&');\n}\nfunction makeCacheKey(request, mappedRequestUrl) {\n    // make the params encoded same as a url so it's easy to identify\n    const { params, method, responseType } = request;\n    const encodedParams = sortAndConcatParams(params);\n    let serializedBody = request.serializeBody();\n    if (serializedBody instanceof URLSearchParams) {\n        serializedBody = sortAndConcatParams(serializedBody);\n    }\n    else if (typeof serializedBody !== 'string') {\n        serializedBody = '';\n    }\n    const key = [method, responseType, mappedRequestUrl, serializedBody, encodedParams].join('|');\n    const hash = generateHash(key);\n    return makeStateKey(hash);\n}\n/**\n * A method that returns a hash representation of a string using a variant of DJB2 hash\n * algorithm.\n *\n * This is the same hashing logic that is used to generate component ids.\n */\nfunction generateHash(value) {\n    let hash = 0;\n    for (const char of value) {\n        hash = (Math.imul(31, hash) + char.charCodeAt(0)) << 0;\n    }\n    // Force positive number hash.\n    // 2147483647 = equivalent of Integer.MAX_VALUE.\n    hash += 2147483647 + 1;\n    return hash.toString();\n}\n/**\n * Returns the DI providers needed to enable HTTP transfer cache.\n *\n * By default, when using server rendering, requests are performed twice: once on the server and\n * other one on the browser.\n *\n * When these providers are added, requests performed on the server are cached and reused during the\n * bootstrapping of the application in the browser thus avoiding duplicate requests and reducing\n * load time.\n *\n */\nfunction withHttpTransferCache(cacheOptions) {\n    return [\n        {\n            provide: CACHE_OPTIONS,\n            useFactory: () => {\n                _performanceMarkFeature('NgHttpTransferCache');\n                return { isCacheActive: true, ...cacheOptions };\n            },\n        },\n        {\n            provide: HTTP_ROOT_INTERCEPTOR_FNS,\n            useValue: transferCacheInterceptorFn,\n            multi: true,\n        },\n        {\n            provide: APP_BOOTSTRAP_LISTENER,\n            multi: true,\n            useFactory: () => {\n                const appRef = inject(ApplicationRef);\n                const cacheState = inject(CACHE_OPTIONS);\n                return () => {\n                    appRef.whenStable().then(() => {\n                        cacheState.isCacheActive = false;\n                    });\n                };\n            },\n        },\n    ];\n}\n/**\n * This function will add a proxy to an HttpHeader to intercept calls to get/has\n * and log a warning if the header entry requested has been removed\n */\nfunction appendMissingHeadersDetection(url, headers, headersToInclude) {\n    const warningProduced = new Set();\n    return new Proxy(headers, {\n        get(target, prop) {\n            const value = Reflect.get(target, prop);\n            const methods = new Set(['get', 'has', 'getAll']);\n            if (typeof value !== 'function' || !methods.has(prop)) {\n                return value;\n            }\n            return (headerName) => {\n                // We log when the key has been removed and a warning hasn't been produced for the header\n                const key = (prop + ':' + headerName).toLowerCase(); // e.g. `get:cache-control`\n                if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {\n                    warningProduced.add(key);\n                    const truncatedUrl = _truncateMiddle(url);\n                    // TODO: create Error guide for this warning\n                    console.warn(_formatRuntimeError(2802 /* RuntimeErrorCode.HEADERS_ALTERED_BY_TRANSFER_CACHE */, `Angular detected that the \\`${headerName}\\` header is accessed, but the value of the header ` +\n                        `was not transferred from the server to the client by the HttpTransferCache. ` +\n                        `To include the value of the \\`${headerName}\\` header for the \\`${truncatedUrl}\\` request, ` +\n                        `use the \\`includeHeaders\\` list. The \\`includeHeaders\\` can be defined either ` +\n                        `on a request level by adding the \\`transferCache\\` parameter, or on an application ` +\n                        `level by adding the \\`httpCacheTransfer.includeHeaders\\` argument to the ` +\n                        `\\`provideClientHydration()\\` call. `));\n                }\n                // invoking the original method\n                return value.apply(target, [headerName]);\n            };\n        },\n    });\n}\nfunction mapRequestOriginUrl(url, originMap) {\n    const origin = new URL(url, 'resolve://').origin;\n    const mappedOrigin = originMap[origin];\n    if (!mappedOrigin) {\n        return url;\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        verifyMappedOrigin(mappedOrigin);\n    }\n    return url.replace(origin, mappedOrigin);\n}\nfunction verifyMappedOrigin(url) {\n    if (new URL(url, 'resolve://').pathname !== '/') {\n        throw new _RuntimeError(2804 /* RuntimeErrorCode.HTTP_ORIGIN_MAP_CONTAINS_PATH */, 'Angular detected a URL with a path segment in the value provided for the ' +\n            `\\`HTTP_TRANSFER_CACHE_ORIGIN_MAP\\` token: ${url}. The map should only contain origins ` +\n            'without any other segments.');\n    }\n}\n\nexport { HTTP_TRANSFER_CACHE_ORIGIN_MAP, HttpClient, HttpErrorResponse, HttpEventType, HttpHeaders, HttpParams, HttpRequest, HttpResponse, httpResource, HTTP_ROOT_INTERCEPTOR_FNS as ɵHTTP_ROOT_INTERCEPTOR_FNS, withHttpTransferCache as ɵwithHttpTransferCache };\n\n","/**\n * @license Angular v20.1.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nexport { BrowserModule, bootstrapApplication, createApplication, platformBrowser, provideProtractorTestingSupport, BrowserDomAdapter as ɵBrowserDomAdapter, BrowserGetTestability as ɵBrowserGetTestability, DomEventsPlugin as ɵDomEventsPlugin, KeyEventsPlugin as ɵKeyEventsPlugin } from './browser.mjs';\nimport { ɵgetDOM as _getDOM, DOCUMENT } from '@angular/common';\nexport { ɵgetDOM } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, ɵglobal as _global, ApplicationRef, InjectionToken, ɵConsole as _Console, Optional, Injector, NgModule, forwardRef, ɵRuntimeError as _RuntimeError, ɵXSS_SECURITY_URL as _XSS_SECURITY_URL, SecurityContext, ɵallowSanitizationBypassAndThrow as _allowSanitizationBypassAndThrow, ɵunwrapSafeValue as _unwrapSafeValue, ɵ_sanitizeUrl as __sanitizeUrl, ɵ_sanitizeHtml as __sanitizeHtml, ɵbypassSanitizationTrustHtml as _bypassSanitizationTrustHtml, ɵbypassSanitizationTrustStyle as _bypassSanitizationTrustStyle, ɵbypassSanitizationTrustScript as _bypassSanitizationTrustScript, ɵbypassSanitizationTrustUrl as _bypassSanitizationTrustUrl, ɵbypassSanitizationTrustResourceUrl as _bypassSanitizationTrustResourceUrl, ɵwithI18nSupport as _withI18nSupport, ɵwithEventReplay as _withEventReplay, ɵwithIncrementalHydration as _withIncrementalHydration, makeEnvironmentProviders, ɵwithDomHydration as _withDomHydration, ENVIRONMENT_INITIALIZER, inject, NgZone, ɵZONELESS_ENABLED as _ZONELESS_ENABLED, ɵformatRuntimeError as _formatRuntimeError, Version } from '@angular/core';\nimport { EventManagerPlugin, EVENT_MANAGER_PLUGINS } from './dom_renderer.mjs';\nexport { EventManager, REMOVE_STYLES_ON_COMPONENT_DESTROY, DomRendererFactory2 as ɵDomRendererFactory2, SharedStylesHost as ɵSharedStylesHost } from './dom_renderer.mjs';\nimport { ɵwithHttpTransferCache as _withHttpTransferCache } from '@angular/common/http';\n\n/**\n * A service for managing HTML `<meta>` tags.\n *\n * Properties of the `MetaDefinition` object match the attributes of the\n * HTML `<meta>` tag. These tags define document metadata that is important for\n * things like configuring a Content Security Policy, defining browser compatibility\n * and security settings, setting HTTP Headers, defining rich content for social sharing,\n * and Search Engine Optimization (SEO).\n *\n * To identify specific `<meta>` tags in a document, use an attribute selection\n * string in the format `\"tag_attribute='value string'\"`.\n * For example, an `attrSelector` value of `\"name='description'\"` matches a tag\n * whose `name` attribute has the value `\"description\"`.\n * Selectors are used with the `querySelector()` Document method,\n * in the format `meta[{attrSelector}]`.\n *\n * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)\n * @see [Document.querySelector()](https://developer.mozilla.org/docs/Web/API/Document/querySelector)\n *\n *\n * @publicApi\n */\nclass Meta {\n    _doc;\n    _dom;\n    constructor(_doc) {\n        this._doc = _doc;\n        this._dom = _getDOM();\n    }\n    /**\n     * Retrieves or creates a specific `<meta>` tag element in the current HTML document.\n     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n     * values in the provided tag definition, and verifies that all other attribute values are equal.\n     * If an existing element is found, it is returned and is not modified in any way.\n     * @param tag The definition of a `<meta>` element to match or create.\n     * @param forceCreation True to create a new element without checking whether one already exists.\n     * @returns The existing element with the same attributes and values if found,\n     * the new element if no match is found, or `null` if the tag parameter is not defined.\n     */\n    addTag(tag, forceCreation = false) {\n        if (!tag)\n            return null;\n        return this._getOrCreateElement(tag, forceCreation);\n    }\n    /**\n     * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.\n     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n     * values in the provided tag definition, and verifies that all other attribute values are equal.\n     * @param tags An array of tag definitions to match or create.\n     * @param forceCreation True to create new elements without checking whether they already exist.\n     * @returns The matching elements if found, or the new elements.\n     */\n    addTags(tags, forceCreation = false) {\n        if (!tags)\n            return [];\n        return tags.reduce((result, tag) => {\n            if (tag) {\n                result.push(this._getOrCreateElement(tag, forceCreation));\n            }\n            return result;\n        }, []);\n    }\n    /**\n     * Retrieves a `<meta>` tag element in the current HTML document.\n     * @param attrSelector The tag attribute and value to match against, in the format\n     * `\"tag_attribute='value string'\"`.\n     * @returns The matching element, if any.\n     */\n    getTag(attrSelector) {\n        if (!attrSelector)\n            return null;\n        return this._doc.querySelector(`meta[${attrSelector}]`) || null;\n    }\n    /**\n     * Retrieves a set of `<meta>` tag elements in the current HTML document.\n     * @param attrSelector The tag attribute and value to match against, in the format\n     * `\"tag_attribute='value string'\"`.\n     * @returns The matching elements, if any.\n     */\n    getTags(attrSelector) {\n        if (!attrSelector)\n            return [];\n        const list /*NodeList*/ = this._doc.querySelectorAll(`meta[${attrSelector}]`);\n        return list ? [].slice.call(list) : [];\n    }\n    /**\n     * Modifies an existing `<meta>` tag element in the current HTML document.\n     * @param tag The tag description with which to replace the existing tag content.\n     * @param selector A tag attribute and value to match against, to identify\n     * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n     * If not supplied, matches a tag with the same `name` or `property` attribute value as the\n     * replacement tag.\n     * @return The modified element.\n     */\n    updateTag(tag, selector) {\n        if (!tag)\n            return null;\n        selector = selector || this._parseSelector(tag);\n        const meta = this.getTag(selector);\n        if (meta) {\n            return this._setMetaElementAttributes(tag, meta);\n        }\n        return this._getOrCreateElement(tag, true);\n    }\n    /**\n     * Removes an existing `<meta>` tag element from the current HTML document.\n     * @param attrSelector A tag attribute and value to match against, to identify\n     * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n     */\n    removeTag(attrSelector) {\n        this.removeTagElement(this.getTag(attrSelector));\n    }\n    /**\n     * Removes an existing `<meta>` tag element from the current HTML document.\n     * @param meta The tag definition to match against to identify an existing tag.\n     */\n    removeTagElement(meta) {\n        if (meta) {\n            this._dom.remove(meta);\n        }\n    }\n    _getOrCreateElement(meta, forceCreation = false) {\n        if (!forceCreation) {\n            const selector = this._parseSelector(meta);\n            // It's allowed to have multiple elements with the same name so it's not enough to\n            // just check that element with the same name already present on the page. We also need to\n            // check if element has tag attributes\n            const elem = this.getTags(selector).filter((elem) => this._containsAttributes(meta, elem))[0];\n            if (elem !== undefined)\n                return elem;\n        }\n        const element = this._dom.createElement('meta');\n        this._setMetaElementAttributes(meta, element);\n        const head = this._doc.getElementsByTagName('head')[0];\n        head.appendChild(element);\n        return element;\n    }\n    _setMetaElementAttributes(tag, el) {\n        Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));\n        return el;\n    }\n    _parseSelector(tag) {\n        const attr = tag.name ? 'name' : 'property';\n        return `${attr}=\"${tag[attr]}\"`;\n    }\n    _containsAttributes(tag, elem) {\n        return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);\n    }\n    _getMetaKeyMap(prop) {\n        return META_KEYS_MAP[prop] || prop;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: Meta, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: Meta, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: Meta, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n/**\n * Mapping for MetaDefinition properties with their correct meta attribute names\n */\nconst META_KEYS_MAP = {\n    httpEquiv: 'http-equiv',\n};\n\n/**\n * A service that can be used to get and set the title of a current HTML document.\n *\n * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)\n * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\n * (representing the `<title>` tag). Instead, this service can be used to set and get the current\n * title value.\n *\n * @publicApi\n */\nclass Title {\n    _doc;\n    constructor(_doc) {\n        this._doc = _doc;\n    }\n    /**\n     * Get the title of the current HTML document.\n     */\n    getTitle() {\n        return this._doc.title;\n    }\n    /**\n     * Set the title of the current HTML document.\n     * @param newTitle\n     */\n    setTitle(newTitle) {\n        this._doc.title = newTitle || '';\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: Title, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: Title, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: Title, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\n/// <reference path=\"../../../goog.d.ts\" />\n/**\n * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if\n * `name` is `'probe'`.\n * @param name Name under which it will be exported. Keep in mind this will be a property of the\n * global `ng` object.\n * @param value The value to export.\n */\nfunction exportNgVar(name, value) {\n    if (typeof COMPILED === 'undefined' || !COMPILED) {\n        // Note: we can't export `ng` when using closure enhanced optimization as:\n        // - closure declares globals itself for minified names, which sometimes clobber our `ng` global\n        // - we can't declare a closure extern as the namespace `ng` is already used within Google\n        //   for typings for angularJS (via `goog.provide('ng....')`).\n        const ng = (_global['ng'] = _global['ng'] || {});\n        ng[name] = value;\n    }\n}\n\nclass ChangeDetectionPerfRecord {\n    msPerTick;\n    numTicks;\n    constructor(msPerTick, numTicks) {\n        this.msPerTick = msPerTick;\n        this.numTicks = numTicks;\n    }\n}\n/**\n * Entry point for all Angular profiling-related debug tools. This object\n * corresponds to the `ng.profiler` in the dev console.\n */\nclass AngularProfiler {\n    appRef;\n    constructor(ref) {\n        this.appRef = ref.injector.get(ApplicationRef);\n    }\n    // tslint:disable:no-console\n    /**\n     * Exercises change detection in a loop and then prints the average amount of\n     * time in milliseconds how long a single round of change detection takes for\n     * the current state of the UI. It runs a minimum of 5 rounds for a minimum\n     * of 500 milliseconds.\n     *\n     * Optionally, a user may pass a `config` parameter containing a map of\n     * options. Supported options are:\n     *\n     * `record` (boolean) - causes the profiler to record a CPU profile while\n     * it exercises the change detector. Example:\n     *\n     * ```ts\n     * ng.profiler.timeChangeDetection({record: true})\n     * ```\n     */\n    timeChangeDetection(config) {\n        const record = config && config['record'];\n        const profileName = 'Change Detection';\n        // Profiler is not available in Android browsers without dev tools opened\n        if (record && 'profile' in console && typeof console.profile === 'function') {\n            console.profile(profileName);\n        }\n        const start = performance.now();\n        let numTicks = 0;\n        while (numTicks < 5 || performance.now() - start < 500) {\n            this.appRef.tick();\n            numTicks++;\n        }\n        const end = performance.now();\n        if (record && 'profileEnd' in console && typeof console.profileEnd === 'function') {\n            console.profileEnd(profileName);\n        }\n        const msPerTick = (end - start) / numTicks;\n        console.log(`ran ${numTicks} change detection cycles`);\n        console.log(`${msPerTick.toFixed(2)} ms per check`);\n        return new ChangeDetectionPerfRecord(msPerTick, numTicks);\n    }\n}\n\nconst PROFILER_GLOBAL_NAME = 'profiler';\n/**\n * Enabled Angular debug tools that are accessible via your browser's\n * developer console.\n *\n * Usage:\n *\n * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)\n * 1. Type `ng.` (usually the console will show auto-complete suggestion)\n * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`\n *    then hit Enter.\n *\n * @publicApi\n */\nfunction enableDebugTools(ref) {\n    exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));\n    return ref;\n}\n/**\n * Disables Angular tools.\n *\n * @publicApi\n */\nfunction disableDebugTools() {\n    exportNgVar(PROFILER_GLOBAL_NAME, null);\n}\n\n/**\n * Predicates for use with {@link DebugElement}'s query functions.\n *\n * @publicApi\n */\nclass By {\n    /**\n     * Match all nodes.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}\n     */\n    static all() {\n        return () => true;\n    }\n    /**\n     * Match elements by the given CSS selector.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}\n     */\n    static css(selector) {\n        return (debugElement) => {\n            return debugElement.nativeElement != null\n                ? elementMatches(debugElement.nativeElement, selector)\n                : false;\n        };\n    }\n    /**\n     * Match nodes that have the given directive present.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}\n     */\n    static directive(type) {\n        return (debugNode) => debugNode.providerTokens.indexOf(type) !== -1;\n    }\n}\nfunction elementMatches(n, selector) {\n    if (_getDOM().isElementNode(n)) {\n        return ((n.matches && n.matches(selector)) ||\n            (n.msMatchesSelector && n.msMatchesSelector(selector)) ||\n            (n.webkitMatchesSelector && n.webkitMatchesSelector(selector)));\n    }\n    return false;\n}\n\n/// <reference types=\"hammerjs\" />\n/**\n * Supported HammerJS recognizer event names.\n */\nconst EVENT_NAMES = {\n    // pan\n    'pan': true,\n    'panstart': true,\n    'panmove': true,\n    'panend': true,\n    'pancancel': true,\n    'panleft': true,\n    'panright': true,\n    'panup': true,\n    'pandown': true,\n    // pinch\n    'pinch': true,\n    'pinchstart': true,\n    'pinchmove': true,\n    'pinchend': true,\n    'pinchcancel': true,\n    'pinchin': true,\n    'pinchout': true,\n    // press\n    'press': true,\n    'pressup': true,\n    // rotate\n    'rotate': true,\n    'rotatestart': true,\n    'rotatemove': true,\n    'rotateend': true,\n    'rotatecancel': true,\n    // swipe\n    'swipe': true,\n    'swipeleft': true,\n    'swiperight': true,\n    'swipeup': true,\n    'swipedown': true,\n    // tap\n    'tap': true,\n    'doubletap': true,\n};\n/**\n * DI token for providing [HammerJS](https://hammerjs.github.io/) support to Angular.\n * @see {@link HammerGestureConfig}\n *\n * @ngModule HammerModule\n * @publicApi\n *\n * @deprecated The HammerJS integration is deprecated. Replace it by your own implementation.\n */\nconst HAMMER_GESTURE_CONFIG = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerGestureConfig' : '');\n/**\n * Injection token used to provide a HammerLoader to Angular.\n *\n * @see {@link HammerLoader}\n *\n * @publicApi\n *\n * @deprecated The HammerJS integration is deprecated. Replace it by your own implementation.\n */\nconst HAMMER_LOADER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerLoader' : '');\n/**\n * An injectable [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n * for gesture recognition. Configures specific event recognition.\n * @publicApi\n *\n * @deprecated The HammerJS integration is deprecated. Replace it by your own implementation.\n */\nclass HammerGestureConfig {\n    /**\n     * A set of supported event names for gestures to be used in Angular.\n     * Angular supports all built-in recognizers, as listed in\n     * [HammerJS documentation](https://hammerjs.github.io/).\n     */\n    events = [];\n    /**\n     * Maps gesture event names to a set of configuration options\n     * that specify overrides to the default values for specific properties.\n     *\n     * The key is a supported event name to be configured,\n     * and the options object contains a set of properties, with override values\n     * to be applied to the named recognizer event.\n     * For example, to disable recognition of the rotate event, specify\n     *  `{\"rotate\": {\"enable\": false}}`.\n     *\n     * Properties that are not present take the HammerJS default values.\n     * For information about which properties are supported for which events,\n     * and their allowed and default values, see\n     * [HammerJS documentation](https://hammerjs.github.io/).\n     *\n     */\n    overrides = {};\n    /**\n     * Properties whose default values can be overridden for a given event.\n     * Different sets of properties apply to different events.\n     * For information about which properties are supported for which events,\n     * and their allowed and default values, see\n     * [HammerJS documentation](https://hammerjs.github.io/).\n     */\n    options;\n    /**\n     * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n     * and attaches it to a given HTML element.\n     * @param element The element that will recognize gestures.\n     * @returns A HammerJS event-manager object.\n     */\n    buildHammer(element) {\n        const mc = new Hammer(element, this.options);\n        mc.get('pinch').set({ enable: true });\n        mc.get('rotate').set({ enable: true });\n        for (const eventName in this.overrides) {\n            mc.get(eventName).set(this.overrides[eventName]);\n        }\n        return mc;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerGestureConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerGestureConfig });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerGestureConfig, decorators: [{\n            type: Injectable\n        }] });\n/**\n * Event plugin that adds Hammer support to an application.\n *\n * @ngModule HammerModule\n */\nclass HammerGesturesPlugin extends EventManagerPlugin {\n    _config;\n    _injector;\n    loader;\n    _loaderPromise = null;\n    constructor(doc, _config, _injector, loader) {\n        super(doc);\n        this._config = _config;\n        this._injector = _injector;\n        this.loader = loader;\n    }\n    supports(eventName) {\n        if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n            return false;\n        }\n        if (!window.Hammer && !this.loader) {\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                // Get a `Console` through an injector to tree-shake the\n                // class when it is unused in production.\n                const _console = this._injector.get(_Console);\n                _console.warn(`The \"${eventName}\" event cannot be bound because Hammer.JS is not ` +\n                    `loaded and no custom loader has been specified.`);\n            }\n            return false;\n        }\n        return true;\n    }\n    addEventListener(element, eventName, handler) {\n        const zone = this.manager.getZone();\n        eventName = eventName.toLowerCase();\n        // If Hammer is not present but a loader is specified, we defer adding the event listener\n        // until Hammer is loaded.\n        if (!window.Hammer && this.loader) {\n            this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());\n            // This `addEventListener` method returns a function to remove the added listener.\n            // Until Hammer is loaded, the returned function needs to *cancel* the registration rather\n            // than remove anything.\n            let cancelRegistration = false;\n            let deregister = () => {\n                cancelRegistration = true;\n            };\n            zone.runOutsideAngular(() => this._loaderPromise.then(() => {\n                // If Hammer isn't actually loaded when the custom loader resolves, give up.\n                if (!window.Hammer) {\n                    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                        const _console = this._injector.get(_Console);\n                        _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);\n                    }\n                    deregister = () => { };\n                    return;\n                }\n                if (!cancelRegistration) {\n                    // Now that Hammer is loaded and the listener is being loaded for real,\n                    // the deregistration function changes from canceling registration to\n                    // removal.\n                    deregister = this.addEventListener(element, eventName, handler);\n                }\n            }).catch(() => {\n                if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                    const _console = this._injector.get(_Console);\n                    _console.warn(`The \"${eventName}\" event cannot be bound because the custom ` +\n                        `Hammer.JS loader failed.`);\n                }\n                deregister = () => { };\n            }));\n            // Return a function that *executes* `deregister` (and not `deregister` itself) so that we\n            // can change the behavior of `deregister` once the listener is added. Using a closure in\n            // this way allows us to avoid any additional data structures to track listener removal.\n            return () => {\n                deregister();\n            };\n        }\n        return zone.runOutsideAngular(() => {\n            // Creating the manager bind events, must be done outside of angular\n            const mc = this._config.buildHammer(element);\n            const callback = function (eventObj) {\n                zone.runGuarded(function () {\n                    handler(eventObj);\n                });\n            };\n            mc.on(eventName, callback);\n            return () => {\n                mc.off(eventName, callback);\n                // destroy mc to prevent memory leak\n                if (typeof mc.destroy === 'function') {\n                    mc.destroy();\n                }\n            };\n        });\n    }\n    isCustomEvent(eventName) {\n        return this._config.events.indexOf(eventName) > -1;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerGesturesPlugin, deps: [{ token: DOCUMENT }, { token: HAMMER_GESTURE_CONFIG }, { token: i0.Injector }, { token: HAMMER_LOADER, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerGesturesPlugin });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerGesturesPlugin, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: HammerGestureConfig, decorators: [{\n                    type: Inject,\n                    args: [HAMMER_GESTURE_CONFIG]\n                }] }, { type: i0.Injector }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [HAMMER_LOADER]\n                }] }] });\n/**\n * Adds support for HammerJS.\n *\n * Import this module at the root of your application so that Angular can work with\n * HammerJS to detect gesture events.\n *\n * Note that applications still need to include the HammerJS script itself. This module\n * simply sets up the coordination layer between HammerJS and Angular's `EventManager`.\n *\n * @publicApi\n *\n * @deprecated The hammer integration is deprecated. Replace it by your own implementation.\n */\nclass HammerModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerModule, providers: [\n            {\n                provide: EVENT_MANAGER_PLUGINS,\n                useClass: HammerGesturesPlugin,\n                multi: true,\n                deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]],\n            },\n            { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },\n        ] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HammerModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [\n                        {\n                            provide: EVENT_MANAGER_PLUGINS,\n                            useClass: HammerGesturesPlugin,\n                            multi: true,\n                            deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]],\n                        },\n                        { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },\n                    ],\n                }]\n        }] });\n\n/**\n * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing\n * values to be safe to use in the different DOM contexts.\n *\n * For example, when binding a URL in an `<a [href]=\"someValue\">` hyperlink, `someValue` will be\n * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on\n * the website.\n *\n * In specific situations, it might be necessary to disable sanitization, for example if the\n * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.\n * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`\n * methods, and then binding to that value from the template.\n *\n * These situations should be very rare, and extraordinary care must be taken to avoid creating a\n * Cross Site Scripting (XSS) security bug!\n *\n * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as\n * close as possible to the source of the value, to make it easy to verify no security bug is\n * created by its use.\n *\n * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that\n * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous\n * code. The sanitizer leaves safe values intact.\n *\n * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in\n * sanitization for the value passed in. Carefully check and audit all values and code paths going\n * into this call. Make sure any user data is appropriately escaped for this security context.\n * For more detail, see the [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\nclass DomSanitizer {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DomSanitizer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DomSanitizer, providedIn: 'root', useExisting: i0.forwardRef(() => DomSanitizerImpl) });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DomSanitizer, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useExisting: forwardRef(() => DomSanitizerImpl) }]\n        }] });\nclass DomSanitizerImpl extends DomSanitizer {\n    _doc;\n    constructor(_doc) {\n        super();\n        this._doc = _doc;\n    }\n    sanitize(ctx, value) {\n        if (value == null)\n            return null;\n        switch (ctx) {\n            case SecurityContext.NONE:\n                return value;\n            case SecurityContext.HTML:\n                if (_allowSanitizationBypassAndThrow(value, \"HTML\" /* BypassType.Html */)) {\n                    return _unwrapSafeValue(value);\n                }\n                return __sanitizeHtml(this._doc, String(value)).toString();\n            case SecurityContext.STYLE:\n                if (_allowSanitizationBypassAndThrow(value, \"Style\" /* BypassType.Style */)) {\n                    return _unwrapSafeValue(value);\n                }\n                return value;\n            case SecurityContext.SCRIPT:\n                if (_allowSanitizationBypassAndThrow(value, \"Script\" /* BypassType.Script */)) {\n                    return _unwrapSafeValue(value);\n                }\n                throw new _RuntimeError(5200 /* RuntimeErrorCode.SANITIZATION_UNSAFE_SCRIPT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                    'unsafe value used in a script context');\n            case SecurityContext.URL:\n                if (_allowSanitizationBypassAndThrow(value, \"URL\" /* BypassType.Url */)) {\n                    return _unwrapSafeValue(value);\n                }\n                return __sanitizeUrl(String(value));\n            case SecurityContext.RESOURCE_URL:\n                if (_allowSanitizationBypassAndThrow(value, \"ResourceURL\" /* BypassType.ResourceUrl */)) {\n                    return _unwrapSafeValue(value);\n                }\n                throw new _RuntimeError(5201 /* RuntimeErrorCode.SANITIZATION_UNSAFE_RESOURCE_URL */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                    `unsafe value used in a resource URL context (see ${_XSS_SECURITY_URL})`);\n            default:\n                throw new _RuntimeError(5202 /* RuntimeErrorCode.SANITIZATION_UNEXPECTED_CTX */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                    `Unexpected SecurityContext ${ctx} (see ${_XSS_SECURITY_URL})`);\n        }\n    }\n    bypassSecurityTrustHtml(value) {\n        return _bypassSanitizationTrustHtml(value);\n    }\n    bypassSecurityTrustStyle(value) {\n        return _bypassSanitizationTrustStyle(value);\n    }\n    bypassSecurityTrustScript(value) {\n        return _bypassSanitizationTrustScript(value);\n    }\n    bypassSecurityTrustUrl(value) {\n        return _bypassSanitizationTrustUrl(value);\n    }\n    bypassSecurityTrustResourceUrl(value) {\n        return _bypassSanitizationTrustResourceUrl(value);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DomSanitizerImpl, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DomSanitizerImpl, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DomSanitizerImpl, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\n/**\n * The list of features as an enum to uniquely type each `HydrationFeature`.\n * @see {@link HydrationFeature}\n *\n * @publicApi\n */\nvar HydrationFeatureKind;\n(function (HydrationFeatureKind) {\n    HydrationFeatureKind[HydrationFeatureKind[\"NoHttpTransferCache\"] = 0] = \"NoHttpTransferCache\";\n    HydrationFeatureKind[HydrationFeatureKind[\"HttpTransferCacheOptions\"] = 1] = \"HttpTransferCacheOptions\";\n    HydrationFeatureKind[HydrationFeatureKind[\"I18nSupport\"] = 2] = \"I18nSupport\";\n    HydrationFeatureKind[HydrationFeatureKind[\"EventReplay\"] = 3] = \"EventReplay\";\n    HydrationFeatureKind[HydrationFeatureKind[\"IncrementalHydration\"] = 4] = \"IncrementalHydration\";\n})(HydrationFeatureKind || (HydrationFeatureKind = {}));\n/**\n * Helper function to create an object that represents a Hydration feature.\n */\nfunction hydrationFeature(ɵkind, ɵproviders = [], ɵoptions = {}) {\n    return { ɵkind, ɵproviders };\n}\n/**\n * Disables HTTP transfer cache. Effectively causes HTTP requests to be performed twice: once on the\n * server and other one on the browser.\n *\n * @publicApi\n */\nfunction withNoHttpTransferCache() {\n    // This feature has no providers and acts as a flag that turns off\n    // HTTP transfer cache (which otherwise is turned on by default).\n    return hydrationFeature(HydrationFeatureKind.NoHttpTransferCache);\n}\n/**\n * The function accepts an object, which allows to configure cache parameters,\n * such as which headers should be included (no headers are included by default),\n * whether POST requests should be cached or a callback function to determine if a\n * particular request should be cached.\n *\n * @publicApi\n */\nfunction withHttpTransferCacheOptions(options) {\n    // This feature has no providers and acts as a flag to pass options to the HTTP transfer cache.\n    return hydrationFeature(HydrationFeatureKind.HttpTransferCacheOptions, _withHttpTransferCache(options));\n}\n/**\n * Enables support for hydrating i18n blocks.\n *\n * @publicApi 20.0\n */\nfunction withI18nSupport() {\n    return hydrationFeature(HydrationFeatureKind.I18nSupport, _withI18nSupport());\n}\n/**\n * Enables support for replaying user events (e.g. `click`s) that happened on a page\n * before hydration logic has completed. Once an application is hydrated, all captured\n * events are replayed and relevant event listeners are executed.\n *\n * @usageNotes\n *\n * Basic example of how you can enable event replay in your application when\n * `bootstrapApplication` function is used:\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideClientHydration(withEventReplay())]\n * });\n * ```\n * @publicApi\n * @see {@link provideClientHydration}\n */\nfunction withEventReplay() {\n    return hydrationFeature(HydrationFeatureKind.EventReplay, _withEventReplay());\n}\n/**\n * Enables support for incremental hydration using the `hydrate` trigger syntax.\n *\n * @usageNotes\n *\n * Basic example of how you can enable incremental hydration in your application when\n * the `bootstrapApplication` function is used:\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideClientHydration(withIncrementalHydration())]\n * });\n * ```\n * @publicApi 20.0\n * @see {@link provideClientHydration}\n */\nfunction withIncrementalHydration() {\n    return hydrationFeature(HydrationFeatureKind.IncrementalHydration, _withIncrementalHydration());\n}\n/**\n * Returns an `ENVIRONMENT_INITIALIZER` token setup with a function\n * that verifies whether compatible ZoneJS was used in an application\n * and logs a warning in a console if it's not the case.\n */\nfunction provideZoneJsCompatibilityDetector() {\n    return [\n        {\n            provide: ENVIRONMENT_INITIALIZER,\n            useValue: () => {\n                const ngZone = inject(NgZone);\n                const isZoneless = inject(_ZONELESS_ENABLED);\n                // Checking `ngZone instanceof NgZone` would be insufficient here,\n                // because custom implementations might use NgZone as a base class.\n                if (!isZoneless && ngZone.constructor !== NgZone) {\n                    const console = inject(_Console);\n                    const message = _formatRuntimeError(-5000 /* RuntimeErrorCode.UNSUPPORTED_ZONEJS_INSTANCE */, 'Angular detected that hydration was enabled for an application ' +\n                        'that uses a custom or a noop Zone.js implementation. ' +\n                        'This is not yet a fully supported configuration.');\n                    console.warn(message);\n                }\n            },\n            multi: true,\n        },\n    ];\n}\n/**\n * Sets up providers necessary to enable hydration functionality for the application.\n *\n * By default, the function enables the recommended set of features for the optimal\n * performance for most of the applications. It includes the following features:\n *\n * * Reconciling DOM hydration. Learn more about it [here](guide/hydration).\n * * [`HttpClient`](api/common/http/HttpClient) response caching while running on the server and\n * transferring this cache to the client to avoid extra HTTP requests. Learn more about data caching\n * [here](guide/ssr#caching-data-when-using-httpclient).\n *\n * These functions allow you to disable some of the default features or enable new ones:\n *\n * * {@link withNoHttpTransferCache} to disable HTTP transfer cache\n * * {@link withHttpTransferCacheOptions} to configure some HTTP transfer cache options\n * * {@link withI18nSupport} to enable hydration support for i18n blocks\n * * {@link withEventReplay} to enable support for replaying user events\n *\n * @usageNotes\n *\n * Basic example of how you can enable hydration in your application when\n * `bootstrapApplication` function is used:\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideClientHydration()]\n * });\n * ```\n *\n * Alternatively if you are using NgModules, you would add `provideClientHydration`\n * to your root app module's provider list.\n * ```ts\n * @NgModule({\n *   declarations: [RootCmp],\n *   bootstrap: [RootCmp],\n *   providers: [provideClientHydration()],\n * })\n * export class AppModule {}\n * ```\n *\n * @see {@link withNoHttpTransferCache}\n * @see {@link withHttpTransferCacheOptions}\n * @see {@link withI18nSupport}\n * @see {@link withEventReplay}\n *\n * @param features Optional features to configure additional hydration behaviors.\n * @returns A set of providers to enable hydration.\n *\n * @publicApi 17.0\n */\nfunction provideClientHydration(...features) {\n    const providers = [];\n    const featuresKind = new Set();\n    for (const { ɵproviders, ɵkind } of features) {\n        featuresKind.add(ɵkind);\n        if (ɵproviders.length) {\n            providers.push(ɵproviders);\n        }\n    }\n    const hasHttpTransferCacheOptions = featuresKind.has(HydrationFeatureKind.HttpTransferCacheOptions);\n    if (typeof ngDevMode !== 'undefined' &&\n        ngDevMode &&\n        featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) &&\n        hasHttpTransferCacheOptions) {\n        throw new _RuntimeError(5001 /* RuntimeErrorCode.HYDRATION_CONFLICTING_FEATURES */, 'Configuration error: found both withHttpTransferCacheOptions() and withNoHttpTransferCache() in the same call to provideClientHydration(), which is a contradiction.');\n    }\n    return makeEnvironmentProviders([\n        typeof ngDevMode !== 'undefined' && ngDevMode ? provideZoneJsCompatibilityDetector() : [],\n        _withDomHydration(),\n        featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) || hasHttpTransferCacheOptions\n            ? []\n            : _withHttpTransferCache({}),\n        providers,\n    ]);\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-browser package.\n */\n/**\n * @publicApi\n */\nconst VERSION = new Version('20.1.4');\n\nexport { By, DomSanitizer, EVENT_MANAGER_PLUGINS, EventManagerPlugin, HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerModule, HydrationFeatureKind, Meta, Title, VERSION, disableDebugTools, enableDebugTools, provideClientHydration, withEventReplay, withHttpTransferCacheOptions, withI18nSupport, withIncrementalHydration, withNoHttpTransferCache, DomSanitizerImpl as ɵDomSanitizerImpl, HammerGesturesPlugin as ɵHammerGesturesPlugin };\n\n","import * as i1 from '@angular/common/http';\nimport { HttpClient } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { SecurityContext, DOCUMENT, Injectable, Optional, Inject, SkipSelf, ErrorHandler } from '@angular/core';\nimport * as i2 from '@angular/platform-browser';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { of, throwError, forkJoin } from 'rxjs';\nimport { tap, map, catchError, finalize, share } from 'rxjs/operators';\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n    if (policy === undefined) {\n        policy = null;\n        if (typeof window !== 'undefined') {\n            const ttWindow = window;\n            if (ttWindow.trustedTypes !== undefined) {\n                policy = ttWindow.trustedTypes.createPolicy('angular#components', {\n                    createHTML: (s) => s,\n                });\n            }\n        }\n    }\n    return policy;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\nfunction trustedHTMLFromString(html) {\n    return getPolicy()?.createHTML(html) || html;\n}\n\n/**\n * Returns an exception to be thrown in the case when attempting to\n * load an icon with a name that cannot be found.\n * @docs-private\n */\nfunction getMatIconNameNotFoundError(iconName) {\n    return Error(`Unable to find icon with the name \"${iconName}\"`);\n}\n/**\n * Returns an exception to be thrown when the consumer attempts to use\n * `<mat-icon>` without including @angular/common/http.\n * @docs-private\n */\nfunction getMatIconNoHttpProviderError() {\n    return Error('Could not find HttpClient for use with Angular Material icons. ' +\n        'Please add provideHttpClient() to your providers.');\n}\n/**\n * Returns an exception to be thrown when a URL couldn't be sanitized.\n * @param url URL that was attempted to be sanitized.\n * @docs-private\n */\nfunction getMatIconFailedToSanitizeUrlError(url) {\n    return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL ` +\n        `via Angular's DomSanitizer. Attempted URL was \"${url}\".`);\n}\n/**\n * Returns an exception to be thrown when a HTML string couldn't be sanitized.\n * @param literal HTML that was attempted to be sanitized.\n * @docs-private\n */\nfunction getMatIconFailedToSanitizeLiteralError(literal) {\n    return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by ` +\n        `Angular's DomSanitizer. Attempted literal was \"${literal}\".`);\n}\n/**\n * Configuration for an icon, including the URL and possibly the cached SVG element.\n * @docs-private\n */\nclass SvgIconConfig {\n    url;\n    svgText;\n    options;\n    svgElement;\n    constructor(url, svgText, options) {\n        this.url = url;\n        this.svgText = svgText;\n        this.options = options;\n    }\n}\n/**\n * Service to register and display icons used by the `<mat-icon>` component.\n * - Registers icon URLs by namespace and name.\n * - Registers icon set URLs by namespace.\n * - Registers aliases for CSS classes, for use with icon fonts.\n * - Loads icons from URLs and extracts individual icons from icon sets.\n */\nclass MatIconRegistry {\n    _httpClient;\n    _sanitizer;\n    _errorHandler;\n    _document;\n    /**\n     * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\n     */\n    _svgIconConfigs = new Map();\n    /**\n     * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.\n     * Multiple icon sets can be registered under the same namespace.\n     */\n    _iconSetConfigs = new Map();\n    /** Cache for icons loaded by direct URLs. */\n    _cachedIconsByUrl = new Map();\n    /** In-progress icon fetches. Used to coalesce multiple requests to the same URL. */\n    _inProgressUrlFetches = new Map();\n    /** Map from font identifiers to their CSS class names. Used for icon fonts. */\n    _fontCssClassesByAlias = new Map();\n    /** Registered icon resolver functions. */\n    _resolvers = [];\n    /**\n     * The CSS classes to apply when an `<mat-icon>` component has no icon name, url, or font\n     * specified. The default 'material-icons' value assumes that the material icon font has been\n     * loaded as described at https://google.github.io/material-design-icons/#icon-font-for-the-web\n     */\n    _defaultFontSetClass = ['material-icons', 'mat-ligature-font'];\n    constructor(_httpClient, _sanitizer, document, _errorHandler) {\n        this._httpClient = _httpClient;\n        this._sanitizer = _sanitizer;\n        this._errorHandler = _errorHandler;\n        this._document = document;\n    }\n    /**\n     * Registers an icon by URL in the default namespace.\n     * @param iconName Name under which the icon should be registered.\n     * @param url\n     */\n    addSvgIcon(iconName, url, options) {\n        return this.addSvgIconInNamespace('', iconName, url, options);\n    }\n    /**\n     * Registers an icon using an HTML string in the default namespace.\n     * @param iconName Name under which the icon should be registered.\n     * @param literal SVG source of the icon.\n     */\n    addSvgIconLiteral(iconName, literal, options) {\n        return this.addSvgIconLiteralInNamespace('', iconName, literal, options);\n    }\n    /**\n     * Registers an icon by URL in the specified namespace.\n     * @param namespace Namespace in which the icon should be registered.\n     * @param iconName Name under which the icon should be registered.\n     * @param url\n     */\n    addSvgIconInNamespace(namespace, iconName, url, options) {\n        return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url, null, options));\n    }\n    /**\n     * Registers an icon resolver function with the registry. The function will be invoked with the\n     * name and namespace of an icon when the registry tries to resolve the URL from which to fetch\n     * the icon. The resolver is expected to return a `SafeResourceUrl` that points to the icon,\n     * an object with the icon URL and icon options, or `null` if the icon is not supported. Resolvers\n     * will be invoked in the order in which they have been registered.\n     * @param resolver Resolver function to be registered.\n     */\n    addSvgIconResolver(resolver) {\n        this._resolvers.push(resolver);\n        return this;\n    }\n    /**\n     * Registers an icon using an HTML string in the specified namespace.\n     * @param namespace Namespace in which the icon should be registered.\n     * @param iconName Name under which the icon should be registered.\n     * @param literal SVG source of the icon.\n     */\n    addSvgIconLiteralInNamespace(namespace, iconName, literal, options) {\n        const cleanLiteral = this._sanitizer.sanitize(SecurityContext.HTML, literal);\n        // TODO: add an ngDevMode check\n        if (!cleanLiteral) {\n            throw getMatIconFailedToSanitizeLiteralError(literal);\n        }\n        // Security: The literal is passed in as SafeHtml, and is thus trusted.\n        const trustedLiteral = trustedHTMLFromString(cleanLiteral);\n        return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig('', trustedLiteral, options));\n    }\n    /**\n     * Registers an icon set by URL in the default namespace.\n     * @param url\n     */\n    addSvgIconSet(url, options) {\n        return this.addSvgIconSetInNamespace('', url, options);\n    }\n    /**\n     * Registers an icon set using an HTML string in the default namespace.\n     * @param literal SVG source of the icon set.\n     */\n    addSvgIconSetLiteral(literal, options) {\n        return this.addSvgIconSetLiteralInNamespace('', literal, options);\n    }\n    /**\n     * Registers an icon set by URL in the specified namespace.\n     * @param namespace Namespace in which to register the icon set.\n     * @param url\n     */\n    addSvgIconSetInNamespace(namespace, url, options) {\n        return this._addSvgIconSetConfig(namespace, new SvgIconConfig(url, null, options));\n    }\n    /**\n     * Registers an icon set using an HTML string in the specified namespace.\n     * @param namespace Namespace in which to register the icon set.\n     * @param literal SVG source of the icon set.\n     */\n    addSvgIconSetLiteralInNamespace(namespace, literal, options) {\n        const cleanLiteral = this._sanitizer.sanitize(SecurityContext.HTML, literal);\n        if (!cleanLiteral) {\n            throw getMatIconFailedToSanitizeLiteralError(literal);\n        }\n        // Security: The literal is passed in as SafeHtml, and is thus trusted.\n        const trustedLiteral = trustedHTMLFromString(cleanLiteral);\n        return this._addSvgIconSetConfig(namespace, new SvgIconConfig('', trustedLiteral, options));\n    }\n    /**\n     * Defines an alias for CSS class names to be used for icon fonts. Creating an matIcon\n     * component with the alias as the fontSet input will cause the class name to be applied\n     * to the `<mat-icon>` element.\n     *\n     * If the registered font is a ligature font, then don't forget to also include the special\n     * class `mat-ligature-font` to allow the usage via attribute. So register like this:\n     *\n     * ```ts\n     * iconRegistry.registerFontClassAlias('f1', 'font1 mat-ligature-font');\n     * ```\n     *\n     * And use like this:\n     *\n     * ```html\n     * <mat-icon fontSet=\"f1\" fontIcon=\"home\"></mat-icon>\n     * ```\n     *\n     * @param alias Alias for the font.\n     * @param classNames Class names override to be used instead of the alias.\n     */\n    registerFontClassAlias(alias, classNames = alias) {\n        this._fontCssClassesByAlias.set(alias, classNames);\n        return this;\n    }\n    /**\n     * Returns the CSS class name associated with the alias by a previous call to\n     * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.\n     */\n    classNameForFontAlias(alias) {\n        return this._fontCssClassesByAlias.get(alias) || alias;\n    }\n    /**\n     * Sets the CSS classes to be used for icon fonts when an `<mat-icon>` component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     */\n    setDefaultFontSetClass(...classNames) {\n        this._defaultFontSetClass = classNames;\n        return this;\n    }\n    /**\n     * Returns the CSS classes to be used for icon fonts when an `<mat-icon>` component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     */\n    getDefaultFontSetClass() {\n        return this._defaultFontSetClass;\n    }\n    /**\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.\n     * The response from the URL may be cached so this will not always cause an HTTP request, but\n     * the produced element will always be a new copy of the originally fetched icon. (That is,\n     * it will not contain any modifications made to elements previously returned).\n     *\n     * @param safeUrl URL from which to fetch the SVG icon.\n     */\n    getSvgIconFromUrl(safeUrl) {\n        const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n        if (!url) {\n            throw getMatIconFailedToSanitizeUrlError(safeUrl);\n        }\n        const cachedIcon = this._cachedIconsByUrl.get(url);\n        if (cachedIcon) {\n            return of(cloneSvg(cachedIcon));\n        }\n        return this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl, null)).pipe(tap(svg => this._cachedIconsByUrl.set(url, svg)), map(svg => cloneSvg(svg)));\n    }\n    /**\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name\n     * and namespace. The icon must have been previously registered with addIcon or addIconSet;\n     * if not, the Observable will throw an error.\n     *\n     * @param name Name of the icon to be retrieved.\n     * @param namespace Namespace in which to look for the icon.\n     */\n    getNamedSvgIcon(name, namespace = '') {\n        const key = iconKey(namespace, name);\n        let config = this._svgIconConfigs.get(key);\n        // Return (copy of) cached icon if possible.\n        if (config) {\n            return this._getSvgFromConfig(config);\n        }\n        // Otherwise try to resolve the config from one of the resolver functions.\n        config = this._getIconConfigFromResolvers(namespace, name);\n        if (config) {\n            this._svgIconConfigs.set(key, config);\n            return this._getSvgFromConfig(config);\n        }\n        // See if we have any icon sets registered for the namespace.\n        const iconSetConfigs = this._iconSetConfigs.get(namespace);\n        if (iconSetConfigs) {\n            return this._getSvgFromIconSetConfigs(name, iconSetConfigs);\n        }\n        return throwError(getMatIconNameNotFoundError(key));\n    }\n    ngOnDestroy() {\n        this._resolvers = [];\n        this._svgIconConfigs.clear();\n        this._iconSetConfigs.clear();\n        this._cachedIconsByUrl.clear();\n    }\n    /**\n     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\n     */\n    _getSvgFromConfig(config) {\n        if (config.svgText) {\n            // We already have the SVG element for this icon, return a copy.\n            return of(cloneSvg(this._svgElementFromConfig(config)));\n        }\n        else {\n            // Fetch the icon from the config's URL, cache it, and return a copy.\n            return this._loadSvgIconFromConfig(config).pipe(map(svg => cloneSvg(svg)));\n        }\n    }\n    /**\n     * Attempts to find an icon with the specified name in any of the SVG icon sets.\n     * First searches the available cached icons for a nested element with a matching name, and\n     * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets\n     * that have not been cached, and searches again after all fetches are completed.\n     * The returned Observable produces the SVG element if possible, and throws\n     * an error if no icon with the specified name can be found.\n     */\n    _getSvgFromIconSetConfigs(name, iconSetConfigs) {\n        // For all the icon set SVG elements we've fetched, see if any contain an icon with the\n        // requested name.\n        const namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n        if (namedIcon) {\n            // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every\n            // time anyway, there's probably not much advantage compared to just always extracting\n            // it from the icon set.\n            return of(namedIcon);\n        }\n        // Not found in any cached icon sets. If there are icon sets with URLs that we haven't\n        // fetched, fetch them now and look for iconName in the results.\n        const iconSetFetchRequests = iconSetConfigs\n            .filter(iconSetConfig => !iconSetConfig.svgText)\n            .map(iconSetConfig => {\n            return this._loadSvgIconSetFromConfig(iconSetConfig).pipe(catchError((err) => {\n                const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, iconSetConfig.url);\n                // Swallow errors fetching individual URLs so the\n                // combined Observable won't necessarily fail.\n                const errorMessage = `Loading icon set URL: ${url} failed: ${err.message}`;\n                this._errorHandler.handleError(new Error(errorMessage));\n                return of(null);\n            }));\n        });\n        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a\n        // cached SVG element (unless the request failed), and we can check again for the icon.\n        return forkJoin(iconSetFetchRequests).pipe(map(() => {\n            const foundIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n            // TODO: add an ngDevMode check\n            if (!foundIcon) {\n                throw getMatIconNameNotFoundError(name);\n            }\n            return foundIcon;\n        }));\n    }\n    /**\n     * Searches the cached SVG elements for the given icon sets for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     */\n    _extractIconWithNameFromAnySet(iconName, iconSetConfigs) {\n        // Iterate backwards, so icon sets added later have precedence.\n        for (let i = iconSetConfigs.length - 1; i >= 0; i--) {\n            const config = iconSetConfigs[i];\n            // Parsing the icon set's text into an SVG element can be expensive. We can avoid some of\n            // the parsing by doing a quick check using `indexOf` to see if there's any chance for the\n            // icon to be in the set. This won't be 100% accurate, but it should help us avoid at least\n            // some of the parsing.\n            if (config.svgText && config.svgText.toString().indexOf(iconName) > -1) {\n                const svg = this._svgElementFromConfig(config);\n                const foundIcon = this._extractSvgIconFromSet(svg, iconName, config.options);\n                if (foundIcon) {\n                    return foundIcon;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\n     * from it.\n     */\n    _loadSvgIconFromConfig(config) {\n        return this._fetchIcon(config).pipe(tap(svgText => (config.svgText = svgText)), map(() => this._svgElementFromConfig(config)));\n    }\n    /**\n     * Loads the content of the icon set URL specified in the\n     * SvgIconConfig and attaches it to the config.\n     */\n    _loadSvgIconSetFromConfig(config) {\n        if (config.svgText) {\n            return of(null);\n        }\n        return this._fetchIcon(config).pipe(tap(svgText => (config.svgText = svgText)));\n    }\n    /**\n     * Searches the cached element of the given SvgIconConfig for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     */\n    _extractSvgIconFromSet(iconSet, iconName, options) {\n        // Use the `id=\"iconName\"` syntax in order to escape special\n        // characters in the ID (versus using the #iconName syntax).\n        const iconSource = iconSet.querySelector(`[id=\"${iconName}\"]`);\n        if (!iconSource) {\n            return null;\n        }\n        // Clone the element and remove the ID to prevent multiple elements from being added\n        // to the page with the same ID.\n        const iconElement = iconSource.cloneNode(true);\n        iconElement.removeAttribute('id');\n        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as\n        // the content of a new <svg> node.\n        if (iconElement.nodeName.toLowerCase() === 'svg') {\n            return this._setSvgAttributes(iconElement, options);\n        }\n        // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note\n        // that the same could be achieved by referring to it via <use href=\"#id\">, however the <use>\n        // tag is problematic on Firefox, because it needs to include the current page path.\n        if (iconElement.nodeName.toLowerCase() === 'symbol') {\n            return this._setSvgAttributes(this._toSvgElement(iconElement), options);\n        }\n        // createElement('SVG') doesn't work as expected; the DOM ends up with\n        // the correct nodes, but the SVG content doesn't render. Instead we\n        // have to create an empty SVG node using innerHTML and append its content.\n        // Elements created using DOMParser.parseFromString have the same problem.\n        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display\n        const svg = this._svgElementFromString(trustedHTMLFromString('<svg></svg>'));\n        // Clone the node so we don't remove it from the parent icon set element.\n        svg.appendChild(iconElement);\n        return this._setSvgAttributes(svg, options);\n    }\n    /**\n     * Creates a DOM element from the given SVG string.\n     */\n    _svgElementFromString(str) {\n        const div = this._document.createElement('DIV');\n        div.innerHTML = str;\n        const svg = div.querySelector('svg');\n        // TODO: add an ngDevMode check\n        if (!svg) {\n            throw Error('<svg> tag not found');\n        }\n        return svg;\n    }\n    /**\n     * Converts an element into an SVG node by cloning all of its children.\n     */\n    _toSvgElement(element) {\n        const svg = this._svgElementFromString(trustedHTMLFromString('<svg></svg>'));\n        const attributes = element.attributes;\n        // Copy over all the attributes from the `symbol` to the new SVG, except the id.\n        for (let i = 0; i < attributes.length; i++) {\n            const { name, value } = attributes[i];\n            if (name !== 'id') {\n                svg.setAttribute(name, value);\n            }\n        }\n        for (let i = 0; i < element.childNodes.length; i++) {\n            if (element.childNodes[i].nodeType === this._document.ELEMENT_NODE) {\n                svg.appendChild(element.childNodes[i].cloneNode(true));\n            }\n        }\n        return svg;\n    }\n    /**\n     * Sets the default attributes for an SVG element to be used as an icon.\n     */\n    _setSvgAttributes(svg, options) {\n        svg.setAttribute('fit', '');\n        svg.setAttribute('height', '100%');\n        svg.setAttribute('width', '100%');\n        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n        svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.\n        if (options && options.viewBox) {\n            svg.setAttribute('viewBox', options.viewBox);\n        }\n        return svg;\n    }\n    /**\n     * Returns an Observable which produces the string contents of the given icon. Results may be\n     * cached, so future calls with the same URL may not cause another HTTP request.\n     */\n    _fetchIcon(iconConfig) {\n        const { url: safeUrl, options } = iconConfig;\n        const withCredentials = options?.withCredentials ?? false;\n        if (!this._httpClient) {\n            throw getMatIconNoHttpProviderError();\n        }\n        // TODO: add an ngDevMode check\n        if (safeUrl == null) {\n            throw Error(`Cannot fetch icon from URL \"${safeUrl}\".`);\n        }\n        const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n        // TODO: add an ngDevMode check\n        if (!url) {\n            throw getMatIconFailedToSanitizeUrlError(safeUrl);\n        }\n        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\n        // already a request in progress for that URL. It's necessary to call share() on the\n        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.\n        const inProgressFetch = this._inProgressUrlFetches.get(url);\n        if (inProgressFetch) {\n            return inProgressFetch;\n        }\n        const req = this._httpClient.get(url, { responseType: 'text', withCredentials }).pipe(map(svg => {\n            // Security: This SVG is fetched from a SafeResourceUrl, and is thus\n            // trusted HTML.\n            return trustedHTMLFromString(svg);\n        }), finalize(() => this._inProgressUrlFetches.delete(url)), share());\n        this._inProgressUrlFetches.set(url, req);\n        return req;\n    }\n    /**\n     * Registers an icon config by name in the specified namespace.\n     * @param namespace Namespace in which to register the icon config.\n     * @param iconName Name under which to register the config.\n     * @param config Config to be registered.\n     */\n    _addSvgIconConfig(namespace, iconName, config) {\n        this._svgIconConfigs.set(iconKey(namespace, iconName), config);\n        return this;\n    }\n    /**\n     * Registers an icon set config in the specified namespace.\n     * @param namespace Namespace in which to register the icon config.\n     * @param config Config to be registered.\n     */\n    _addSvgIconSetConfig(namespace, config) {\n        const configNamespace = this._iconSetConfigs.get(namespace);\n        if (configNamespace) {\n            configNamespace.push(config);\n        }\n        else {\n            this._iconSetConfigs.set(namespace, [config]);\n        }\n        return this;\n    }\n    /** Parses a config's text into an SVG element. */\n    _svgElementFromConfig(config) {\n        if (!config.svgElement) {\n            const svg = this._svgElementFromString(config.svgText);\n            this._setSvgAttributes(svg, config.options);\n            config.svgElement = svg;\n        }\n        return config.svgElement;\n    }\n    /** Tries to create an icon config through the registered resolver functions. */\n    _getIconConfigFromResolvers(namespace, name) {\n        for (let i = 0; i < this._resolvers.length; i++) {\n            const result = this._resolvers[i](name, namespace);\n            if (result) {\n                return isSafeUrlWithOptions(result)\n                    ? new SvgIconConfig(result.url, null, result.options)\n                    : new SvgIconConfig(result, null);\n            }\n        }\n        return undefined;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconRegistry, deps: [{ token: i1.HttpClient, optional: true }, { token: i2.DomSanitizer }, { token: DOCUMENT, optional: true }, { token: i0.ErrorHandler }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconRegistry, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconRegistry, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.HttpClient, decorators: [{\n                    type: Optional\n                }] }, { type: i2.DomSanitizer }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i0.ErrorHandler }] });\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, httpClient, sanitizer, errorHandler, document) {\n    return parentRegistry || new MatIconRegistry(httpClient, sanitizer, document, errorHandler);\n}\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nconst ICON_REGISTRY_PROVIDER = {\n    // If there is already an MatIconRegistry available, use that. Otherwise, provide a new one.\n    provide: MatIconRegistry,\n    deps: [\n        [new Optional(), new SkipSelf(), MatIconRegistry],\n        [new Optional(), HttpClient],\n        DomSanitizer,\n        ErrorHandler,\n        [new Optional(), DOCUMENT],\n    ],\n    useFactory: ICON_REGISTRY_PROVIDER_FACTORY,\n};\n/** Clones an SVGElement while preserving type information. */\nfunction cloneSvg(svg) {\n    return svg.cloneNode(true);\n}\n/** Returns the cache key to use for an icon namespace and name. */\nfunction iconKey(namespace, name) {\n    return namespace + ':' + name;\n}\nfunction isSafeUrlWithOptions(value) {\n    return !!(value.url && value.options);\n}\n\nexport { ICON_REGISTRY_PROVIDER_FACTORY as I, MatIconRegistry as M, getMatIconNoHttpProviderError as a, getMatIconFailedToSanitizeUrlError as b, getMatIconFailedToSanitizeLiteralError as c, ICON_REGISTRY_PROVIDER as d, getMatIconNameNotFoundError as g };\n\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, DOCUMENT, ElementRef, ErrorHandler, HostAttributeToken, booleanAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, NgModule } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { take } from 'rxjs/operators';\nimport { M as MatIconRegistry } from './icon-registry-CwOTJ7YM.mjs';\nexport { d as ICON_REGISTRY_PROVIDER, I as ICON_REGISTRY_PROVIDER_FACTORY, c as getMatIconFailedToSanitizeLiteralError, b as getMatIconFailedToSanitizeUrlError, g as getMatIconNameNotFoundError, a as getMatIconNoHttpProviderError } from './icon-registry-CwOTJ7YM.mjs';\nimport { M as MatCommonModule } from './common-module-cKSwHniA.mjs';\nimport '@angular/common/http';\nimport '@angular/platform-browser';\nimport '@angular/cdk/a11y';\nimport '@angular/cdk/bidi';\n\n/** Injection token to be used to override the default options for `mat-icon`. */\nconst MAT_ICON_DEFAULT_OPTIONS = new InjectionToken('MAT_ICON_DEFAULT_OPTIONS');\n/**\n * Injection token used to provide the current location to `MatIcon`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * @docs-private\n */\nconst MAT_ICON_LOCATION = new InjectionToken('mat-icon-location', {\n    providedIn: 'root',\n    factory: MAT_ICON_LOCATION_FACTORY,\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction MAT_ICON_LOCATION_FACTORY() {\n    const _document = inject(DOCUMENT);\n    const _location = _document ? _document.location : null;\n    return {\n        // Note that this needs to be a function, rather than a property, because Angular\n        // will only resolve it once, but we want the current path on each call.\n        getPathname: () => (_location ? _location.pathname + _location.search : ''),\n    };\n}\n/** SVG attributes that accept a FuncIRI (e.g. `url(<something>)`). */\nconst funcIriAttributes = [\n    'clip-path',\n    'color-profile',\n    'src',\n    'cursor',\n    'fill',\n    'filter',\n    'marker',\n    'marker-start',\n    'marker-mid',\n    'marker-end',\n    'mask',\n    'stroke',\n];\n/** Selector that can be used to find all elements that are using a `FuncIRI`. */\nconst funcIriAttributeSelector = funcIriAttributes.map(attr => `[${attr}]`).join(', ');\n/** Regex that can be used to extract the id out of a FuncIRI. */\nconst funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\n/**\n * Component to display an icon. It can be used in the following ways:\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n *\n * - Use a font ligature as an icon by putting the ligature text in the `fontIcon` attribute or the\n *   content of the `<mat-icon>` component. If you register a custom font class, don't forget to also\n *   include the special class `mat-ligature-font`. It is recommended to use the attribute alternative\n *   to prevent the ligature text to be selectable and to appear in search engine results.\n *   By default, the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n *   Examples:\n *     `<mat-icon fontIcon=\"home\"></mat-icon>\n *     <mat-icon>home</mat-icon>\n *     <mat-icon fontSet=\"myfont\" fontIcon=\"sun\"></mat-icon>\n *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fontawesome-v4.github.io/examples/\n *   Example:\n *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n */\nclass MatIcon {\n    _elementRef = inject(ElementRef);\n    _iconRegistry = inject(MatIconRegistry);\n    _location = inject(MAT_ICON_LOCATION);\n    _errorHandler = inject(ErrorHandler);\n    _defaultColor;\n    /**\n     * Theme color of the icon. This API is supported in M2 themes only, it\n     * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/icon/styling.\n     *\n     * For information on applying color variants in M3, see\n     * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n     */\n    get color() {\n        return this._color || this._defaultColor;\n    }\n    set color(value) {\n        this._color = value;\n    }\n    _color;\n    /**\n     * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n     * the element the icon is contained in.\n     */\n    inline = false;\n    /** Name of the icon in the SVG icon set. */\n    get svgIcon() {\n        return this._svgIcon;\n    }\n    set svgIcon(value) {\n        if (value !== this._svgIcon) {\n            if (value) {\n                this._updateSvgIcon(value);\n            }\n            else if (this._svgIcon) {\n                this._clearSvgElement();\n            }\n            this._svgIcon = value;\n        }\n    }\n    _svgIcon;\n    /** Font set that the icon is a part of. */\n    get fontSet() {\n        return this._fontSet;\n    }\n    set fontSet(value) {\n        const newValue = this._cleanupFontValue(value);\n        if (newValue !== this._fontSet) {\n            this._fontSet = newValue;\n            this._updateFontIconClasses();\n        }\n    }\n    _fontSet;\n    /** Name of an icon within a font set. */\n    get fontIcon() {\n        return this._fontIcon;\n    }\n    set fontIcon(value) {\n        const newValue = this._cleanupFontValue(value);\n        if (newValue !== this._fontIcon) {\n            this._fontIcon = newValue;\n            this._updateFontIconClasses();\n        }\n    }\n    _fontIcon;\n    _previousFontSetClass = [];\n    _previousFontIconClass;\n    _svgName;\n    _svgNamespace;\n    /** Keeps track of the current page path. */\n    _previousPath;\n    /** Keeps track of the elements and attributes that we've prefixed with the current path. */\n    _elementsWithExternalReferences;\n    /** Subscription to the current in-progress SVG icon request. */\n    _currentIconFetch = Subscription.EMPTY;\n    constructor() {\n        const ariaHidden = inject(new HostAttributeToken('aria-hidden'), { optional: true });\n        const defaults = inject(MAT_ICON_DEFAULT_OPTIONS, { optional: true });\n        if (defaults) {\n            if (defaults.color) {\n                this.color = this._defaultColor = defaults.color;\n            }\n            if (defaults.fontSet) {\n                this.fontSet = defaults.fontSet;\n            }\n        }\n        // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\n        // the right thing to do for the majority of icon use-cases.\n        if (!ariaHidden) {\n            this._elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n        }\n    }\n    /**\n     * Splits an svgIcon binding value into its icon set and icon name components.\n     * Returns a 2-element array of [(icon set), (icon name)].\n     * The separator for the two fields is ':'. If there is no separator, an empty\n     * string is returned for the icon set and the entire value is returned for\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\n     * Throws an error if the name contains two or more ':' separators.\n     * Examples:\n     *   `'social:cake' -> ['social', 'cake']\n     *   'penguin' -> ['', 'penguin']\n     *   null -> ['', '']\n     *   'a:b:c' -> (throws Error)`\n     */\n    _splitIconName(iconName) {\n        if (!iconName) {\n            return ['', ''];\n        }\n        const parts = iconName.split(':');\n        switch (parts.length) {\n            case 1:\n                return ['', parts[0]]; // Use default namespace.\n            case 2:\n                return parts;\n            default:\n                throw Error(`Invalid icon name: \"${iconName}\"`); // TODO: add an ngDevMode check\n        }\n    }\n    ngOnInit() {\n        // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n        // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.\n        this._updateFontIconClasses();\n    }\n    ngAfterViewChecked() {\n        const cachedElements = this._elementsWithExternalReferences;\n        if (cachedElements && cachedElements.size) {\n            const newPath = this._location.getPathname();\n            // We need to check whether the URL has changed on each change detection since\n            // the browser doesn't have an API that will let us react on link clicks and\n            // we can't depend on the Angular router. The references need to be updated,\n            // because while most browsers don't care whether the URL is correct after\n            // the first render, Safari will break if the user navigates to a different\n            // page and the SVG isn't re-rendered.\n            if (newPath !== this._previousPath) {\n                this._previousPath = newPath;\n                this._prependPathToReferences(newPath);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._currentIconFetch.unsubscribe();\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n    }\n    _usingFontIcon() {\n        return !this.svgIcon;\n    }\n    _setSvgElement(svg) {\n        this._clearSvgElement();\n        // Note: we do this fix here, rather than the icon registry, because the\n        // references have to point to the URL at the time that the icon was created.\n        const path = this._location.getPathname();\n        this._previousPath = path;\n        this._cacheChildrenWithExternalReferences(svg);\n        this._prependPathToReferences(path);\n        this._elementRef.nativeElement.appendChild(svg);\n    }\n    _clearSvgElement() {\n        const layoutElement = this._elementRef.nativeElement;\n        let childCount = layoutElement.childNodes.length;\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n        // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n        // we can't use innerHTML, because IE will throw if the element has a data binding.\n        while (childCount--) {\n            const child = layoutElement.childNodes[childCount];\n            // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n            // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n            if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n                child.remove();\n            }\n        }\n    }\n    _updateFontIconClasses() {\n        if (!this._usingFontIcon()) {\n            return;\n        }\n        const elem = this._elementRef.nativeElement;\n        const fontSetClasses = (this.fontSet\n            ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/)\n            : this._iconRegistry.getDefaultFontSetClass()).filter(className => className.length > 0);\n        this._previousFontSetClass.forEach(className => elem.classList.remove(className));\n        fontSetClasses.forEach(className => elem.classList.add(className));\n        this._previousFontSetClass = fontSetClasses;\n        if (this.fontIcon !== this._previousFontIconClass &&\n            !fontSetClasses.includes('mat-ligature-font')) {\n            if (this._previousFontIconClass) {\n                elem.classList.remove(this._previousFontIconClass);\n            }\n            if (this.fontIcon) {\n                elem.classList.add(this.fontIcon);\n            }\n            this._previousFontIconClass = this.fontIcon;\n        }\n    }\n    /**\n     * Cleans up a value to be used as a fontIcon or fontSet.\n     * Since the value ends up being assigned as a CSS class, we\n     * have to trim the value and omit space-separated values.\n     */\n    _cleanupFontValue(value) {\n        return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n    }\n    /**\n     * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n     * reference. This is required because WebKit browsers require references to be prefixed with\n     * the current path, if the page has a `base` tag.\n     */\n    _prependPathToReferences(path) {\n        const elements = this._elementsWithExternalReferences;\n        if (elements) {\n            elements.forEach((attrs, element) => {\n                attrs.forEach(attr => {\n                    element.setAttribute(attr.name, `url('${path}#${attr.value}')`);\n                });\n            });\n        }\n    }\n    /**\n     * Caches the children of an SVG element that have `url()`\n     * references that we need to prefix with the current path.\n     */\n    _cacheChildrenWithExternalReferences(element) {\n        const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n        const elements = (this._elementsWithExternalReferences =\n            this._elementsWithExternalReferences || new Map());\n        for (let i = 0; i < elementsWithFuncIri.length; i++) {\n            funcIriAttributes.forEach(attr => {\n                const elementWithReference = elementsWithFuncIri[i];\n                const value = elementWithReference.getAttribute(attr);\n                const match = value ? value.match(funcIriPattern) : null;\n                if (match) {\n                    let attributes = elements.get(elementWithReference);\n                    if (!attributes) {\n                        attributes = [];\n                        elements.set(elementWithReference, attributes);\n                    }\n                    attributes.push({ name: attr, value: match[1] });\n                }\n            });\n        }\n    }\n    /** Sets a new SVG icon with a particular name. */\n    _updateSvgIcon(rawName) {\n        this._svgNamespace = null;\n        this._svgName = null;\n        this._currentIconFetch.unsubscribe();\n        if (rawName) {\n            const [namespace, iconName] = this._splitIconName(rawName);\n            if (namespace) {\n                this._svgNamespace = namespace;\n            }\n            if (iconName) {\n                this._svgName = iconName;\n            }\n            this._currentIconFetch = this._iconRegistry\n                .getNamedSvgIcon(iconName, namespace)\n                .pipe(take(1))\n                .subscribe(svg => this._setSvgElement(svg), (err) => {\n                const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;\n                this._errorHandler.handleError(new Error(errorMessage));\n            });\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIcon, deps: [], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"16.1.0\", version: \"20.0.0\", type: MatIcon, isStandalone: true, selector: \"mat-icon\", inputs: { color: \"color\", inline: [\"inline\", \"inline\", booleanAttribute], svgIcon: \"svgIcon\", fontSet: \"fontSet\", fontIcon: \"fontIcon\" }, host: { attributes: { \"role\": \"img\" }, properties: { \"class\": \"color ? \\\"mat-\\\" + color : \\\"\\\"\", \"attr.data-mat-icon-type\": \"_usingFontIcon() ? \\\"font\\\" : \\\"svg\\\"\", \"attr.data-mat-icon-name\": \"_svgName || fontIcon\", \"attr.data-mat-icon-namespace\": \"_svgNamespace || fontSet\", \"attr.fontIcon\": \"_usingFontIcon() ? fontIcon : null\", \"class.mat-icon-inline\": \"inline\", \"class.mat-icon-no-color\": \"color !== \\\"primary\\\" && color !== \\\"accent\\\" && color !== \\\"warn\\\"\" }, classAttribute: \"mat-icon notranslate\" }, exportAs: [\"matIcon\"], ngImport: i0, template: '<ng-content></ng-content>', isInline: true, styles: [\"mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIcon, decorators: [{\n            type: Component,\n            args: [{ template: '<ng-content></ng-content>', selector: 'mat-icon', exportAs: 'matIcon', host: {\n                        'role': 'img',\n                        'class': 'mat-icon notranslate',\n                        '[class]': 'color ? \"mat-\" + color : \"\"',\n                        '[attr.data-mat-icon-type]': '_usingFontIcon() ? \"font\" : \"svg\"',\n                        '[attr.data-mat-icon-name]': '_svgName || fontIcon',\n                        '[attr.data-mat-icon-namespace]': '_svgNamespace || fontSet',\n                        '[attr.fontIcon]': '_usingFontIcon() ? fontIcon : null',\n                        '[class.mat-icon-inline]': 'inline',\n                        '[class.mat-icon-no-color]': 'color !== \"primary\" && color !== \"accent\" && color !== \"warn\"',\n                    }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, styles: [\"mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"] }]\n        }], ctorParameters: () => [], propDecorators: { color: [{\n                type: Input\n            }], inline: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], svgIcon: [{\n                type: Input\n            }], fontSet: [{\n                type: Input\n            }], fontIcon: [{\n                type: Input\n            }] } });\n\nclass MatIconModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconModule, imports: [MatCommonModule, MatIcon], exports: [MatIcon, MatCommonModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconModule, imports: [MatCommonModule, MatCommonModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule, MatIcon],\n                    exports: [MatIcon, MatCommonModule],\n                }]\n        }] });\n\nexport { MAT_ICON_DEFAULT_OPTIONS, MAT_ICON_LOCATION, MAT_ICON_LOCATION_FACTORY, MatIcon, MatIconModule, MatIconRegistry };\n\n"],"mappings":"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","names":["map","value","base","headers","params","HttpEventType","HttpStatusCode","req","signal","HttpFeatureKind","httpResource","request","elem","HydrationFeatureKind"],"x_google_ignoreList":[0,1,2,3,4]}