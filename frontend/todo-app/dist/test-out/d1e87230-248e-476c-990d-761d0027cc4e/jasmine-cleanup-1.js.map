{"version":3,"sources":["node_modules/zone.js/fesm2015/zone-testing.js"],"sourcesContent":["'use strict';\n/**\n * @license Angular v<unknown>\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\nfunction patchJasmine(Zone) {\n    Zone.__load_patch('jasmine', (global, Zone, api) => {\n        const __extends = function (d, b) {\n            for (const p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p];\n            function __() {\n                this.constructor = d;\n            }\n            d.prototype =\n                b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n        };\n        // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n        // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n        if (!Zone)\n            throw new Error('Missing: zone.js');\n        if (typeof jest !== 'undefined') {\n            // return if jasmine is a light implementation inside jest\n            // in this case, we are running inside jest not jasmine\n            return;\n        }\n        if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n            return;\n        }\n        jasmine['__zone_patch__'] = true;\n        const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!SyncTestZoneSpec)\n            throw new Error('Missing: SyncTestZoneSpec');\n        if (!ProxyZoneSpec)\n            throw new Error('Missing: ProxyZoneSpec');\n        const ambientZone = Zone.current;\n        const symbol = Zone.__symbol__;\n        // whether patch jasmine clock when in fakeAsync\n        const disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n        // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n        // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we\n        // also automatically disable the auto jump into fakeAsync feature\n        const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n            (global[symbol('fakeAsyncPatchLock')] === true ||\n                global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n        const ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n        if (!ignoreUnhandledRejection) {\n            const globalErrors = jasmine.GlobalErrors;\n            if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n                jasmine[symbol('GlobalErrors')] = globalErrors;\n                jasmine.GlobalErrors = function () {\n                    const instance = new globalErrors();\n                    const originalInstall = instance.install;\n                    if (originalInstall && !instance[symbol('install')]) {\n                        instance[symbol('install')] = originalInstall;\n                        instance.install = function () {\n                            const isNode = typeof process !== 'undefined' && !!process.on;\n                            // Note: Jasmine checks internally if `process` and `process.on` is defined.\n                            // Otherwise, it installs the browser rejection handler through the\n                            // `global.addEventListener`. This code may be run in the browser environment where\n                            // `process` is not defined, and this will lead to a runtime exception since webpack 5\n                            // removed automatic Node.js polyfills. Note, that events are named differently, it's\n                            // `unhandledRejection` in Node.js and `unhandledrejection` in the browser.\n                            const originalHandlers = isNode\n                                ? process.listeners('unhandledRejection')\n                                : global.eventListeners('unhandledrejection');\n                            const result = originalInstall.apply(this, arguments);\n                            isNode\n                                ? process.removeAllListeners('unhandledRejection')\n                                : global.removeAllListeners('unhandledrejection');\n                            if (originalHandlers) {\n                                originalHandlers.forEach((handler) => {\n                                    if (isNode) {\n                                        process.on('unhandledRejection', handler);\n                                    }\n                                    else {\n                                        global.addEventListener('unhandledrejection', handler);\n                                    }\n                                });\n                            }\n                            return result;\n                        };\n                    }\n                    return instance;\n                };\n            }\n        }\n        // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n        const jasmineEnv = jasmine.getEnv();\n        ['describe', 'xdescribe', 'fdescribe'].forEach((methodName) => {\n            let originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[methodName] = function (description, specDefinitions) {\n                return originalJasmineFn.call(this, description, wrapDescribeInZone(description, specDefinitions));\n            };\n        });\n        ['it', 'xit', 'fit'].forEach((methodName) => {\n            let originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n                arguments[1] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach((methodName) => {\n            let originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (specDefinitions, timeout) {\n                arguments[0] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        if (!disablePatchingJasmineClock) {\n            // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n            // they can work properly in FakeAsyncTest\n            const originalClockFn = (jasmine[symbol('clock')] = jasmine['clock']);\n            jasmine['clock'] = function () {\n                const clock = originalClockFn.apply(this, arguments);\n                if (!clock[symbol('patched')]) {\n                    clock[symbol('patched')] = symbol('patched');\n                    const originalTick = (clock[symbol('tick')] = clock.tick);\n                    clock.tick = function () {\n                        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                        }\n                        return originalTick.apply(this, arguments);\n                    };\n                    const originalMockDate = (clock[symbol('mockDate')] = clock.mockDate);\n                    clock.mockDate = function () {\n                        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            const dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function'\n                                ? [dateTime.getTime()]\n                                : arguments);\n                        }\n                        return originalMockDate.apply(this, arguments);\n                    };\n                    // for auto go into fakeAsync feature, we need the flag to enable it\n                    if (enableAutoFakeAsyncWhenClockPatched) {\n                        ['install', 'uninstall'].forEach((methodName) => {\n                            const originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                            clock[methodName] = function () {\n                                const FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                                if (FakeAsyncTestZoneSpec) {\n                                    jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                    return;\n                                }\n                                return originalClockFn.apply(this, arguments);\n                            };\n                        });\n                    }\n                }\n                return clock;\n            };\n        }\n        // monkey patch createSpyObj to make properties enumerable to true\n        if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n            const originalCreateSpyObj = jasmine.createSpyObj;\n            jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n            jasmine.createSpyObj = function () {\n                const args = Array.prototype.slice.call(arguments);\n                const propertyNames = args.length >= 3 ? args[2] : null;\n                let spyObj;\n                if (propertyNames) {\n                    const defineProperty = Object.defineProperty;\n                    Object.defineProperty = function (obj, p, attributes) {\n                        return defineProperty.call(this, obj, p, {\n                            ...attributes,\n                            configurable: true,\n                            enumerable: true,\n                        });\n                    };\n                    try {\n                        spyObj = originalCreateSpyObj.apply(this, args);\n                    }\n                    finally {\n                        Object.defineProperty = defineProperty;\n                    }\n                }\n                else {\n                    spyObj = originalCreateSpyObj.apply(this, args);\n                }\n                return spyObj;\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(description, describeBody) {\n            return function () {\n                // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n                // error if any asynchronous operations are attempted inside of a `describe`.\n                const syncZone = ambientZone.fork(new SyncTestZoneSpec(`jasmine.describe#${description}`));\n                return syncZone.run(describeBody, this, arguments);\n            };\n        }\n        function runInTestZone(testBody, applyThis, queueRunner, done) {\n            const isClockInstalled = !!jasmine[symbol('clockInstalled')];\n            queueRunner.testProxyZoneSpec;\n            const testProxyZone = queueRunner.testProxyZone;\n            if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n                // auto run a fakeAsync\n                const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            if (done) {\n                return testProxyZone.run(testBody, applyThis, [done]);\n            }\n            else {\n                return testProxyZone.run(testBody, applyThis);\n            }\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n         */\n        function wrapTestInZone(testBody) {\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jasmine will\n            // think that all functions are sync or async.\n            return (testBody &&\n                (testBody.length\n                    ? function (done) {\n                        return runInTestZone(testBody, this, this.queueRunner, done);\n                    }\n                    : function () {\n                        return runInTestZone(testBody, this, this.queueRunner);\n                    }));\n        }\n        const QueueRunner = jasmine.QueueRunner;\n        jasmine.QueueRunner = (function (_super) {\n            __extends(ZoneQueueRunner, _super);\n            function ZoneQueueRunner(attrs) {\n                if (attrs.onComplete) {\n                    attrs.onComplete = ((fn) => () => {\n                        // All functions are done, clear the test zone.\n                        this.testProxyZone = null;\n                        this.testProxyZoneSpec = null;\n                        ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                    })(attrs.onComplete);\n                }\n                const nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n                const nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n                if (nativeSetTimeout) {\n                    // should run setTimeout inside jasmine outside of zone\n                    attrs.timeout = {\n                        setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                        clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout,\n                    };\n                }\n                // create a userContext to hold the queueRunner itself\n                // so we can access the testProxy in it/xit/beforeEach ...\n                if (jasmine.UserContext) {\n                    if (!attrs.userContext) {\n                        attrs.userContext = new jasmine.UserContext();\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                else {\n                    if (!attrs.userContext) {\n                        attrs.userContext = {};\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                // patch attrs.onException\n                const onException = attrs.onException;\n                attrs.onException = function (error) {\n                    if (error &&\n                        error.message ===\n                            'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                        // jasmine timeout, we can make the error message more\n                        // reasonable to tell what tasks are pending\n                        const proxyZoneSpec = this && this.testProxyZoneSpec;\n                        if (proxyZoneSpec) {\n                            const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                            try {\n                                // try catch here in case error.message is not writable\n                                error.message += pendingTasksInfo;\n                            }\n                            catch (err) { }\n                        }\n                    }\n                    if (onException) {\n                        onException.call(this, error);\n                    }\n                };\n                _super.call(this, attrs);\n            }\n            ZoneQueueRunner.prototype.execute = function () {\n                let zone = Zone.current;\n                let isChildOfAmbientZone = false;\n                while (zone) {\n                    if (zone === ambientZone) {\n                        isChildOfAmbientZone = true;\n                        break;\n                    }\n                    zone = zone.parent;\n                }\n                if (!isChildOfAmbientZone)\n                    throw new Error('Unexpected Zone: ' + Zone.current.name);\n                // This is the zone which will be used for running individual tests.\n                // It will be a proxy zone, so that the tests function can retroactively install\n                // different zones.\n                // Example:\n                //   - In beforeEach() do childZone = Zone.current.fork(...);\n                //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n                //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n                //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n                //     fakeAsync behavior to the childZone.\n                this.testProxyZoneSpec = new ProxyZoneSpec();\n                this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n                if (!Zone.currentTask) {\n                    // if we are not running in a task then if someone would register a\n                    // element.addEventListener and then calling element.click() the\n                    // addEventListener callback would think that it is the top most task and would\n                    // drain the microtask queue on element.click() which would be incorrect.\n                    // For this reason we always force a task when running jasmine tests.\n                    Zone.current.scheduleMicroTask('jasmine.execute().forceTask', () => QueueRunner.prototype.execute.call(this));\n                }\n                else {\n                    _super.prototype.execute.call(this);\n                }\n            };\n            return ZoneQueueRunner;\n        })(QueueRunner);\n    });\n}\n\nfunction patchJest(Zone) {\n    Zone.__load_patch('jest', (context, Zone, api) => {\n        if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n            return;\n        }\n        // From jest 29 and jest-preset-angular v13, the module transform logic\n        // changed, and now jest-preset-angular use the use the tsconfig target\n        // other than the hardcoded one, https://github.com/thymikee/jest-preset-angular/issues/2010\n        // But jest-angular-preset doesn't introduce the @babel/plugin-transform-async-to-generator\n        // which is needed by angular since `async/await` still need to be transformed\n        // to promise for ES2017+ target.\n        // So for now, we disable to output the uncaught error console log for a temp solution,\n        // until jest-preset-angular find a proper solution.\n        Zone[api.symbol('ignoreConsoleErrorUncaughtError')] = true;\n        jest['__zone_patch__'] = true;\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        const rootZone = Zone.current;\n        const syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n        const proxyZoneSpec = new ProxyZoneSpec();\n        const proxyZone = rootZone.fork(proxyZoneSpec);\n        function wrapDescribeFactoryInZone(originalJestFn) {\n            return function (...tableArgs) {\n                const originalDescribeFn = originalJestFn.apply(this, tableArgs);\n                return function (...args) {\n                    args[1] = wrapDescribeInZone(args[1]);\n                    return originalDescribeFn.apply(this, args);\n                };\n            };\n        }\n        function wrapTestFactoryInZone(originalJestFn) {\n            return function (...tableArgs) {\n                return function (...args) {\n                    args[1] = wrapTestInZone(args[1]);\n                    return originalJestFn.apply(this, tableArgs).apply(this, args);\n                };\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function (...args) {\n                return syncZone.run(describeBody, this, args);\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in the `proxyZone`.\n         */\n        function wrapTestInZone(testBody, isTestFunc = false) {\n            if (typeof testBody !== 'function') {\n                return testBody;\n            }\n            const wrappedFunc = function () {\n                if (Zone[api.symbol('useFakeTimersCalled')] === true &&\n                    testBody &&\n                    !testBody.isFakeAsync) {\n                    // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n                    const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                    if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                        testBody = fakeAsyncModule.fakeAsync(testBody);\n                    }\n                }\n                proxyZoneSpec.isTestFunc = isTestFunc;\n                return proxyZone.run(testBody, null, arguments);\n            };\n            // Update the length of wrappedFunc to be the same as the length of the testBody\n            // So jest core can handle whether the test function has `done()` or not correctly\n            Object.defineProperty(wrappedFunc, 'length', {\n                configurable: true,\n                writable: true,\n                enumerable: false,\n            });\n            wrappedFunc.length = testBody.length;\n            return wrappedFunc;\n        }\n        ['describe', 'xdescribe', 'fdescribe'].forEach((methodName) => {\n            let originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function (...args) {\n                args[1] = wrapDescribeInZone(args[1]);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n        });\n        context.describe.only = context.fdescribe;\n        context.describe.skip = context.xdescribe;\n        ['it', 'xit', 'fit', 'test', 'xtest'].forEach((methodName) => {\n            let originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function (...args) {\n                args[1] = wrapTestInZone(args[1], true);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n            context[methodName].todo = originalJestFn.todo;\n            context[methodName].failing = originalJestFn.failing;\n        });\n        context.it.only = context.fit;\n        context.it.skip = context.xit;\n        context.test.only = context.fit;\n        context.test.skip = context.xit;\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach((methodName) => {\n            let originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function (...args) {\n                args[0] = wrapTestInZone(args[0]);\n                return originalJestFn.apply(this, args);\n            };\n        });\n        Zone.patchJestObject = function patchJestObject(Timer, isModern = false) {\n            // check whether currently the test is inside fakeAsync()\n            function isPatchingFakeTimer() {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                return !!fakeAsyncZoneSpec;\n            }\n            // check whether the current function is inside `test/it` or other methods\n            // such as `describe/beforeEach`\n            function isInTestFunc() {\n                const proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n                return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n            }\n            if (Timer[api.symbol('fakeTimers')]) {\n                return;\n            }\n            Timer[api.symbol('fakeTimers')] = true;\n            // patch jest fakeTimer internal method to make sure no console.warn print out\n            api.patchMethod(Timer, '_checkFakeTimers', (delegate) => {\n                return function (self, args) {\n                    if (isPatchingFakeTimer()) {\n                        return true;\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n            api.patchMethod(Timer, 'useFakeTimers', (delegate) => {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = true;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch useRealTimers(), unset useFakeTimers flag\n            api.patchMethod(Timer, 'useRealTimers', (delegate) => {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = false;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'setSystemTime', (delegate) => {\n                return function (self, args) {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getRealSystemTime', (delegate) => {\n                return function (self, args) {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        return fakeAsyncZoneSpec.getRealSystemTime();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTicks(), run all microTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTicks', (delegate) => {\n                return function (self, args) {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushMicrotasks();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTimers(), run all macroTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTimers', (delegate) => {\n                return function (self, args) {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flush(100, true);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersByTime', (delegate) => {\n                return function (self, args) {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tick(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'runOnlyPendingTimers', (delegate) => {\n                return function (self, args) {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushOnlyPendingTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersToNextTimer', (delegate) => {\n                return function (self, args) {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tickToNext(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'clearAllTimers', (delegate) => {\n                return function (self, args) {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.removeAllTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getTimerCount', (delegate) => {\n                return function (self, args) {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        return fakeAsyncZoneSpec.getTimerCount();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n        };\n    });\n}\n\nfunction patchMocha(Zone) {\n    Zone.__load_patch('mocha', (global, Zone) => {\n        const Mocha = global.Mocha;\n        if (typeof Mocha === 'undefined') {\n            // return if Mocha is not available, because now zone-testing\n            // will load mocha patch with jasmine/jest patch\n            return;\n        }\n        if (typeof Zone === 'undefined') {\n            throw new Error('Missing Zone.js');\n        }\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        if (Mocha['__zone_patch__']) {\n            throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n        }\n        Mocha['__zone_patch__'] = true;\n        const rootZone = Zone.current;\n        const syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n        let testZone = null;\n        const suiteZone = rootZone.fork(new ProxyZoneSpec());\n        const mochaOriginal = {\n            after: global.after,\n            afterEach: global.afterEach,\n            before: global.before,\n            beforeEach: global.beforeEach,\n            describe: global.describe,\n            it: global.it,\n        };\n        function modifyArguments(args, syncTest, asyncTest) {\n            for (let i = 0; i < args.length; i++) {\n                let arg = args[i];\n                if (typeof arg === 'function') {\n                    // The `done` callback is only passed through if the function expects at\n                    // least one argument.\n                    // Note we have to make a function with correct number of arguments,\n                    // otherwise mocha will\n                    // think that all functions are sync or async.\n                    args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg);\n                    // Mocha uses toString to view the test body in the result list, make sure we return the\n                    // correct function body\n                    args[i].toString = function () {\n                        return arg.toString();\n                    };\n                }\n            }\n            return args;\n        }\n        function wrapDescribeInZone(args) {\n            const syncTest = function (fn) {\n                return function () {\n                    return syncZone.run(fn, this, arguments);\n                };\n            };\n            return modifyArguments(args, syncTest);\n        }\n        function wrapTestInZone(args) {\n            const asyncTest = function (fn) {\n                return function (done) {\n                    return testZone.run(fn, this, [done]);\n                };\n            };\n            const syncTest = function (fn) {\n                return function () {\n                    return testZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        function wrapSuiteInZone(args) {\n            const asyncTest = function (fn) {\n                return function (done) {\n                    return suiteZone.run(fn, this, [done]);\n                };\n            };\n            const syncTest = function (fn) {\n                return function () {\n                    return suiteZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        global.describe = global.suite = function () {\n            return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.xdescribe =\n            global.suite.skip =\n                global.describe.skip =\n                    function () {\n                        return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n                    };\n        global.describe.only = global.suite.only = function () {\n            return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.it =\n            global.specify =\n                global.test =\n                    function () {\n                        return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n                    };\n        global.xit =\n            global.xspecify =\n                global.it.skip =\n                    function () {\n                        return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n                    };\n        global.it.only = global.test.only = function () {\n            return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n        };\n        global.after = global.suiteTeardown = function () {\n            return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.afterEach = global.teardown = function () {\n            return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n        };\n        global.before = global.suiteSetup = function () {\n            return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.beforeEach = global.setup = function () {\n            return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n        };\n        ((originalRunTest, originalRun) => {\n            Mocha.Runner.prototype.runTest = function (fn) {\n                Zone.current.scheduleMicroTask('mocha.forceTask', () => {\n                    originalRunTest.call(this, fn);\n                });\n            };\n            Mocha.Runner.prototype.run = function (fn) {\n                this.on('test', (e) => {\n                    testZone = rootZone.fork(new ProxyZoneSpec());\n                });\n                this.on('fail', (test, err) => {\n                    const proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n                    if (proxyZoneSpec && err) {\n                        try {\n                            // try catch here in case err.message is not writable\n                            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n                        }\n                        catch (error) { }\n                    }\n                });\n                return originalRun.call(this, fn);\n            };\n        })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n    });\n}\n\nconst global$2 = globalThis;\n// __Zone_symbol_prefix global can be used to override the default zone\n// symbol prefix with a custom one if needed.\nfunction __symbol__(name) {\n    const symbolPrefix = global$2['__Zone_symbol_prefix'] || '__zone_symbol__';\n    return symbolPrefix + name;\n}\n\nconst __global = (typeof window !== 'undefined' && window) || (typeof self !== 'undefined' && self) || global;\nclass AsyncTestZoneSpec {\n    finishCallback;\n    failCallback;\n    // Needs to be a getter and not a plain property in order run this just-in-time. Otherwise\n    // `__symbol__` would be evaluated during top-level execution prior to the Zone prefix being\n    // changed for tests.\n    static get symbolParentUnresolved() {\n        return __symbol__('parentUnresolved');\n    }\n    _pendingMicroTasks = false;\n    _pendingMacroTasks = false;\n    _alreadyErrored = false;\n    _isSync = false;\n    _existingFinishTimer = null;\n    entryFunction = null;\n    runZone = Zone.current;\n    unresolvedChainedPromiseCount = 0;\n    supportWaitUnresolvedChainedPromise = false;\n    constructor(finishCallback, failCallback, namePrefix) {\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = { 'AsyncTestZoneSpec': this };\n        this.supportWaitUnresolvedChainedPromise =\n            __global[__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n    }\n    isUnresolvedChainedPromisePending() {\n        return this.unresolvedChainedPromiseCount > 0;\n    }\n    _finishCallbackIfDone() {\n        // NOTE: Technically the `onHasTask` could fire together with the initial synchronous\n        // completion in `onInvoke`. `onHasTask` might call this method when it captured e.g.\n        // microtasks in the proxy zone that now complete as part of this async zone run.\n        // Consider the following scenario:\n        //    1. A test `beforeEach` schedules a microtask in the ProxyZone.\n        //    2. An actual empty `it` spec executes in the AsyncTestZone` (using e.g. `waitForAsync`).\n        //    3. The `onInvoke` invokes `_finishCallbackIfDone` because the spec runs synchronously.\n        //    4. We wait the scheduled timeout (see below) to account for unhandled promises.\n        //    5. The microtask from (1) finishes and `onHasTask` is invoked.\n        //    --> We register a second `_finishCallbackIfDone` even though we have scheduled a timeout.\n        // If the finish timeout from below is already scheduled, terminate the existing scheduled\n        // finish invocation, avoiding calling `jasmine` `done` multiple times. *Note* that we would\n        // want to schedule a new finish callback in case the task state changes again.\n        if (this._existingFinishTimer !== null) {\n            clearTimeout(this._existingFinishTimer);\n            this._existingFinishTimer = null;\n        }\n        if (!(this._pendingMicroTasks ||\n            this._pendingMacroTasks ||\n            (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n            // We wait until the next tick because we would like to catch unhandled promises which could\n            // cause test logic to be executed. In such cases we cannot finish with tasks pending then.\n            this.runZone.run(() => {\n                this._existingFinishTimer = setTimeout(() => {\n                    if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {\n                        this.finishCallback();\n                    }\n                }, 0);\n            });\n        }\n    }\n    patchPromiseForTest() {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n            return;\n        }\n        const patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n        if (patchPromiseForTest) {\n            patchPromiseForTest();\n        }\n    }\n    unPatchPromiseForTest() {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n            return;\n        }\n        const unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n        if (unPatchPromiseForTest) {\n            unPatchPromiseForTest();\n        }\n    }\n    // ZoneSpec implementation below.\n    name;\n    properties;\n    onScheduleTask(delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n            this._isSync = false;\n        }\n        if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n            // check whether the promise is a chained promise\n            if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                // chained promise is being scheduled\n                this.unresolvedChainedPromiseCount--;\n            }\n        }\n        return delegate.scheduleTask(target, task);\n    }\n    onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n            this._isSync = false;\n        }\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n    }\n    onCancelTask(delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n            this._isSync = false;\n        }\n        return delegate.cancelTask(target, task);\n    }\n    // Note - we need to use onInvoke at the moment to call finish when a test is\n    // fully synchronous. TODO(juliemr): remove this when the logic for\n    // onHasTask changes and it calls whenever the task queues are dirty.\n    // updated by(JiaLiPassion), only call finish callback when no task\n    // was scheduled/invoked/canceled.\n    onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        if (!this.entryFunction) {\n            this.entryFunction = delegate;\n        }\n        try {\n            this._isSync = true;\n            return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        }\n        finally {\n            // We need to check the delegate is the same as entryFunction or not.\n            // Consider the following case.\n            //\n            // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n            //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n            //   });\n            // });\n            //\n            // We only want to check whether there are async tasks scheduled\n            // for the entry function.\n            if (this._isSync && this.entryFunction === delegate) {\n                this._finishCallbackIfDone();\n            }\n        }\n    }\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n        // Let the parent try to handle the error.\n        const result = parentZoneDelegate.handleError(targetZone, error);\n        if (result) {\n            this.failCallback(error);\n            this._alreadyErrored = true;\n        }\n        return false;\n    }\n    onHasTask(delegate, current, target, hasTaskState) {\n        delegate.hasTask(target, hasTaskState);\n        // We should only trigger finishCallback when the target zone is the AsyncTestZone\n        // Consider the following cases.\n        //\n        // const childZone = asyncTestZone.fork({\n        //   name: 'child',\n        //   onHasTask: ...\n        // });\n        //\n        // So we have nested zones declared the onHasTask hook, in this case,\n        // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n        // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n        // when the current zone is the same as the target zone.\n        if (current !== target) {\n            return;\n        }\n        if (hasTaskState.change == 'microTask') {\n            this._pendingMicroTasks = hasTaskState.microTask;\n            this._finishCallbackIfDone();\n        }\n        else if (hasTaskState.change == 'macroTask') {\n            this._pendingMacroTasks = hasTaskState.macroTask;\n            this._finishCallbackIfDone();\n        }\n    }\n}\nfunction patchAsyncTest(Zone) {\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n    Zone.__load_patch('asynctest', (global, Zone, api) => {\n        /**\n         * Wraps a test function in an asynchronous test zone. The test will automatically\n         * complete when all asynchronous calls within this zone are done.\n         */\n        Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n            // If we're running using the Jasmine test framework, adapt to call the 'done'\n            // function when asynchronous activity is finished.\n            if (global.jasmine) {\n                // Not using an arrow function to preserve context passed from call site\n                return function (done) {\n                    if (!done) {\n                        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                        // fake it here and assume sync.\n                        done = function () { };\n                        done.fail = function (e) {\n                            throw e;\n                        };\n                    }\n                    runInTestZone(fn, this, done, (err) => {\n                        if (typeof err === 'string') {\n                            return done.fail(new Error(err));\n                        }\n                        else {\n                            done.fail(err);\n                        }\n                    });\n                };\n            }\n            // Otherwise, return a promise which will resolve when asynchronous activity\n            // is finished. This will be correctly consumed by the Mocha framework with\n            // it('...', async(myFn)); or can be used in a custom framework.\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                return new Promise((finishCallback, failCallback) => {\n                    runInTestZone(fn, this, finishCallback, failCallback);\n                });\n            };\n        };\n        function runInTestZone(fn, context, finishCallback, failCallback) {\n            const currentZone = Zone.current;\n            const AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n            if (AsyncTestZoneSpec === undefined) {\n                throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/async-test');\n            }\n            const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n            if (!ProxyZoneSpec) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/proxy');\n            }\n            const proxyZoneSpec = ProxyZoneSpec.get();\n            ProxyZoneSpec.assertPresent();\n            // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n            // If we do it in ProxyZone then we will get to infinite recursion.\n            const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n            const previousDelegate = proxyZoneSpec.getDelegate();\n            proxyZone.parent.run(() => {\n                const testZoneSpec = new AsyncTestZoneSpec(() => {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's\n                        // still this one. Otherwise, assume\n                        // it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(() => {\n                        finishCallback();\n                    });\n                }, (error) => {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(() => {\n                        failCallback(error);\n                    });\n                }, 'test');\n                proxyZoneSpec.setDelegate(testZoneSpec);\n                testZoneSpec.patchPromiseForTest();\n            });\n            return Zone.current.runGuarded(fn, context);\n        }\n    });\n}\n\nconst global$1 = (typeof window === 'object' && window) || (typeof self === 'object' && self) || globalThis.global;\nconst OriginalDate = global$1.Date;\n// Since when we compile this file to `es2015`, and if we define\n// this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n// there will be an error which is `Cannot assign to read only property 'prototype'`\n// so we need to use function implementation here.\nfunction FakeDate() {\n    if (arguments.length === 0) {\n        const d = new OriginalDate();\n        d.setTime(FakeDate.now());\n        return d;\n    }\n    else {\n        const args = Array.prototype.slice.call(arguments);\n        return new OriginalDate(...args);\n    }\n}\nFakeDate.now = function () {\n    const fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n    if (fakeAsyncTestZoneSpec) {\n        return fakeAsyncTestZoneSpec.getFakeSystemTime();\n    }\n    return OriginalDate.now.apply(this, arguments);\n};\nFakeDate.UTC = OriginalDate.UTC;\nFakeDate.parse = OriginalDate.parse;\n// keep a reference for zone patched timer function\nlet patchedTimers;\nconst timeoutCallback = function () { };\nclass Scheduler {\n    // Next scheduler id.\n    static nextNodeJSId = 1;\n    static nextId = -1;\n    // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n    _schedulerQueue = [];\n    // Current simulated time in millis.\n    _currentTickTime = 0;\n    // Current fake system base time in millis.\n    _currentFakeBaseSystemTime = OriginalDate.now();\n    // track requeuePeriodicTimer\n    _currentTickRequeuePeriodicEntries = [];\n    constructor() { }\n    static getNextId() {\n        const id = patchedTimers.nativeSetTimeout.call(global$1, timeoutCallback, 0);\n        patchedTimers.nativeClearTimeout.call(global$1, id);\n        if (typeof id === 'number') {\n            return id;\n        }\n        // in NodeJS, we just use a number for fakeAsync, since it will not\n        // conflict with native TimeoutId\n        return Scheduler.nextNodeJSId++;\n    }\n    getCurrentTickTime() {\n        return this._currentTickTime;\n    }\n    getFakeSystemTime() {\n        return this._currentFakeBaseSystemTime + this._currentTickTime;\n    }\n    setFakeBaseSystemTime(fakeBaseSystemTime) {\n        this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n    }\n    getRealSystemTime() {\n        return OriginalDate.now();\n    }\n    scheduleFunction(cb, delay, options) {\n        options = {\n            ...{\n                args: [],\n                isPeriodic: false,\n                isRequestAnimationFrame: false,\n                id: -1,\n                isRequeuePeriodic: false,\n            },\n            ...options,\n        };\n        let currentId = options.id < 0 ? Scheduler.nextId : options.id;\n        Scheduler.nextId = Scheduler.getNextId();\n        let endTime = this._currentTickTime + delay;\n        // Insert so that scheduler queue remains sorted by end time.\n        let newEntry = {\n            endTime: endTime,\n            id: currentId,\n            func: cb,\n            args: options.args,\n            delay: delay,\n            isPeriodic: options.isPeriodic,\n            isRequestAnimationFrame: options.isRequestAnimationFrame,\n        };\n        if (options.isRequeuePeriodic) {\n            this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n        let i = 0;\n        for (; i < this._schedulerQueue.length; i++) {\n            let currentEntry = this._schedulerQueue[i];\n            if (newEntry.endTime < currentEntry.endTime) {\n                break;\n            }\n        }\n        this._schedulerQueue.splice(i, 0, newEntry);\n        return currentId;\n    }\n    removeScheduledFunctionWithId(id) {\n        for (let i = 0; i < this._schedulerQueue.length; i++) {\n            if (this._schedulerQueue[i].id == id) {\n                this._schedulerQueue.splice(i, 1);\n                break;\n            }\n        }\n    }\n    removeAll() {\n        this._schedulerQueue = [];\n    }\n    getTimerCount() {\n        return this._schedulerQueue.length;\n    }\n    tickToNext(step = 1, doTick, tickOptions) {\n        if (this._schedulerQueue.length < step) {\n            return;\n        }\n        // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n        const startTime = this._currentTickTime;\n        const targetTask = this._schedulerQueue[step - 1];\n        this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n    }\n    tick(millis = 0, doTick, tickOptions) {\n        let finalTime = this._currentTickTime + millis;\n        let lastCurrentTime = 0;\n        tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n        // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n        const schedulerQueue = tickOptions.processNewMacroTasksSynchronously\n            ? this._schedulerQueue\n            : this._schedulerQueue.slice();\n        if (schedulerQueue.length === 0 && doTick) {\n            doTick(millis);\n            return;\n        }\n        while (schedulerQueue.length > 0) {\n            // clear requeueEntries before each loop\n            this._currentTickRequeuePeriodicEntries = [];\n            let current = schedulerQueue[0];\n            if (finalTime < current.endTime) {\n                // Done processing the queue since it's sorted by endTime.\n                break;\n            }\n            else {\n                // Time to run scheduled function. Remove it from the head of queue.\n                let current = schedulerQueue.shift();\n                if (!tickOptions.processNewMacroTasksSynchronously) {\n                    const idx = this._schedulerQueue.indexOf(current);\n                    if (idx >= 0) {\n                        this._schedulerQueue.splice(idx, 1);\n                    }\n                }\n                lastCurrentTime = this._currentTickTime;\n                this._currentTickTime = current.endTime;\n                if (doTick) {\n                    doTick(this._currentTickTime - lastCurrentTime);\n                }\n                let retval = current.func.apply(global$1, current.isRequestAnimationFrame ? [this._currentTickTime] : current.args);\n                if (!retval) {\n                    // Uncaught exception in the current scheduled function. Stop processing the queue.\n                    break;\n                }\n                // check is there any requeue periodic entry is added in\n                // current loop, if there is, we need to add to current loop\n                if (!tickOptions.processNewMacroTasksSynchronously) {\n                    this._currentTickRequeuePeriodicEntries.forEach((newEntry) => {\n                        let i = 0;\n                        for (; i < schedulerQueue.length; i++) {\n                            const currentEntry = schedulerQueue[i];\n                            if (newEntry.endTime < currentEntry.endTime) {\n                                break;\n                            }\n                        }\n                        schedulerQueue.splice(i, 0, newEntry);\n                    });\n                }\n            }\n        }\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = finalTime;\n        if (doTick) {\n            doTick(this._currentTickTime - lastCurrentTime);\n        }\n    }\n    flushOnlyPendingTimers(doTick) {\n        if (this._schedulerQueue.length === 0) {\n            return 0;\n        }\n        // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n        const startTime = this._currentTickTime;\n        const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });\n        return this._currentTickTime - startTime;\n    }\n    flush(limit = 20, flushPeriodic = false, doTick) {\n        if (flushPeriodic) {\n            return this.flushPeriodic(doTick);\n        }\n        else {\n            return this.flushNonPeriodic(limit, doTick);\n        }\n    }\n    flushPeriodic(doTick) {\n        if (this._schedulerQueue.length === 0) {\n            return 0;\n        }\n        // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n        const startTime = this._currentTickTime;\n        const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTickTime - startTime;\n    }\n    flushNonPeriodic(limit, doTick) {\n        const startTime = this._currentTickTime;\n        let lastCurrentTime = 0;\n        let count = 0;\n        while (this._schedulerQueue.length > 0) {\n            count++;\n            if (count > limit) {\n                throw new Error('flush failed after reaching the limit of ' +\n                    limit +\n                    ' tasks. Does your code use a polling timeout?');\n            }\n            // flush only non-periodic timers.\n            // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n            if (this._schedulerQueue.filter((task) => !task.isPeriodic && !task.isRequestAnimationFrame)\n                .length === 0) {\n                break;\n            }\n            const current = this._schedulerQueue.shift();\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = current.endTime;\n            if (doTick) {\n                // Update any secondary schedulers like Jasmine mock Date.\n                doTick(this._currentTickTime - lastCurrentTime);\n            }\n            const retval = current.func.apply(global$1, current.args);\n            if (!retval) {\n                // Uncaught exception in the current scheduled function. Stop processing the queue.\n                break;\n            }\n        }\n        return this._currentTickTime - startTime;\n    }\n}\nclass FakeAsyncTestZoneSpec {\n    trackPendingRequestAnimationFrame;\n    macroTaskOptions;\n    static assertInZone() {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n            throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n    }\n    _scheduler = new Scheduler();\n    _microtasks = [];\n    _lastError = null;\n    _uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n    pendingPeriodicTimers = [];\n    pendingTimers = [];\n    patchDateLocked = false;\n    constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this.name = 'fakeAsyncTestZone for ' + namePrefix;\n        // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n        if (!this.macroTaskOptions) {\n            this.macroTaskOptions = global$1[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n    }\n    _fnAndFlush(fn, completers) {\n        return (...args) => {\n            fn.apply(global$1, args);\n            if (this._lastError === null) {\n                // Success\n                if (completers.onSuccess != null) {\n                    completers.onSuccess.apply(global$1);\n                }\n                // Flush microtasks only on success.\n                this.flushMicrotasks();\n            }\n            else {\n                // Failure\n                if (completers.onError != null) {\n                    completers.onError.apply(global$1);\n                }\n            }\n            // Return true if there were no errors, false otherwise.\n            return this._lastError === null;\n        };\n    }\n    static _removeTimer(timers, id) {\n        let index = timers.indexOf(id);\n        if (index > -1) {\n            timers.splice(index, 1);\n        }\n    }\n    _dequeueTimer(id) {\n        return () => {\n            FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n        };\n    }\n    _requeuePeriodicTimer(fn, interval, args, id) {\n        return () => {\n            // Requeue the timer callback if it's not been canceled.\n            if (this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                this._scheduler.scheduleFunction(fn, interval, {\n                    args,\n                    isPeriodic: true,\n                    id,\n                    isRequeuePeriodic: true,\n                });\n            }\n        };\n    }\n    _dequeuePeriodicTimer(id) {\n        return () => {\n            FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n        };\n    }\n    _setTimeout(fn, delay, args, isTimer = true) {\n        let removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n        // Queue the callback and dequeue the timer on success and error.\n        let cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n        let id = this._scheduler.scheduleFunction(cb, delay, { args, isRequestAnimationFrame: !isTimer });\n        if (isTimer) {\n            this.pendingTimers.push(id);\n        }\n        return id;\n    }\n    _clearTimeout(id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n        this._scheduler.removeScheduledFunctionWithId(id);\n    }\n    _setInterval(fn, interval, args) {\n        let id = Scheduler.nextId;\n        let completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n        let cb = this._fnAndFlush(fn, completers);\n        // Use the callback created above to requeue on success.\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n        // Queue the callback and dequeue the periodic timer only on error.\n        this._scheduler.scheduleFunction(cb, interval, { args, isPeriodic: true });\n        this.pendingPeriodicTimers.push(id);\n        return id;\n    }\n    _clearInterval(id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n        this._scheduler.removeScheduledFunctionWithId(id);\n    }\n    _resetLastErrorAndThrow() {\n        let error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n    }\n    getCurrentTickTime() {\n        return this._scheduler.getCurrentTickTime();\n    }\n    getFakeSystemTime() {\n        return this._scheduler.getFakeSystemTime();\n    }\n    setFakeBaseSystemTime(realTime) {\n        this._scheduler.setFakeBaseSystemTime(realTime);\n    }\n    getRealSystemTime() {\n        return this._scheduler.getRealSystemTime();\n    }\n    static patchDate() {\n        if (!!global$1[Zone.__symbol__('disableDatePatching')]) {\n            // we don't want to patch global Date\n            // because in some case, global Date\n            // is already being patched, we need to provide\n            // an option to let user still use their\n            // own version of Date.\n            return;\n        }\n        if (global$1['Date'] === FakeDate) {\n            // already patched\n            return;\n        }\n        global$1['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype;\n        // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n    }\n    static resetDate() {\n        if (global$1['Date'] === FakeDate) {\n            global$1['Date'] = OriginalDate;\n        }\n    }\n    static checkTimerPatch() {\n        if (!patchedTimers) {\n            throw new Error('Expected timers to have been patched.');\n        }\n        if (global$1.setTimeout !== patchedTimers.setTimeout) {\n            global$1.setTimeout = patchedTimers.setTimeout;\n            global$1.clearTimeout = patchedTimers.clearTimeout;\n        }\n        if (global$1.setInterval !== patchedTimers.setInterval) {\n            global$1.setInterval = patchedTimers.setInterval;\n            global$1.clearInterval = patchedTimers.clearInterval;\n        }\n    }\n    lockDatePatch() {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n    }\n    unlockDatePatch() {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n    }\n    tickToNext(steps = 1, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {\n        if (steps <= 0) {\n            return;\n        }\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n        this._scheduler.tickToNext(steps, doTick, tickOptions);\n        if (this._lastError !== null) {\n            this._resetLastErrorAndThrow();\n        }\n    }\n    tick(millis = 0, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n        this._scheduler.tick(millis, doTick, tickOptions);\n        if (this._lastError !== null) {\n            this._resetLastErrorAndThrow();\n        }\n    }\n    flushMicrotasks() {\n        FakeAsyncTestZoneSpec.assertInZone();\n        const flushErrors = () => {\n            if (this._lastError !== null || this._uncaughtPromiseErrors.length) {\n                // If there is an error stop processing the microtask queue and rethrow the error.\n                this._resetLastErrorAndThrow();\n            }\n        };\n        while (this._microtasks.length > 0) {\n            let microtask = this._microtasks.shift();\n            microtask.func.apply(microtask.target, microtask.args);\n        }\n        flushErrors();\n    }\n    flush(limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n        const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n        if (this._lastError !== null) {\n            this._resetLastErrorAndThrow();\n        }\n        return elapsed;\n    }\n    flushOnlyPendingTimers(doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n        const elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n        if (this._lastError !== null) {\n            this._resetLastErrorAndThrow();\n        }\n        return elapsed;\n    }\n    removeAllTimers() {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this._scheduler.removeAll();\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n    }\n    getTimerCount() {\n        return this._scheduler.getTimerCount() + this._microtasks.length;\n    }\n    // ZoneSpec implementation below.\n    name;\n    properties = { 'FakeAsyncTestZoneSpec': this };\n    onScheduleTask(delegate, current, target, task) {\n        switch (task.type) {\n            case 'microTask':\n                let args = task.data && task.data.args;\n                // should pass additional arguments to callback if have any\n                // currently we know process.nextTick will have such additional\n                // arguments\n                let additionalArgs;\n                if (args) {\n                    let callbackIndex = task.data.cbIdx;\n                    if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                        additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                    }\n                }\n                this._microtasks.push({\n                    func: task.invoke,\n                    args: additionalArgs,\n                    target: task.data && task.data.target,\n                });\n                break;\n            case 'macroTask':\n                switch (task.source) {\n                    case 'setTimeout':\n                        task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                        break;\n                    case 'setImmediate':\n                        task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                        break;\n                    case 'setInterval':\n                        task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                        break;\n                    case 'XMLHttpRequest.send':\n                        throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                            task.data['url']);\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                        // (60 frames per second)\n                        task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                        break;\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        const macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            const args = task.data && task.data['args'];\n                            const delay = args && args.length > 1 ? args[1] : 0;\n                            let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args;\n                            if (!!macroTaskOption.isPeriodic) {\n                                // periodic macroTask, use setInterval to simulate\n                                task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                task.data.isPeriodic = true;\n                            }\n                            else {\n                                // not periodic, use setTimeout to simulate\n                                task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                            }\n                            break;\n                        }\n                        throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                }\n                break;\n            case 'eventTask':\n                task = delegate.scheduleTask(target, task);\n                break;\n        }\n        return task;\n    }\n    onCancelTask(delegate, current, target, task) {\n        switch (task.source) {\n            case 'setTimeout':\n            case 'requestAnimationFrame':\n            case 'webkitRequestAnimationFrame':\n            case 'mozRequestAnimationFrame':\n                return this._clearTimeout(task.data['handleId']);\n            case 'setInterval':\n                return this._clearInterval(task.data['handleId']);\n            default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                const macroTaskOption = this.findMacroTaskOption(task);\n                if (macroTaskOption) {\n                    const handleId = task.data['handleId'];\n                    return macroTaskOption.isPeriodic\n                        ? this._clearInterval(handleId)\n                        : this._clearTimeout(handleId);\n                }\n                return delegate.cancelTask(target, task);\n        }\n    }\n    onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n            FakeAsyncTestZoneSpec.patchDate();\n            return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        }\n        finally {\n            if (!this.patchDateLocked) {\n                FakeAsyncTestZoneSpec.resetDate();\n            }\n        }\n    }\n    findMacroTaskOption(task) {\n        if (!this.macroTaskOptions) {\n            return null;\n        }\n        for (let i = 0; i < this.macroTaskOptions.length; i++) {\n            const macroTaskOption = this.macroTaskOptions[i];\n            if (macroTaskOption.source === task.source) {\n                return macroTaskOption;\n            }\n        }\n        return null;\n    }\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n        // ComponentFixture has a special-case handling to detect FakeAsyncTestZoneSpec\n        // and prevent rethrowing the error from the onError subscription since it's handled here.\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n    }\n}\nlet _fakeAsyncTestZoneSpec = null;\nfunction getProxyZoneSpec() {\n    return Zone && Zone['ProxyZoneSpec'];\n}\nlet _sharedProxyZoneSpec = null;\nlet _sharedProxyZone = null;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @experimental\n */\nfunction resetFakeAsyncZone() {\n    if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n    }\n    _fakeAsyncTestZoneSpec = null;\n    getProxyZoneSpec()?.get()?.resetDelegate();\n    _sharedProxyZoneSpec?.resetDelegate();\n}\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * When flush is `false`, if there are any pending timers at the end of the function,\n * an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * ## Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @param options\n *     flush: when true, will drain the macrotask queue after the test function completes.\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @experimental\n */\nfunction fakeAsync(fn, options = {}) {\n    const { flush = true } = options;\n    // Not using an arrow function to preserve context passed from call site\n    const fakeAsyncFn = function (...args) {\n        const ProxyZoneSpec = getProxyZoneSpec();\n        if (!ProxyZoneSpec) {\n            throw new Error('ProxyZoneSpec is needed for the fakeAsync() test helper but could not be found. ' +\n                'Make sure that your environment includes zone-testing.js');\n        }\n        const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n            throw new Error('fakeAsync() calls can not be nested');\n        }\n        try {\n            // in case jasmine.clock init a fakeAsyncTestZoneSpec\n            if (!_fakeAsyncTestZoneSpec) {\n                const FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n                if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n            }\n            let res;\n            const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n            proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n            _fakeAsyncTestZoneSpec.lockDatePatch();\n            try {\n                res = fn.apply(this, args);\n                if (flush) {\n                    _fakeAsyncTestZoneSpec.flush(20, true);\n                }\n                else {\n                    flushMicrotasks();\n                }\n            }\n            finally {\n                proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n            }\n            if (!flush) {\n                if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                    throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n                        `periodic timer(s) still in the queue.`);\n                }\n                if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                    throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n                }\n            }\n            return res;\n        }\n        finally {\n            resetFakeAsyncZone();\n        }\n    };\n    fakeAsyncFn.isFakeAsync = true;\n    return fakeAsyncFn;\n}\nfunction _getFakeAsyncZoneSpec() {\n    if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (_fakeAsyncTestZoneSpec == null) {\n            throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n    }\n    return _fakeAsyncTestZoneSpec;\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer\n * callback has been executed.\n *\n * ## Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @experimental\n */\nfunction tick(millis = 0, ignoreNestedTimeout = false) {\n    _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @experimental\n */\nfunction flush(maxTurns) {\n    return _getFakeAsyncZoneSpec().flush(maxTurns);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @experimental\n */\nfunction discardPeriodicTasks() {\n    const zoneSpec = _getFakeAsyncZoneSpec();\n    zoneSpec.pendingPeriodicTimers;\n    zoneSpec.pendingPeriodicTimers.length = 0;\n}\n/**\n * Wraps a function to be executed in a shared ProxyZone.\n *\n * If no shared ProxyZone exists, one is created and reused for subsequent calls.\n * Useful for wrapping test setup (beforeEach) and test execution (it) when test\n * runner patching isn't available or desired for setting up the ProxyZone.\n *\n * @param fn The function to wrap.\n * @returns A function that executes the original function within the shared ProxyZone.\n *\n * @experimental\n */\nfunction withProxyZone(fn) {\n    const autoProxyFn = function (...args) {\n        const proxyZoneSpec = getProxyZoneSpec();\n        if (proxyZoneSpec === undefined) {\n            throw new Error('ProxyZoneSpec is needed for the withProxyZone() test helper but could not be found. ' +\n                'Make sure that your environment includes zone-testing.js');\n        }\n        const proxyZone = proxyZoneSpec.get() !== undefined ? Zone.current : getOrCreateRootProxy();\n        return proxyZone.run(fn, this, args);\n    };\n    return autoProxyFn;\n}\nfunction getOrCreateRootProxy() {\n    const ProxyZoneSpec = getProxyZoneSpec();\n    if (ProxyZoneSpec === undefined) {\n        throw new Error('ProxyZoneSpec is needed for withProxyZone but could not be found. ' +\n            'Make sure that your environment includes zone-testing.js');\n    }\n    // Ensure the shared ProxyZoneSpec instance exists\n    if (_sharedProxyZoneSpec === null) {\n        _sharedProxyZoneSpec = new ProxyZoneSpec();\n    }\n    _sharedProxyZone = Zone.root.fork(_sharedProxyZoneSpec);\n    return _sharedProxyZone;\n}\n/**\n * Flush any pending microtasks.\n *\n * @experimental\n */\nfunction flushMicrotasks() {\n    _getFakeAsyncZoneSpec().flushMicrotasks();\n}\nfunction patchFakeAsyncTest(Zone) {\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    Zone.__load_patch('fakeasync', (global, Zone, api) => {\n        Zone[api.symbol('fakeAsyncTest')] = {\n            resetFakeAsyncZone,\n            flushMicrotasks,\n            discardPeriodicTasks,\n            tick,\n            flush,\n            fakeAsync,\n            withProxyZone,\n        };\n    }, true);\n    patchedTimers = {\n        setTimeout: global$1.setTimeout,\n        setInterval: global$1.setInterval,\n        clearTimeout: global$1.clearTimeout,\n        clearInterval: global$1.clearInterval,\n        nativeSetTimeout: global$1[Zone.__symbol__('setTimeout')],\n        nativeClearTimeout: global$1[Zone.__symbol__('clearTimeout')],\n    };\n    Scheduler.nextId = Scheduler.getNextId();\n}\n\n/**\n * @fileoverview\n * @suppress {globalThis}\n */\nfunction patchLongStackTrace(Zone) {\n    const NEWLINE = '\\n';\n    const IGNORE_FRAMES = {};\n    const creationTrace = '__creationTrace__';\n    const ERROR_TAG = 'STACKTRACE TRACKING';\n    const SEP_TAG = '__SEP_TAG__';\n    let sepTemplate = SEP_TAG + '@[native]';\n    class LongStackTrace {\n        error = getStacktrace();\n        timestamp = new Date();\n    }\n    function getStacktraceWithUncaughtError() {\n        return new Error(ERROR_TAG);\n    }\n    function getStacktraceWithCaughtError() {\n        try {\n            throw getStacktraceWithUncaughtError();\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    // Some implementations of exception handling don't create a stack trace if the exception\n    // isn't thrown, however it's faster not to actually throw the exception.\n    const error = getStacktraceWithUncaughtError();\n    const caughtError = getStacktraceWithCaughtError();\n    const getStacktrace = error.stack\n        ? getStacktraceWithUncaughtError\n        : caughtError.stack\n            ? getStacktraceWithCaughtError\n            : getStacktraceWithUncaughtError;\n    function getFrames(error) {\n        return error.stack ? error.stack.split(NEWLINE) : [];\n    }\n    function addErrorStack(lines, error) {\n        let trace = getFrames(error);\n        for (let i = 0; i < trace.length; i++) {\n            const frame = trace[i];\n            // Filter out the Frames which are part of stack capturing.\n            if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n                lines.push(trace[i]);\n            }\n        }\n    }\n    function renderLongStackTrace(frames, stack) {\n        const longTrace = [stack ? stack.trim() : ''];\n        if (frames) {\n            let timestamp = new Date().getTime();\n            for (let i = 0; i < frames.length; i++) {\n                const traceFrames = frames[i];\n                const lastTime = traceFrames.timestamp;\n                let separator = `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;\n                separator = separator.replace(/[^\\w\\d]/g, '_');\n                longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n                addErrorStack(longTrace, traceFrames.error);\n                timestamp = lastTime.getTime();\n            }\n        }\n        return longTrace.join(NEWLINE);\n    }\n    // if Error.stackTraceLimit is 0, means stack trace\n    // is disabled, so we don't need to generate long stack trace\n    // this will improve performance in some test(some test will\n    // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n    function stackTracesEnabled() {\n        // Cast through any since this property only exists on Error in the nodejs\n        // typings.\n        return Error.stackTraceLimit > 0;\n    }\n    Zone['longStackTraceZoneSpec'] = {\n        name: 'long-stack-trace',\n        longStackTraceLimit: 10, // Max number of task to keep the stack trace for.\n        // add a getLongStackTrace method in spec to\n        // handle handled reject promise error.\n        getLongStackTrace: function (error) {\n            if (!error) {\n                return undefined;\n            }\n            const trace = error[Zone.__symbol__('currentTaskTrace')];\n            if (!trace) {\n                return error.stack;\n            }\n            return renderLongStackTrace(trace, error.stack);\n        },\n        onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (stackTracesEnabled()) {\n                const currentTask = Zone.currentTask;\n                let trace = (currentTask && currentTask.data && currentTask.data[creationTrace]) || [];\n                trace = [new LongStackTrace()].concat(trace);\n                if (trace.length > this.longStackTraceLimit) {\n                    trace.length = this.longStackTraceLimit;\n                }\n                if (!task.data)\n                    task.data = {};\n                if (task.type === 'eventTask') {\n                    // Fix issue https://github.com/angular/zone.js/issues/1195,\n                    // For event task of browser, by default, all task will share a\n                    // singleton instance of data object, we should create a new one here\n                    // The cast to `any` is required to workaround a closure bug which wrongly applies\n                    // URL sanitization rules to .data access.\n                    task.data = { ...task.data };\n                }\n                task.data[creationTrace] = trace;\n            }\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        },\n        onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (stackTracesEnabled()) {\n                const parentTask = Zone.currentTask || error.task;\n                if (error instanceof Error && parentTask) {\n                    const longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                    try {\n                        error.stack = error.longStack = longStack;\n                    }\n                    catch (err) { }\n                }\n            }\n            return parentZoneDelegate.handleError(targetZone, error);\n        },\n    };\n    function captureStackTraces(stackTraces, count) {\n        if (count > 0) {\n            stackTraces.push(getFrames(new LongStackTrace().error));\n            captureStackTraces(stackTraces, count - 1);\n        }\n    }\n    function computeIgnoreFrames() {\n        if (!stackTracesEnabled()) {\n            return;\n        }\n        const frames = [];\n        captureStackTraces(frames, 2);\n        const frames1 = frames[0];\n        const frames2 = frames[1];\n        for (let i = 0; i < frames1.length; i++) {\n            const frame1 = frames1[i];\n            if (frame1.indexOf(ERROR_TAG) == -1) {\n                let match = frame1.match(/^\\s*at\\s+/);\n                if (match) {\n                    sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                    break;\n                }\n            }\n        }\n        for (let i = 0; i < frames1.length; i++) {\n            const frame1 = frames1[i];\n            const frame2 = frames2[i];\n            if (frame1 === frame2) {\n                IGNORE_FRAMES[frame1] = true;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    computeIgnoreFrames();\n}\n\nclass ProxyZoneSpec {\n    defaultSpecDelegate;\n    name = 'ProxyZone';\n    _delegateSpec = null;\n    properties = { 'ProxyZoneSpec': this };\n    propertyKeys = null;\n    lastTaskState = null;\n    isNeedToTriggerHasTask = false;\n    tasks = [];\n    static get() {\n        return Zone.current.get('ProxyZoneSpec');\n    }\n    static isLoaded() {\n        return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n    }\n    static assertPresent() {\n        const spec = ProxyZoneSpec.get();\n        if (spec === undefined) {\n            throw new Error(`Expected to be running in 'ProxyZone', but it was not found.`);\n        }\n        return spec;\n    }\n    constructor(defaultSpecDelegate = null) {\n        this.defaultSpecDelegate = defaultSpecDelegate;\n        this.setDelegate(defaultSpecDelegate);\n    }\n    setDelegate(delegateSpec) {\n        const isNewDelegate = this._delegateSpec !== delegateSpec;\n        this._delegateSpec = delegateSpec;\n        this.propertyKeys && this.propertyKeys.forEach((key) => delete this.properties[key]);\n        this.propertyKeys = null;\n        if (delegateSpec && delegateSpec.properties) {\n            this.propertyKeys = Object.keys(delegateSpec.properties);\n            this.propertyKeys.forEach((k) => (this.properties[k] = delegateSpec.properties[k]));\n        }\n        // if a new delegateSpec was set, check if we need to trigger hasTask\n        if (isNewDelegate &&\n            this.lastTaskState &&\n            (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n            this.isNeedToTriggerHasTask = true;\n        }\n    }\n    getDelegate() {\n        return this._delegateSpec;\n    }\n    resetDelegate() {\n        this.getDelegate();\n        this.setDelegate(this.defaultSpecDelegate);\n    }\n    tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {\n        if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n            // last delegateSpec has microTask or macroTask\n            // should call onHasTask in current delegateSpec\n            this.isNeedToTriggerHasTask = false;\n            this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n        }\n    }\n    removeFromTasks(task) {\n        if (!this.tasks) {\n            return;\n        }\n        for (let i = 0; i < this.tasks.length; i++) {\n            if (this.tasks[i] === task) {\n                this.tasks.splice(i, 1);\n                return;\n            }\n        }\n    }\n    getAndClearPendingTasksInfo() {\n        if (this.tasks.length === 0) {\n            return '';\n        }\n        const taskInfo = this.tasks.map((task) => {\n            const dataInfo = task.data &&\n                Object.keys(task.data)\n                    .map((key) => {\n                    return key + ':' + task.data[key];\n                })\n                    .join(',');\n            return `type: ${task.type}, source: ${task.source}, args: {${dataInfo}}`;\n        });\n        const pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n        // clear tasks\n        this.tasks = [];\n        return pendingTasksInfo;\n    }\n    onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n        if (this._delegateSpec && this._delegateSpec.onFork) {\n            return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n        }\n        else {\n            return parentZoneDelegate.fork(targetZone, zoneSpec);\n        }\n    }\n    onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {\n        if (this._delegateSpec && this._delegateSpec.onIntercept) {\n            return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n        }\n        else {\n            return parentZoneDelegate.intercept(targetZone, delegate, source);\n        }\n    }\n    onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n        if (this._delegateSpec && this._delegateSpec.onInvoke) {\n            return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n        }\n        else {\n            return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        }\n    }\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n        if (this._delegateSpec && this._delegateSpec.onHandleError) {\n            return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n        }\n        else {\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    }\n    onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n        if (task.type !== 'eventTask') {\n            this.tasks.push(task);\n        }\n        if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n            return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n        }\n        else {\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        }\n    }\n    onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n            this.removeFromTasks(task);\n        }\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n        if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n            return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n        }\n        else {\n            return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n        }\n    }\n    onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n        if (task.type !== 'eventTask') {\n            this.removeFromTasks(task);\n        }\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n        if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n            return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n        }\n        else {\n            return parentZoneDelegate.cancelTask(targetZone, task);\n        }\n    }\n    onHasTask(delegate, current, target, hasTaskState) {\n        this.lastTaskState = hasTaskState;\n        if (this._delegateSpec && this._delegateSpec.onHasTask) {\n            this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n        }\n        else {\n            delegate.hasTask(target, hasTaskState);\n        }\n    }\n}\nfunction patchProxyZoneSpec(Zone) {\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n}\n\nfunction patchSyncTest(Zone) {\n    class SyncTestZoneSpec {\n        runZone = Zone.current;\n        constructor(namePrefix) {\n            this.name = 'syncTestZone for ' + namePrefix;\n        }\n        // ZoneSpec implementation below.\n        name;\n        onScheduleTask(delegate, current, target, task) {\n            switch (task.type) {\n                case 'microTask':\n                case 'macroTask':\n                    throw new Error(`Cannot call ${task.source} from within a sync test (${this.name}).`);\n                case 'eventTask':\n                    task = delegate.scheduleTask(target, task);\n                    break;\n            }\n            return task;\n        }\n    }\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n}\n\nfunction patchPromiseTesting(Zone) {\n    /**\n     * Promise for async/fakeAsync zoneSpec test\n     * can support async operation which not supported by zone.js\n     * such as\n     * it ('test jsonp in AsyncZone', async() => {\n     *   new Promise(res => {\n     *     jsonp(url, (data) => {\n     *       // success callback\n     *       res(data);\n     *     });\n     *   }).then((jsonpResult) => {\n     *     // get jsonp result.\n     *\n     *     // user will expect AsyncZoneSpec wait for\n     *     // then, but because jsonp is not zone aware\n     *     // AsyncZone will finish before then is called.\n     *   });\n     * });\n     */\n    Zone.__load_patch('promisefortest', (global, Zone, api) => {\n        const symbolState = api.symbol('state');\n        const UNRESOLVED = null;\n        const symbolParentUnresolved = api.symbol('parentUnresolved');\n        // patch Promise.prototype.then to keep an internal\n        // number for tracking unresolved chained promise\n        // we will decrease this number when the parent promise\n        // being resolved/rejected and chained promise was\n        // scheduled as a microTask.\n        // so we can know such kind of chained promise still\n        // not resolved in AsyncTestZone\n        Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n            let oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                return;\n            }\n            oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n            Promise.prototype.then = function () {\n                const chained = oriThen.apply(this, arguments);\n                if (this[symbolState] === UNRESOLVED) {\n                    // parent promise is unresolved.\n                    const asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n                    if (asyncTestZoneSpec) {\n                        asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n                        chained[symbolParentUnresolved] = true;\n                    }\n                }\n                return chained;\n            };\n        };\n        Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n            // restore origin then\n            const oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                Promise.prototype.then = oriThen;\n                Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n            }\n        };\n    });\n}\n\nfunction rollupTesting(Zone) {\n    patchLongStackTrace(Zone);\n    patchProxyZoneSpec(Zone);\n    patchSyncTest(Zone);\n    patchJasmine(Zone);\n    patchJest(Zone);\n    patchMocha(Zone);\n    patchAsyncTest(Zone);\n    patchFakeAsyncTest(Zone);\n    patchPromiseTesting(Zone);\n}\n\nrollupTesting(Zone);\n"],"mappings":"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","names":["Zone","global","ProxyZoneSpec","originalClockFn","FakeAsyncTestZoneSpec","proxyZoneSpec","self","AsyncTestZoneSpec","current","args","flush","error"],"x_google_ignoreList":[0]}