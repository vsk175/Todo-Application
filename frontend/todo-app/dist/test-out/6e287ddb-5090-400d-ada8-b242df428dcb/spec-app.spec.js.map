{"version":3,"sources":["angular:jit:template:src\\app\\app.html","angular:jit:style:src\\app\\app.css","node_modules/@angular/router/fesm2022/router2.mjs","node_modules/@angular/router/fesm2022/router.mjs","src/app/app.ts","src/app/app.spec.ts"],"sourcesContent":["<router-outlet />\r\n","/* src/app/app.css */\n/*# sourceMappingURL=app.css.map */\n","/**\n * @license Angular v20.1.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { DOCUMENT, Location } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { ɵisPromise as _isPromise, ɵRuntimeError as _RuntimeError, Injectable, ɵisNgModule as _isNgModule, isStandalone, createEnvironmentInjector, InjectionToken, EventEmitter, input, inject, ViewContainerRef, ChangeDetectorRef, Directive, Input, Output, reflectComponentType, Component, ɵisInjectable as _isInjectable, runInInjectionContext, Compiler, NgModuleFactory, afterNextRender, EnvironmentInjector, DestroyRef, ɵConsole as _Console, ɵPendingTasksInternal as _PendingTasksInternal, ɵINTERNAL_APPLICATION_ERROR_HANDLER as _INTERNAL_APPLICATION_ERROR_HANDLER } from '@angular/core';\nimport { isObservable, from, of, BehaviorSubject, combineLatest, EmptyError, concat, defer, pipe, throwError, EMPTY, ConnectableObservable, Subject, Observable, Subscription } from 'rxjs';\nimport { map, switchMap, take, startWith, filter, mergeMap, first, concatMap, tap, catchError, scan, defaultIfEmpty, last as last$1, takeLast, finalize, refCount, takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/platform-browser';\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nconst PRIMARY_OUTLET = 'primary';\n/**\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\n */\nconst RouteTitleKey = /* @__PURE__ */ Symbol('RouteTitle');\nclass ParamsAsMap {\n    params;\n    constructor(params) {\n        this.params = params || {};\n    }\n    has(name) {\n        return Object.prototype.hasOwnProperty.call(this.params, name);\n    }\n    get(name) {\n        if (this.has(name)) {\n            const v = this.params[name];\n            return Array.isArray(v) ? v[0] : v;\n        }\n        return null;\n    }\n    getAll(name) {\n        if (this.has(name)) {\n            const v = this.params[name];\n            return Array.isArray(v) ? v : [v];\n        }\n        return [];\n    }\n    get keys() {\n        return Object.keys(this.params);\n    }\n}\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nfunction convertToParamMap(params) {\n    return new ParamsAsMap(params);\n}\n/**\n * Matches the route configuration (`route`) against the actual URL (`segments`).\n *\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\n *\n * @param segments The remaining unmatched segments in the current navigation\n * @param segmentGroup The current segment group being matched\n * @param route The `Route` to match against.\n *\n * @see {@link UrlMatchResult}\n * @see {@link Route}\n *\n * @returns The resulting match information or `null` if the `route` should not match.\n * @publicApi\n */\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n    const parts = route.path.split('/');\n    if (parts.length > segments.length) {\n        // The actual URL is shorter than the config, no match\n        return null;\n    }\n    if (route.pathMatch === 'full' &&\n        (segmentGroup.hasChildren() || parts.length < segments.length)) {\n        // The config is longer than the actual URL but we are looking for a full match, return null\n        return null;\n    }\n    const posParams = {};\n    // Check each config part against the actual URL\n    for (let index = 0; index < parts.length; index++) {\n        const part = parts[index];\n        const segment = segments[index];\n        const isParameter = part[0] === ':';\n        if (isParameter) {\n            posParams[part.substring(1)] = segment;\n        }\n        else if (part !== segment.path) {\n            // The actual URL part does not match the config, no match\n            return null;\n        }\n    }\n    return { consumed: segments.slice(0, parts.length), posParams };\n}\n\nfunction shallowEqualArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; ++i) {\n        if (!shallowEqual(a[i], b[i]))\n            return false;\n    }\n    return true;\n}\nfunction shallowEqual(a, b) {\n    // While `undefined` should never be possible, it would sometimes be the case in IE 11\n    // and pre-chromium Edge. The check below accounts for this edge case.\n    const k1 = a ? getDataKeys(a) : undefined;\n    const k2 = b ? getDataKeys(b) : undefined;\n    if (!k1 || !k2 || k1.length != k2.length) {\n        return false;\n    }\n    let key;\n    for (let i = 0; i < k1.length; i++) {\n        key = k1[i];\n        if (!equalArraysOrString(a[key], b[key])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Gets the keys of an object, including `symbol` keys.\n */\nfunction getDataKeys(obj) {\n    return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\n/**\n * Test equality for arrays of strings or a string.\n */\nfunction equalArraysOrString(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length)\n            return false;\n        const aSorted = [...a].sort();\n        const bSorted = [...b].sort();\n        return aSorted.every((val, index) => bSorted[index] === val);\n    }\n    else {\n        return a === b;\n    }\n}\n/**\n * Return the last element of an array.\n */\nfunction last(a) {\n    return a.length > 0 ? a[a.length - 1] : null;\n}\nfunction wrapIntoObservable(value) {\n    if (isObservable(value)) {\n        return value;\n    }\n    if (_isPromise(value)) {\n        // Use `Promise.resolve()` to wrap promise-like instances.\n        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n        // change detection.\n        return from(Promise.resolve(value));\n    }\n    return of(value);\n}\n\nconst pathCompareMap = {\n    'exact': equalSegmentGroups,\n    'subset': containsSegmentGroup,\n};\nconst paramCompareMap = {\n    'exact': equalParams,\n    'subset': containsParams,\n    'ignored': () => true,\n};\nfunction containsTree(container, containee, options) {\n    return (pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n        paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n        !(options.fragment === 'exact' && container.fragment !== containee.fragment));\n}\nfunction equalParams(container, containee) {\n    // TODO: This does not handle array params correctly.\n    return shallowEqual(container, containee);\n}\nfunction equalSegmentGroups(container, containee, matrixParams) {\n    if (!equalPath(container.segments, containee.segments))\n        return false;\n    if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n        return false;\n    }\n    if (container.numberOfChildren !== containee.numberOfChildren)\n        return false;\n    for (const c in containee.children) {\n        if (!container.children[c])\n            return false;\n        if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\n            return false;\n    }\n    return true;\n}\nfunction containsParams(container, containee) {\n    return (Object.keys(containee).length <= Object.keys(container).length &&\n        Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key])));\n}\nfunction containsSegmentGroup(container, containee, matrixParams) {\n    return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\nfunction containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {\n    if (container.segments.length > containeePaths.length) {\n        const current = container.segments.slice(0, containeePaths.length);\n        if (!equalPath(current, containeePaths))\n            return false;\n        if (containee.hasChildren())\n            return false;\n        if (!matrixParamsMatch(current, containeePaths, matrixParams))\n            return false;\n        return true;\n    }\n    else if (container.segments.length === containeePaths.length) {\n        if (!equalPath(container.segments, containeePaths))\n            return false;\n        if (!matrixParamsMatch(container.segments, containeePaths, matrixParams))\n            return false;\n        for (const c in containee.children) {\n            if (!container.children[c])\n                return false;\n            if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else {\n        const current = containeePaths.slice(0, container.segments.length);\n        const next = containeePaths.slice(container.segments.length);\n        if (!equalPath(container.segments, current))\n            return false;\n        if (!matrixParamsMatch(container.segments, current, matrixParams))\n            return false;\n        if (!container.children[PRIMARY_OUTLET])\n            return false;\n        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n    }\n}\nfunction matrixParamsMatch(containerPaths, containeePaths, options) {\n    return containeePaths.every((containeeSegment, i) => {\n        return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n    });\n}\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass UrlTree {\n    root;\n    queryParams;\n    fragment;\n    /** @internal */\n    _queryParamMap;\n    constructor(\n    /** The root segment group of the URL tree */\n    root = new UrlSegmentGroup([], {}), \n    /** The query params of the URL */\n    queryParams = {}, \n    /** The fragment of the URL */\n    fragment = null) {\n        this.root = root;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (root.segments.length > 0) {\n                throw new _RuntimeError(4015 /* RuntimeErrorCode.INVALID_ROOT_URL_SEGMENT */, 'The root `UrlSegmentGroup` should not contain `segments`. ' +\n                    'Instead, these segments belong in the `children` so they can be associated with a named outlet.');\n            }\n        }\n    }\n    get queryParamMap() {\n        this._queryParamMap ??= convertToParamMap(this.queryParams);\n        return this._queryParamMap;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return DEFAULT_SERIALIZER.serialize(this);\n    }\n}\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nclass UrlSegmentGroup {\n    segments;\n    children;\n    /** The parent node in the url tree */\n    parent = null;\n    constructor(\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    segments, \n    /** The list of children of this group */\n    children) {\n        this.segments = segments;\n        this.children = children;\n        Object.values(children).forEach((v) => (v.parent = this));\n    }\n    /** Whether the segment has child segments */\n    hasChildren() {\n        return this.numberOfChildren > 0;\n    }\n    /** Number of child segments */\n    get numberOfChildren() {\n        return Object.keys(this.children).length;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return serializePaths(this);\n    }\n}\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass UrlSegment {\n    path;\n    parameters;\n    /** @internal */\n    _parameterMap;\n    constructor(\n    /** The path part of a URL segment */\n    path, \n    /** The matrix parameters associated with a segment */\n    parameters) {\n        this.path = path;\n        this.parameters = parameters;\n    }\n    get parameterMap() {\n        this._parameterMap ??= convertToParamMap(this.parameters);\n        return this._parameterMap;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return serializePath(this);\n    }\n}\nfunction equalSegments(as, bs) {\n    return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\nfunction equalPath(as, bs) {\n    if (as.length !== bs.length)\n        return false;\n    return as.every((a, i) => a.path === bs[i].path);\n}\nfunction mapChildrenIntoArray(segment, fn) {\n    let res = [];\n    Object.entries(segment.children).forEach(([childOutlet, child]) => {\n        if (childOutlet === PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    Object.entries(segment.children).forEach(([childOutlet, child]) => {\n        if (childOutlet !== PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    return res;\n}\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\nclass UrlSerializer {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: UrlSerializer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: UrlSerializer, providedIn: 'root', useFactory: () => new DefaultUrlSerializer() });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: UrlSerializer, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => new DefaultUrlSerializer() }]\n        }] });\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nclass DefaultUrlSerializer {\n    /** Parses a url into a `UrlTree` */\n    parse(url) {\n        const p = new UrlParser(url);\n        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n    }\n    /** Converts a `UrlTree` into a url */\n    serialize(tree) {\n        const segment = `/${serializeSegment(tree.root, true)}`;\n        const query = serializeQueryParams(tree.queryParams);\n        const fragment = typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n        return `${segment}${query}${fragment}`;\n    }\n}\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\nfunction serializePaths(segment) {\n    return segment.segments.map((p) => serializePath(p)).join('/');\n}\nfunction serializeSegment(segment, root) {\n    if (!segment.hasChildren()) {\n        return serializePaths(segment);\n    }\n    if (root) {\n        const primary = segment.children[PRIMARY_OUTLET]\n            ? serializeSegment(segment.children[PRIMARY_OUTLET], false)\n            : '';\n        const children = [];\n        Object.entries(segment.children).forEach(([k, v]) => {\n            if (k !== PRIMARY_OUTLET) {\n                children.push(`${k}:${serializeSegment(v, false)}`);\n            }\n        });\n        return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n    }\n    else {\n        const children = mapChildrenIntoArray(segment, (v, k) => {\n            if (k === PRIMARY_OUTLET) {\n                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n            }\n            return [`${k}:${serializeSegment(v, false)}`];\n        });\n        // use no parenthesis if the only child is a primary outlet route\n        if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n            return `${serializePaths(segment)}/${children[0]}`;\n        }\n        return `${serializePaths(segment)}/(${children.join('//')})`;\n    }\n}\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\nfunction encodeUriString(s) {\n    return encodeURIComponent(s)\n        .replace(/%40/g, '@')\n        .replace(/%3A/gi, ':')\n        .replace(/%24/g, '$')\n        .replace(/%2C/gi, ',');\n}\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nfunction encodeUriQuery(s) {\n    return encodeUriString(s).replace(/%3B/gi, ';');\n}\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nfunction encodeUriFragment(s) {\n    return encodeURI(s);\n}\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nfunction encodeUriSegment(s) {\n    return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\nfunction decode(s) {\n    return decodeURIComponent(s);\n}\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nfunction decodeQuery(s) {\n    return decode(s.replace(/\\+/g, '%20'));\n}\nfunction serializePath(path) {\n    return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\nfunction serializeMatrixParams(params) {\n    return Object.entries(params)\n        .map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`)\n        .join('');\n}\nfunction serializeQueryParams(params) {\n    const strParams = Object.entries(params)\n        .map(([name, value]) => {\n        return Array.isArray(value)\n            ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&')\n            : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n    })\n        .filter((s) => s);\n    return strParams.length ? `?${strParams.join('&')}` : '';\n}\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str) {\n    const match = str.match(SEGMENT_RE);\n    return match ? match[0] : '';\n}\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str) {\n    const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n    return match ? match[0] : '';\n}\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str) {\n    const match = str.match(QUERY_PARAM_RE);\n    return match ? match[0] : '';\n}\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str) {\n    const match = str.match(QUERY_PARAM_VALUE_RE);\n    return match ? match[0] : '';\n}\nclass UrlParser {\n    url;\n    remaining;\n    constructor(url) {\n        this.url = url;\n        this.remaining = url;\n    }\n    parseRootSegment() {\n        this.consumeOptional('/');\n        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n            return new UrlSegmentGroup([], {});\n        }\n        // The root segment group never has segments\n        return new UrlSegmentGroup([], this.parseChildren());\n    }\n    parseQueryParams() {\n        const params = {};\n        if (this.consumeOptional('?')) {\n            do {\n                this.parseQueryParam(params);\n            } while (this.consumeOptional('&'));\n        }\n        return params;\n    }\n    parseFragment() {\n        return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n    }\n    parseChildren() {\n        if (this.remaining === '') {\n            return {};\n        }\n        this.consumeOptional('/');\n        const segments = [];\n        if (!this.peekStartsWith('(')) {\n            segments.push(this.parseSegment());\n        }\n        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n            this.capture('/');\n            segments.push(this.parseSegment());\n        }\n        let children = {};\n        if (this.peekStartsWith('/(')) {\n            this.capture('/');\n            children = this.parseParens(true);\n        }\n        let res = {};\n        if (this.peekStartsWith('(')) {\n            res = this.parseParens(false);\n        }\n        if (segments.length > 0 || Object.keys(children).length > 0) {\n            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n        }\n        return res;\n    }\n    // parse a segment with its matrix parameters\n    // ie `name;k1=v1;k2`\n    parseSegment() {\n        const path = matchSegments(this.remaining);\n        if (path === '' && this.peekStartsWith(';')) {\n            throw new _RuntimeError(4009 /* RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `Empty path url segment cannot have parameters: '${this.remaining}'.`);\n        }\n        this.capture(path);\n        return new UrlSegment(decode(path), this.parseMatrixParams());\n    }\n    parseMatrixParams() {\n        const params = {};\n        while (this.consumeOptional(';')) {\n            this.parseParam(params);\n        }\n        return params;\n    }\n    parseParam(params) {\n        const key = matchMatrixKeySegments(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        let value = '';\n        if (this.consumeOptional('=')) {\n            const valueMatch = matchSegments(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        params[decode(key)] = decode(value);\n    }\n    // Parse a single query parameter `name[=value]`\n    parseQueryParam(params) {\n        const key = matchQueryParams(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        let value = '';\n        if (this.consumeOptional('=')) {\n            const valueMatch = matchUrlQueryParamValue(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        const decodedKey = decodeQuery(key);\n        const decodedVal = decodeQuery(value);\n        if (params.hasOwnProperty(decodedKey)) {\n            // Append to existing values\n            let currentVal = params[decodedKey];\n            if (!Array.isArray(currentVal)) {\n                currentVal = [currentVal];\n                params[decodedKey] = currentVal;\n            }\n            currentVal.push(decodedVal);\n        }\n        else {\n            // Create a new value\n            params[decodedKey] = decodedVal;\n        }\n    }\n    // parse `(a/b//outlet_name:c/d)`\n    parseParens(allowPrimary) {\n        const segments = {};\n        this.capture('(');\n        while (!this.consumeOptional(')') && this.remaining.length > 0) {\n            const path = matchSegments(this.remaining);\n            const next = this.remaining[path.length];\n            // if is is not one of these characters, then the segment was unescaped\n            // or the group was not closed\n            if (next !== '/' && next !== ')' && next !== ';') {\n                throw new _RuntimeError(4010 /* RuntimeErrorCode.UNPARSABLE_URL */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`);\n            }\n            let outletName = undefined;\n            if (path.indexOf(':') > -1) {\n                outletName = path.slice(0, path.indexOf(':'));\n                this.capture(outletName);\n                this.capture(':');\n            }\n            else if (allowPrimary) {\n                outletName = PRIMARY_OUTLET;\n            }\n            const children = this.parseChildren();\n            segments[outletName] =\n                Object.keys(children).length === 1\n                    ? children[PRIMARY_OUTLET]\n                    : new UrlSegmentGroup([], children);\n            this.consumeOptional('//');\n        }\n        return segments;\n    }\n    peekStartsWith(str) {\n        return this.remaining.startsWith(str);\n    }\n    // Consumes the prefix when it is present and returns whether it has been consumed\n    consumeOptional(str) {\n        if (this.peekStartsWith(str)) {\n            this.remaining = this.remaining.substring(str.length);\n            return true;\n        }\n        return false;\n    }\n    capture(str) {\n        if (!this.consumeOptional(str)) {\n            throw new _RuntimeError(4011 /* RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`);\n        }\n    }\n}\nfunction createRoot(rootCandidate) {\n    return rootCandidate.segments.length > 0\n        ? new UrlSegmentGroup([], { [PRIMARY_OUTLET]: rootCandidate })\n        : rootCandidate;\n}\n/**\n * Recursively\n * - merges primary segment children into their parents\n * - drops empty children (those which have no segments and no children themselves). This latter\n * prevents serializing a group into something like `/a(aux:)`, where `aux` is an empty child\n * segment.\n * - merges named outlets without a primary segment sibling into the children. This prevents\n * serializing a URL like `//(a:a)(b:b) instead of `/(a:a//b:b)` when the aux b route lives on the\n * root but the `a` route lives under an empty path primary route.\n */\nfunction squashSegmentGroup(segmentGroup) {\n    const newChildren = {};\n    for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n        const childCandidate = squashSegmentGroup(child);\n        // moves named children in an empty path primary child into this group\n        if (childOutlet === PRIMARY_OUTLET &&\n            childCandidate.segments.length === 0 &&\n            childCandidate.hasChildren()) {\n            for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n                newChildren[grandChildOutlet] = grandChild;\n            }\n        } // don't add empty children\n        else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n            newChildren[childOutlet] = childCandidate;\n        }\n    }\n    const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n    return mergeTrivialChildren(s);\n}\n/**\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n *\n * When a segment group has only one child which is a primary outlet, merges that child into the\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\n * group into the parent.\n */\nfunction mergeTrivialChildren(s) {\n    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n        const c = s.children[PRIMARY_OUTLET];\n        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n    }\n    return s;\n}\nfunction isUrlTree(v) {\n    return v instanceof UrlTree;\n}\n\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n *\n * @usageNotes\n *\n * ```ts\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nfunction createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {\n    const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\nfunction createSegmentGroupFromRoute(route) {\n    let targetGroup;\n    function createSegmentGroupFromRouteRecursive(currentRoute) {\n        const childOutlets = {};\n        for (const childSnapshot of currentRoute.children) {\n            const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n            childOutlets[childSnapshot.outlet] = root;\n        }\n        const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n        if (currentRoute === route) {\n            targetGroup = segmentGroup;\n        }\n        return segmentGroup;\n    }\n    const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n    const rootSegmentGroup = createRoot(rootCandidate);\n    return targetGroup ?? rootSegmentGroup;\n}\nfunction createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {\n    let root = relativeTo;\n    while (root.parent) {\n        root = root.parent;\n    }\n    // There are no commands so the `UrlTree` goes to the same path as the one created from the\n    // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n    // applying any other logic.\n    if (commands.length === 0) {\n        return tree(root, root, root, queryParams, fragment);\n    }\n    const nav = computeNavigation(commands);\n    if (nav.toRoot()) {\n        return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n    }\n    const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n    const newSegmentGroup = position.processChildren\n        ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands)\n        : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n    return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\nfunction isMatrixParams(command) {\n    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\n * Determines if a given command has an `outlets` map. When we encounter a command\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n */\nfunction isCommandWithOutlets(command) {\n    return typeof command === 'object' && command != null && command.outlets;\n}\nfunction tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {\n    let qp = {};\n    if (queryParams) {\n        Object.entries(queryParams).forEach(([name, value]) => {\n            qp[name] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;\n        });\n    }\n    let rootCandidate;\n    if (oldRoot === oldSegmentGroup) {\n        rootCandidate = newSegmentGroup;\n    }\n    else {\n        rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n    }\n    const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n    return new UrlTree(newRoot, qp, fragment);\n}\n/**\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\n * value.\n */\nfunction replaceSegment(current, oldSegment, newSegment) {\n    const children = {};\n    Object.entries(current.children).forEach(([outletName, c]) => {\n        if (c === oldSegment) {\n            children[outletName] = newSegment;\n        }\n        else {\n            children[outletName] = replaceSegment(c, oldSegment, newSegment);\n        }\n    });\n    return new UrlSegmentGroup(current.segments, children);\n}\nclass Navigation {\n    isAbsolute;\n    numberOfDoubleDots;\n    commands;\n    constructor(isAbsolute, numberOfDoubleDots, commands) {\n        this.isAbsolute = isAbsolute;\n        this.numberOfDoubleDots = numberOfDoubleDots;\n        this.commands = commands;\n        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n            throw new _RuntimeError(4003 /* RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                'Root segment cannot have matrix parameters');\n        }\n        const cmdWithOutlet = commands.find(isCommandWithOutlets);\n        if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n            throw new _RuntimeError(4004 /* RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                '{outlets:{}} has to be the last command');\n        }\n    }\n    toRoot() {\n        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n    }\n}\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands) {\n    if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n        return new Navigation(true, 0, commands);\n    }\n    let numberOfDoubleDots = 0;\n    let isAbsolute = false;\n    const res = commands.reduce((res, cmd, cmdIdx) => {\n        if (typeof cmd === 'object' && cmd != null) {\n            if (cmd.outlets) {\n                const outlets = {};\n                Object.entries(cmd.outlets).forEach(([name, commands]) => {\n                    outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n                });\n                return [...res, { outlets }];\n            }\n            if (cmd.segmentPath) {\n                return [...res, cmd.segmentPath];\n            }\n        }\n        if (!(typeof cmd === 'string')) {\n            return [...res, cmd];\n        }\n        if (cmdIdx === 0) {\n            cmd.split('/').forEach((urlPart, partIndex) => {\n                if (partIndex == 0 && urlPart === '.') ;\n                else if (partIndex == 0 && urlPart === '') {\n                    //  '/a'\n                    isAbsolute = true;\n                }\n                else if (urlPart === '..') {\n                    //  '../a'\n                    numberOfDoubleDots++;\n                }\n                else if (urlPart != '') {\n                    res.push(urlPart);\n                }\n            });\n            return res;\n        }\n        return [...res, cmd];\n    }, []);\n    return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\nclass Position {\n    segmentGroup;\n    processChildren;\n    index;\n    constructor(segmentGroup, processChildren, index) {\n        this.segmentGroup = segmentGroup;\n        this.processChildren = processChildren;\n        this.index = index;\n    }\n}\nfunction findStartingPositionForTargetGroup(nav, root, target) {\n    if (nav.isAbsolute) {\n        return new Position(root, true, 0);\n    }\n    if (!target) {\n        // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n        // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n        // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n        // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n        return new Position(root, false, NaN);\n    }\n    if (target.parent === null) {\n        return new Position(target, true, 0);\n    }\n    const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n    const index = target.segments.length - 1 + modifier;\n    return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n    let g = group;\n    let ci = index;\n    let dd = numberOfDoubleDots;\n    while (dd > ci) {\n        dd -= ci;\n        g = g.parent;\n        if (!g) {\n            throw new _RuntimeError(4005 /* RuntimeErrorCode.INVALID_DOUBLE_DOTS */, (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\");\n        }\n        ci = g.segments.length;\n    }\n    return new Position(g, false, ci - dd);\n}\nfunction getOutlets(commands) {\n    if (isCommandWithOutlets(commands[0])) {\n        return commands[0].outlets;\n    }\n    return { [PRIMARY_OUTLET]: commands };\n}\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n    segmentGroup ??= new UrlSegmentGroup([], {});\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n    }\n    const m = prefixedWith(segmentGroup, startIndex, commands);\n    const slicedCommands = commands.slice(m.commandIndex);\n    if (m.match && m.pathIndex < segmentGroup.segments.length) {\n        const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n        g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n        return updateSegmentGroupChildren(g, 0, slicedCommands);\n    }\n    else if (m.match && slicedCommands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else if (m.match && !segmentGroup.hasChildren()) {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n    else if (m.match) {\n        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n    }\n    else {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n}\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n    if (commands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else {\n        const outlets = getOutlets(commands);\n        const children = {};\n        // If the set of commands applies to anything other than the primary outlet and the child\n        // segment is an empty path primary segment on its own, we want to apply the commands to the\n        // empty child path rather than here. The outcome is that the empty primary child is effectively\n        // removed from the final output UrlTree. Imagine the following config:\n        //\n        // {path: '', children: [{path: '**', outlet: 'popup'}]}.\n        //\n        // Navigation to /(popup:a) will activate the child outlet correctly Given a follow-up\n        // navigation with commands\n        // ['/', {outlets: {'popup': 'b'}}], we _would not_ want to apply the outlet commands to the\n        // root segment because that would result in\n        // //(popup:a)(popup:b) since the outlet command got applied one level above where it appears in\n        // the `ActivatedRoute` rather than updating the existing one.\n        //\n        // Because empty paths do not appear in the URL segments and the fact that the segments used in\n        // the output `UrlTree` are squashed to eliminate these empty paths where possible\n        // https://github.com/angular/angular/blob/13f10de40e25c6900ca55bd83b36bd533dacfa9e/packages/router/src/url_tree.ts#L755\n        // it can be hard to determine what is the right thing to do when applying commands to a\n        // `UrlSegmentGroup` that is created from an \"unsquashed\"/expanded `ActivatedRoute` tree.\n        // This code effectively \"squashes\" empty path primary routes when they have no siblings on\n        // the same level of the tree.\n        if (Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) &&\n            segmentGroup.children[PRIMARY_OUTLET] &&\n            segmentGroup.numberOfChildren === 1 &&\n            segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {\n            const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);\n            return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n        }\n        Object.entries(outlets).forEach(([outlet, commands]) => {\n            if (typeof commands === 'string') {\n                commands = [commands];\n            }\n            if (commands !== null) {\n                children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n            }\n        });\n        Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n            if (outlets[childOutlet] === undefined) {\n                children[childOutlet] = child;\n            }\n        });\n        return new UrlSegmentGroup(segmentGroup.segments, children);\n    }\n}\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n    let currentCommandIndex = 0;\n    let currentPathIndex = startIndex;\n    const noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n    while (currentPathIndex < segmentGroup.segments.length) {\n        if (currentCommandIndex >= commands.length)\n            return noMatch;\n        const path = segmentGroup.segments[currentPathIndex];\n        const command = commands[currentCommandIndex];\n        // Do not try to consume command as part of the prefixing if it has outlets because it can\n        // contain outlets other than the one being processed. Consuming the outlets command would\n        // result in other outlets being ignored.\n        if (isCommandWithOutlets(command)) {\n            break;\n        }\n        const curr = `${command}`;\n        const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n        if (currentPathIndex > 0 && curr === undefined)\n            break;\n        if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n            if (!compare(curr, next, path))\n                return noMatch;\n            currentCommandIndex += 2;\n        }\n        else {\n            if (!compare(curr, {}, path))\n                return noMatch;\n            currentCommandIndex++;\n        }\n        currentPathIndex++;\n    }\n    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n}\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n    const paths = segmentGroup.segments.slice(0, startIndex);\n    let i = 0;\n    while (i < commands.length) {\n        const command = commands[i];\n        if (isCommandWithOutlets(command)) {\n            const children = createNewSegmentChildren(command.outlets);\n            return new UrlSegmentGroup(paths, children);\n        }\n        // if we start with an object literal, we need to reuse the path part from the segment\n        if (i === 0 && isMatrixParams(commands[0])) {\n            const p = segmentGroup.segments[startIndex];\n            paths.push(new UrlSegment(p.path, stringify(commands[0])));\n            i++;\n            continue;\n        }\n        const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n        const next = i < commands.length - 1 ? commands[i + 1] : null;\n        if (curr && next && isMatrixParams(next)) {\n            paths.push(new UrlSegment(curr, stringify(next)));\n            i += 2;\n        }\n        else {\n            paths.push(new UrlSegment(curr, {}));\n            i++;\n        }\n    }\n    return new UrlSegmentGroup(paths, {});\n}\nfunction createNewSegmentChildren(outlets) {\n    const children = {};\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n        if (typeof commands === 'string') {\n            commands = [commands];\n        }\n        if (commands !== null) {\n            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n        }\n    });\n    return children;\n}\nfunction stringify(params) {\n    const res = {};\n    Object.entries(params).forEach(([k, v]) => (res[k] = `${v}`));\n    return res;\n}\nfunction compare(path, params, segment) {\n    return path == segment.path && shallowEqual(params, segment.parameters);\n}\n\nconst IMPERATIVE_NAVIGATION = 'imperative';\n/**\n * Identifies the type of a router event.\n *\n * @publicApi\n */\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"NavigationStart\"] = 0] = \"NavigationStart\";\n    EventType[EventType[\"NavigationEnd\"] = 1] = \"NavigationEnd\";\n    EventType[EventType[\"NavigationCancel\"] = 2] = \"NavigationCancel\";\n    EventType[EventType[\"NavigationError\"] = 3] = \"NavigationError\";\n    EventType[EventType[\"RoutesRecognized\"] = 4] = \"RoutesRecognized\";\n    EventType[EventType[\"ResolveStart\"] = 5] = \"ResolveStart\";\n    EventType[EventType[\"ResolveEnd\"] = 6] = \"ResolveEnd\";\n    EventType[EventType[\"GuardsCheckStart\"] = 7] = \"GuardsCheckStart\";\n    EventType[EventType[\"GuardsCheckEnd\"] = 8] = \"GuardsCheckEnd\";\n    EventType[EventType[\"RouteConfigLoadStart\"] = 9] = \"RouteConfigLoadStart\";\n    EventType[EventType[\"RouteConfigLoadEnd\"] = 10] = \"RouteConfigLoadEnd\";\n    EventType[EventType[\"ChildActivationStart\"] = 11] = \"ChildActivationStart\";\n    EventType[EventType[\"ChildActivationEnd\"] = 12] = \"ChildActivationEnd\";\n    EventType[EventType[\"ActivationStart\"] = 13] = \"ActivationStart\";\n    EventType[EventType[\"ActivationEnd\"] = 14] = \"ActivationEnd\";\n    EventType[EventType[\"Scroll\"] = 15] = \"Scroll\";\n    EventType[EventType[\"NavigationSkipped\"] = 16] = \"NavigationSkipped\";\n})(EventType || (EventType = {}));\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event | RouterEvent): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see {@link Event}\n * @see [Router events summary](guide/routing/router-reference#router-events)\n * @publicApi\n */\nclass RouterEvent {\n    id;\n    url;\n    constructor(\n    /** A unique ID that the router assigns to every router navigation. */\n    id, \n    /** The URL that is the destination for this navigation. */\n    url) {\n        this.id = id;\n        this.url = url;\n    }\n}\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nclass NavigationStart extends RouterEvent {\n    type = EventType.NavigationStart;\n    /**\n     * Identifies the call or event that triggered the navigation.\n     * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n     *\n     * @see {@link NavigationEnd}\n     * @see {@link NavigationCancel}\n     * @see {@link NavigationError}\n     */\n    navigationTrigger;\n    /**\n     * The navigation state that was previously supplied to the `pushState` call,\n     * when the navigation is triggered by a `popstate` event. Otherwise null.\n     *\n     * The state object is defined by `NavigationExtras`, and contains any\n     * developer-defined state value, as well as a unique ID that\n     * the router assigns to every router transition/navigation.\n     *\n     * From the perspective of the router, the router never \"goes back\".\n     * When the user clicks on the back button in the browser,\n     * a new navigation ID is created.\n     *\n     * Use the ID in this previous-state object to differentiate between a newly created\n     * state and one returned to by a `popstate` event, so that you can restore some\n     * remembered state, such as scroll position.\n     *\n     */\n    restoredState;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    navigationTrigger = 'imperative', \n    /** @docsNotRequired */\n    restoredState = null) {\n        super(id, url);\n        this.navigationTrigger = navigationTrigger;\n        this.restoredState = restoredState;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n    }\n}\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationCancel}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nclass NavigationEnd extends RouterEvent {\n    urlAfterRedirects;\n    type = EventType.NavigationEnd;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n    }\n}\n/**\n * A code for the `NavigationCancel` event of the `Router` to indicate the\n * reason a navigation failed.\n *\n * @publicApi\n */\nvar NavigationCancellationCode;\n(function (NavigationCancellationCode) {\n    /**\n     * A navigation failed because a guard returned a `UrlTree` to redirect.\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"Redirect\"] = 0] = \"Redirect\";\n    /**\n     * A navigation failed because a more recent navigation started.\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"SupersededByNewNavigation\"] = 1] = \"SupersededByNewNavigation\";\n    /**\n     * A navigation failed because one of the resolvers completed without emitting a value.\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"NoDataFromResolver\"] = 2] = \"NoDataFromResolver\";\n    /**\n     * A navigation failed because a guard returned `false`.\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"GuardRejected\"] = 3] = \"GuardRejected\";\n    /**\n     * A navigation was aborted by the `Navigation.abort` function.\n     *\n     * @see {@link Navigation}\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"Aborted\"] = 4] = \"Aborted\";\n})(NavigationCancellationCode || (NavigationCancellationCode = {}));\n/**\n * A code for the `NavigationSkipped` event of the `Router` to indicate the\n * reason a navigation was skipped.\n *\n * @publicApi\n */\nvar NavigationSkippedCode;\n(function (NavigationSkippedCode) {\n    /**\n     * A navigation was skipped because the navigation URL was the same as the current Router URL.\n     */\n    NavigationSkippedCode[NavigationSkippedCode[\"IgnoredSameUrlNavigation\"] = 0] = \"IgnoredSameUrlNavigation\";\n    /**\n     * A navigation was skipped because the configured `UrlHandlingStrategy` return `false` for both\n     * the current Router URL and the target of the navigation.\n     *\n     * @see {@link UrlHandlingStrategy}\n     */\n    NavigationSkippedCode[NavigationSkippedCode[\"IgnoredByUrlHandlingStrategy\"] = 1] = \"IgnoredByUrlHandlingStrategy\";\n})(NavigationSkippedCode || (NavigationSkippedCode = {}));\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nclass NavigationCancel extends RouterEvent {\n    reason;\n    code;\n    type = EventType.NavigationCancel;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /**\n     * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n     * instead for a stable cancellation reason that can be used in production.\n     */\n    reason, \n    /**\n     * A code to indicate why the navigation was canceled. This cancellation code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    code) {\n        super(id, url);\n        this.reason = reason;\n        this.code = code;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n    }\n}\n/**\n * An event triggered when a navigation is skipped.\n * This can happen for a couple reasons including onSameUrlHandling\n * is set to `ignore` and the navigation URL is not different than the\n * current state.\n *\n * @publicApi\n */\nclass NavigationSkipped extends RouterEvent {\n    reason;\n    code;\n    type = EventType.NavigationSkipped;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /**\n     * A description of why the navigation was skipped. For debug purposes only. Use `code`\n     * instead for a stable skipped reason that can be used in production.\n     */\n    reason, \n    /**\n     * A code to indicate why the navigation was skipped. This code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    code) {\n        super(id, url);\n        this.reason = reason;\n        this.code = code;\n    }\n}\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationCancel}\n *\n * @publicApi\n */\nclass NavigationError extends RouterEvent {\n    error;\n    target;\n    type = EventType.NavigationError;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    error, \n    /**\n     * The target of the navigation when the error occurred.\n     *\n     * Note that this can be `undefined` because an error could have occurred before the\n     * `RouterStateSnapshot` was created for the navigation.\n     */\n    target) {\n        super(id, url);\n        this.error = error;\n        this.target = target;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n    }\n}\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nclass RoutesRecognized extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    type = EventType.RoutesRecognized;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n    }\n}\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see {@link GuardsCheckEnd}\n *\n * @publicApi\n */\nclass GuardsCheckStart extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    type = EventType.GuardsCheckStart;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n    }\n    toString() {\n        return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n    }\n}\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see {@link GuardsCheckStart}\n *\n * @publicApi\n */\nclass GuardsCheckEnd extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    shouldActivate;\n    type = EventType.GuardsCheckEnd;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state, \n    /** @docsNotRequired */\n    shouldActivate) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n        this.shouldActivate = shouldActivate;\n    }\n    toString() {\n        return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n    }\n}\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see {@link ResolveEnd}\n *\n * @publicApi\n */\nclass ResolveStart extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    type = EventType.ResolveStart;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n    }\n    toString() {\n        return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n    }\n}\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nclass ResolveEnd extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    type = EventType.ResolveEnd;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n    }\n    toString() {\n        return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n    }\n}\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see {@link RouteConfigLoadEnd}\n *\n * @publicApi\n */\nclass RouteConfigLoadStart {\n    route;\n    type = EventType.RouteConfigLoadStart;\n    constructor(\n    /** @docsNotRequired */\n    route) {\n        this.route = route;\n    }\n    toString() {\n        return `RouteConfigLoadStart(path: ${this.route.path})`;\n    }\n}\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see {@link RouteConfigLoadStart}\n *\n * @publicApi\n */\nclass RouteConfigLoadEnd {\n    route;\n    type = EventType.RouteConfigLoadEnd;\n    constructor(\n    /** @docsNotRequired */\n    route) {\n        this.route = route;\n    }\n    toString() {\n        return `RouteConfigLoadEnd(path: ${this.route.path})`;\n    }\n}\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see {@link ChildActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nclass ChildActivationStart {\n    snapshot;\n    type = EventType.ChildActivationStart;\n    constructor(\n    /** @docsNotRequired */\n    snapshot) {\n        this.snapshot = snapshot;\n    }\n    toString() {\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n        return `ChildActivationStart(path: '${path}')`;\n    }\n}\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see {@link ChildActivationStart}\n * @see {@link ResolveStart}\n * @publicApi\n */\nclass ChildActivationEnd {\n    snapshot;\n    type = EventType.ChildActivationEnd;\n    constructor(\n    /** @docsNotRequired */\n    snapshot) {\n        this.snapshot = snapshot;\n    }\n    toString() {\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n        return `ChildActivationEnd(path: '${path}')`;\n    }\n}\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nclass ActivationStart {\n    snapshot;\n    type = EventType.ActivationStart;\n    constructor(\n    /** @docsNotRequired */\n    snapshot) {\n        this.snapshot = snapshot;\n    }\n    toString() {\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n        return `ActivationStart(path: '${path}')`;\n    }\n}\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationStart}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nclass ActivationEnd {\n    snapshot;\n    type = EventType.ActivationEnd;\n    constructor(\n    /** @docsNotRequired */\n    snapshot) {\n        this.snapshot = snapshot;\n    }\n    toString() {\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n        return `ActivationEnd(path: '${path}')`;\n    }\n}\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nclass Scroll {\n    routerEvent;\n    position;\n    anchor;\n    type = EventType.Scroll;\n    constructor(\n    /** @docsNotRequired */\n    routerEvent, \n    /** @docsNotRequired */\n    position, \n    /** @docsNotRequired */\n    anchor) {\n        this.routerEvent = routerEvent;\n        this.position = position;\n        this.anchor = anchor;\n    }\n    toString() {\n        const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n        return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n    }\n}\nclass BeforeActivateRoutes {\n}\nclass RedirectRequest {\n    url;\n    navigationBehaviorOptions;\n    constructor(url, navigationBehaviorOptions) {\n        this.url = url;\n        this.navigationBehaviorOptions = navigationBehaviorOptions;\n    }\n}\nfunction isPublicRouterEvent(e) {\n    return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\n}\nfunction stringifyEvent(routerEvent) {\n    switch (routerEvent.type) {\n        case EventType.ActivationEnd:\n            return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n        case EventType.ActivationStart:\n            return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n        case EventType.ChildActivationEnd:\n            return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n        case EventType.ChildActivationStart:\n            return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n        case EventType.GuardsCheckEnd:\n            return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n        case EventType.GuardsCheckStart:\n            return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n        case EventType.NavigationCancel:\n            return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n        case EventType.NavigationSkipped:\n            return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n        case EventType.NavigationEnd:\n            return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\n        case EventType.NavigationError:\n            return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\n        case EventType.NavigationStart:\n            return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n        case EventType.ResolveEnd:\n            return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n        case EventType.ResolveStart:\n            return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n        case EventType.RouteConfigLoadEnd:\n            return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n        case EventType.RouteConfigLoadStart:\n            return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n        case EventType.RoutesRecognized:\n            return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n        case EventType.Scroll:\n            const pos = routerEvent.position\n                ? `${routerEvent.position[0]}, ${routerEvent.position[1]}`\n                : null;\n            return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n    }\n}\n\n/**\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\n * `currentInjector`.\n *\n * @param route The route that might have providers\n * @param currentInjector The parent injector of the `Route`\n */\nfunction getOrCreateRouteInjectorIfNeeded(route, currentInjector) {\n    if (route.providers && !route._injector) {\n        route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);\n    }\n    return route._injector ?? currentInjector;\n}\nfunction validateConfig(config, parentPath = '', requireStandaloneComponents = false) {\n    // forEach doesn't iterate undefined values\n    for (let i = 0; i < config.length; i++) {\n        const route = config[i];\n        const fullPath = getFullPath(parentPath, route);\n        validateNode(route, fullPath, requireStandaloneComponents);\n    }\n}\nfunction assertStandalone(fullPath, component) {\n    if (component && _isNgModule(component)) {\n        throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` +\n            `but it must be used with standalone components. Use 'loadChildren' instead.`);\n    }\n    else if (component && !isStandalone(component)) {\n        throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);\n    }\n}\nfunction validateNode(route, fullPath, requireStandaloneComponents) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!route) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n        }\n        if (Array.isArray(route)) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': Array cannot be specified`);\n        }\n        if (!route.redirectTo &&\n            !route.component &&\n            !route.loadComponent &&\n            !route.children &&\n            !route.loadChildren &&\n            route.outlet &&\n            route.outlet !== PRIMARY_OUTLET) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n        }\n        if (route.redirectTo && route.children) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n        }\n        if (route.redirectTo && route.loadChildren) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n        }\n        if (route.children && route.loadChildren) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n        }\n        if (route.component && route.loadComponent) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);\n        }\n        if (route.redirectTo) {\n            if (route.component || route.loadComponent) {\n                throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);\n            }\n            if (route.canMatch || route.canActivate) {\n                throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? 'canMatch' : 'canActivate'} cannot be used together.` +\n                    `Redirects happen before guards are executed.`);\n            }\n        }\n        if (route.path && route.matcher) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n        }\n        if (route.redirectTo === void 0 &&\n            !route.component &&\n            !route.loadComponent &&\n            !route.children &&\n            !route.loadChildren) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);\n        }\n        if (route.path === void 0 && route.matcher === void 0) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n        }\n        if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n        }\n        if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n            const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n        }\n        if (requireStandaloneComponents) {\n            assertStandalone(fullPath, route.component);\n        }\n    }\n    if (route.children) {\n        validateConfig(route.children, fullPath, requireStandaloneComponents);\n    }\n}\nfunction getFullPath(parentPath, currentRoute) {\n    if (!currentRoute) {\n        return parentPath;\n    }\n    if (!parentPath && !currentRoute.path) {\n        return '';\n    }\n    else if (parentPath && !currentRoute.path) {\n        return `${parentPath}/`;\n    }\n    else if (!parentPath && currentRoute.path) {\n        return currentRoute.path;\n    }\n    else {\n        return `${parentPath}/${currentRoute.path}`;\n    }\n}\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\nfunction getOutlet(route) {\n    return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\n * The order of the configs is otherwise preserved.\n */\nfunction sortByMatchingOutlets(routes, outletName) {\n    const sortedConfig = routes.filter((r) => getOutlet(r) === outletName);\n    sortedConfig.push(...routes.filter((r) => getOutlet(r) !== outletName));\n    return sortedConfig;\n}\n/**\n * Gets the first injector in the snapshot's parent tree.\n *\n * If the `Route` has a static list of providers, the returned injector will be the one created from\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\n * loaded config or their static providers.\n *\n * Returns `null` if there is neither this nor any parents have a stored injector.\n *\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\n * also used for getting the correct injector to use for creating components.\n */\nfunction getClosestRouteInjector(snapshot) {\n    if (!snapshot)\n        return null;\n    // If the current route has its own injector, which is created from the static providers on the\n    // route itself, we should use that. Otherwise, we start at the parent since we do not want to\n    // include the lazy loaded injector from this route.\n    if (snapshot.routeConfig?._injector) {\n        return snapshot.routeConfig._injector;\n    }\n    for (let s = snapshot.parent; s; s = s.parent) {\n        const route = s.routeConfig;\n        // Note that the order here is important. `_loadedInjector` stored on the route with\n        // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\n        // is created from the static providers on that parent route, so it applies to the children as\n        // well, but only if there is no lazy loaded NgModuleRef injector.\n        if (route?._loadedInjector)\n            return route._loadedInjector;\n        if (route?._injector)\n            return route._injector;\n    }\n    return null;\n}\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nclass OutletContext {\n    rootInjector;\n    outlet = null;\n    route = null;\n    children;\n    attachRef = null;\n    get injector() {\n        return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\n    }\n    constructor(rootInjector) {\n        this.rootInjector = rootInjector;\n        this.children = new ChildrenOutletContexts(this.rootInjector);\n    }\n}\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\nclass ChildrenOutletContexts {\n    rootInjector;\n    // contexts for child outlets, by name.\n    contexts = new Map();\n    /** @docs-private */\n    constructor(rootInjector) {\n        this.rootInjector = rootInjector;\n    }\n    /** Called when a `RouterOutlet` directive is instantiated */\n    onChildOutletCreated(childName, outlet) {\n        const context = this.getOrCreateContext(childName);\n        context.outlet = outlet;\n        this.contexts.set(childName, context);\n    }\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     */\n    onChildOutletDestroyed(childName) {\n        const context = this.getContext(childName);\n        if (context) {\n            context.outlet = null;\n            context.attachRef = null;\n        }\n    }\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     */\n    onOutletDeactivated() {\n        const contexts = this.contexts;\n        this.contexts = new Map();\n        return contexts;\n    }\n    onOutletReAttached(contexts) {\n        this.contexts = contexts;\n    }\n    getOrCreateContext(childName) {\n        let context = this.getContext(childName);\n        if (!context) {\n            context = new OutletContext(this.rootInjector);\n            this.contexts.set(childName, context);\n        }\n        return context;\n    }\n    getContext(childName) {\n        return this.contexts.get(childName) || null;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: ChildrenOutletContexts, deps: [{ token: i0.EnvironmentInjector }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: ChildrenOutletContexts, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: ChildrenOutletContexts, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i0.EnvironmentInjector }] });\n\nclass Tree {\n    /** @internal */\n    _root;\n    constructor(root) {\n        this._root = root;\n    }\n    get root() {\n        return this._root.value;\n    }\n    /**\n     * @internal\n     */\n    parent(t) {\n        const p = this.pathFromRoot(t);\n        return p.length > 1 ? p[p.length - 2] : null;\n    }\n    /**\n     * @internal\n     */\n    children(t) {\n        const n = findNode(t, this._root);\n        return n ? n.children.map((t) => t.value) : [];\n    }\n    /**\n     * @internal\n     */\n    firstChild(t) {\n        const n = findNode(t, this._root);\n        return n && n.children.length > 0 ? n.children[0].value : null;\n    }\n    /**\n     * @internal\n     */\n    siblings(t) {\n        const p = findPath(t, this._root);\n        if (p.length < 2)\n            return [];\n        const c = p[p.length - 2].children.map((c) => c.value);\n        return c.filter((cc) => cc !== t);\n    }\n    /**\n     * @internal\n     */\n    pathFromRoot(t) {\n        return findPath(t, this._root).map((s) => s.value);\n    }\n}\n// DFS for the node matching the value\nfunction findNode(value, node) {\n    if (value === node.value)\n        return node;\n    for (const child of node.children) {\n        const node = findNode(value, child);\n        if (node)\n            return node;\n    }\n    return null;\n}\n// Return the path to the node with the given value using DFS\nfunction findPath(value, node) {\n    if (value === node.value)\n        return [node];\n    for (const child of node.children) {\n        const path = findPath(value, child);\n        if (path.length) {\n            path.unshift(node);\n            return path;\n        }\n    }\n    return [];\n}\nclass TreeNode {\n    value;\n    children;\n    constructor(value, children) {\n        this.value = value;\n        this.children = children;\n    }\n    toString() {\n        return `TreeNode(${this.value})`;\n    }\n}\n// Return the list of T indexed by outlet name\nfunction nodeChildrenAsMap(node) {\n    const map = {};\n    if (node) {\n        node.children.forEach((child) => (map[child.value.outlet] = child));\n    }\n    return map;\n}\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see {@link ActivatedRoute}\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nclass RouterState extends Tree {\n    snapshot;\n    /** @internal */\n    constructor(root, \n    /** The current snapshot of the router state */\n    snapshot) {\n        super(root);\n        this.snapshot = snapshot;\n        setRouterState(this, root);\n    }\n    toString() {\n        return this.snapshot.toString();\n    }\n}\nfunction createEmptyState(rootComponent) {\n    const snapshot = createEmptyStateSnapshot(rootComponent);\n    const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n    const emptyParams = new BehaviorSubject({});\n    const emptyData = new BehaviorSubject({});\n    const emptyQueryParams = new BehaviorSubject({});\n    const fragment = new BehaviorSubject('');\n    const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n    activated.snapshot = snapshot.root;\n    return new RouterState(new TreeNode(activated, []), snapshot);\n}\nfunction createEmptyStateSnapshot(rootComponent) {\n    const emptyParams = {};\n    const emptyData = {};\n    const emptyQueryParams = {};\n    const fragment = '';\n    const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});\n    return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * Note: the observables in this class only emit when the current and previous values differ based\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"}\n *\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nclass ActivatedRoute {\n    urlSubject;\n    paramsSubject;\n    queryParamsSubject;\n    fragmentSubject;\n    dataSubject;\n    outlet;\n    component;\n    /** The current snapshot of this route */\n    snapshot;\n    /** @internal */\n    _futureSnapshot;\n    /** @internal */\n    _routerState;\n    /** @internal */\n    _paramMap;\n    /** @internal */\n    _queryParamMap;\n    /** An Observable of the resolved route title */\n    title;\n    /** An observable of the URL segments matched by this route. */\n    url;\n    /** An observable of the matrix parameters scoped to this route. */\n    params;\n    /** An observable of the query parameters shared by all the routes. */\n    queryParams;\n    /** An observable of the URL fragment shared by all the routes. */\n    fragment;\n    /** An observable of the static and resolved data of this route. */\n    data;\n    /** @internal */\n    constructor(\n    /** @internal */\n    urlSubject, \n    /** @internal */\n    paramsSubject, \n    /** @internal */\n    queryParamsSubject, \n    /** @internal */\n    fragmentSubject, \n    /** @internal */\n    dataSubject, \n    /** The outlet name of the route, a constant. */\n    outlet, \n    /** The component of the route, a constant. */\n    component, futureSnapshot) {\n        this.urlSubject = urlSubject;\n        this.paramsSubject = paramsSubject;\n        this.queryParamsSubject = queryParamsSubject;\n        this.fragmentSubject = fragmentSubject;\n        this.dataSubject = dataSubject;\n        this.outlet = outlet;\n        this.component = component;\n        this._futureSnapshot = futureSnapshot;\n        this.title = this.dataSubject?.pipe(map((d) => d[RouteTitleKey])) ?? of(undefined);\n        // TODO(atscott): Verify that these can be changed to `.asObservable()` with TGP.\n        this.url = urlSubject;\n        this.params = paramsSubject;\n        this.queryParams = queryParamsSubject;\n        this.fragment = fragmentSubject;\n        this.data = dataSubject;\n    }\n    /** The configuration used to match this route. */\n    get routeConfig() {\n        return this._futureSnapshot.routeConfig;\n    }\n    /** The root of the router state. */\n    get root() {\n        return this._routerState.root;\n    }\n    /** The parent of this route in the router state tree. */\n    get parent() {\n        return this._routerState.parent(this);\n    }\n    /** The first child of this route in the router state tree. */\n    get firstChild() {\n        return this._routerState.firstChild(this);\n    }\n    /** The children of this route in the router state tree. */\n    get children() {\n        return this._routerState.children(this);\n    }\n    /** The path from the root of the router state tree to this route. */\n    get pathFromRoot() {\n        return this._routerState.pathFromRoot(this);\n    }\n    /**\n     * An Observable that contains a map of the required and optional parameters\n     * specific to the route.\n     * The map supports retrieving single and multiple values from the same parameter.\n     */\n    get paramMap() {\n        this._paramMap ??= this.params.pipe(map((p) => convertToParamMap(p)));\n        return this._paramMap;\n    }\n    /**\n     * An Observable that contains a map of the query parameters available to all routes.\n     * The map supports retrieving single and multiple values from the query parameter.\n     */\n    get queryParamMap() {\n        this._queryParamMap ??= this.queryParams.pipe(map((p) => convertToParamMap(p)));\n        return this._queryParamMap;\n    }\n    toString() {\n        return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n    }\n}\n/**\n * Returns the inherited params, data, and resolve for a given route.\n *\n * By default, we do not inherit parent data unless the current route is path-less or the parent\n * route is component-less.\n */\nfunction getInherited(route, parent, paramsInheritanceStrategy = 'emptyOnly') {\n    let inherited;\n    const { routeConfig } = route;\n    if (parent !== null &&\n        (paramsInheritanceStrategy === 'always' ||\n            // inherit parent data if route is empty path\n            routeConfig?.path === '' ||\n            // inherit parent data if parent was componentless\n            (!parent.component && !parent.routeConfig?.loadComponent))) {\n        inherited = {\n            params: { ...parent.params, ...route.params },\n            data: { ...parent.data, ...route.data },\n            resolve: {\n                // Snapshots are created with data inherited from parent and guards (i.e. canActivate) can\n                // change data because it's not frozen...\n                // This first line could be deleted chose to break/disallow mutating the `data` object in\n                // guards.\n                // Note that data from parents still override this mutated data so anyone relying on this\n                // might be surprised that it doesn't work if parent data is inherited but otherwise does.\n                ...route.data,\n                // Ensure inherited resolved data overrides inherited static data\n                ...parent.data,\n                // static data from the current route overrides any inherited data\n                ...routeConfig?.data,\n                // resolved data from current route overrides everything\n                ...route._resolvedData,\n            },\n        };\n    }\n    else {\n        inherited = {\n            params: { ...route.params },\n            data: { ...route.data },\n            resolve: { ...route.data, ...(route._resolvedData ?? {}) },\n        };\n    }\n    if (routeConfig && hasStaticTitle(routeConfig)) {\n        inherited.resolve[RouteTitleKey] = routeConfig.title;\n    }\n    return inherited;\n}\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * The following example initializes a component with route information extracted\n * from the snapshot of the root node at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass ActivatedRouteSnapshot {\n    url;\n    params;\n    queryParams;\n    fragment;\n    data;\n    outlet;\n    component;\n    /** The configuration used to match this route **/\n    routeConfig;\n    /** @internal */\n    _resolve;\n    /** @internal */\n    _resolvedData;\n    /** @internal */\n    _routerState;\n    /** @internal */\n    _paramMap;\n    /** @internal */\n    _queryParamMap;\n    /** The resolved route title */\n    get title() {\n        // Note: This _must_ be a getter because the data is mutated in the resolvers. Title will not be\n        // available at the time of class instantiation.\n        return this.data?.[RouteTitleKey];\n    }\n    /** @internal */\n    constructor(\n    /** The URL segments matched by this route */\n    url, \n    /**\n     *  The matrix parameters scoped to this route.\n     *\n     *  You can compute all params (or data) in the router state or to get params outside\n     *  of an activated component by traversing the `RouterState` tree as in the following\n     *  example:\n     *  ```ts\n     *  collectRouteParams(router: Router) {\n     *    let params = {};\n     *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\n     *    while (stack.length > 0) {\n     *      const route = stack.pop()!;\n     *      params = {...params, ...route.params};\n     *      stack.push(...route.children);\n     *    }\n     *    return params;\n     *  }\n     *  ```\n     */\n    params, \n    /** The query parameters shared by all the routes */\n    queryParams, \n    /** The URL fragment shared by all the routes */\n    fragment, \n    /** The static and resolved data of this route */\n    data, \n    /** The outlet name of the route */\n    outlet, \n    /** The component of the route */\n    component, routeConfig, resolve) {\n        this.url = url;\n        this.params = params;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        this.data = data;\n        this.outlet = outlet;\n        this.component = component;\n        this.routeConfig = routeConfig;\n        this._resolve = resolve;\n    }\n    /** The root of the router state */\n    get root() {\n        return this._routerState.root;\n    }\n    /** The parent of this route in the router state tree */\n    get parent() {\n        return this._routerState.parent(this);\n    }\n    /** The first child of this route in the router state tree */\n    get firstChild() {\n        return this._routerState.firstChild(this);\n    }\n    /** The children of this route in the router state tree */\n    get children() {\n        return this._routerState.children(this);\n    }\n    /** The path from the root of the router state tree to this route */\n    get pathFromRoot() {\n        return this._routerState.pathFromRoot(this);\n    }\n    get paramMap() {\n        this._paramMap ??= convertToParamMap(this.params);\n        return this._paramMap;\n    }\n    get queryParamMap() {\n        this._queryParamMap ??= convertToParamMap(this.queryParams);\n        return this._queryParamMap;\n    }\n    toString() {\n        const url = this.url.map((segment) => segment.toString()).join('/');\n        const matched = this.routeConfig ? this.routeConfig.path : '';\n        return `Route(url:'${url}', path:'${matched}')`;\n    }\n}\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass RouterStateSnapshot extends Tree {\n    url;\n    /** @internal */\n    constructor(\n    /** The url from which this snapshot was created */\n    url, root) {\n        super(root);\n        this.url = url;\n        setRouterState(this, root);\n    }\n    toString() {\n        return serializeNode(this._root);\n    }\n}\nfunction setRouterState(state, node) {\n    node.value._routerState = state;\n    node.children.forEach((c) => setRouterState(state, c));\n}\nfunction serializeNode(node) {\n    const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n    return `${node.value}${c}`;\n}\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n */\nfunction advanceActivatedRoute(route) {\n    if (route.snapshot) {\n        const currentSnapshot = route.snapshot;\n        const nextSnapshot = route._futureSnapshot;\n        route.snapshot = nextSnapshot;\n        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n            route.queryParamsSubject.next(nextSnapshot.queryParams);\n        }\n        if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n            route.fragmentSubject.next(nextSnapshot.fragment);\n        }\n        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n            route.paramsSubject.next(nextSnapshot.params);\n        }\n        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n            route.urlSubject.next(nextSnapshot.url);\n        }\n        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n            route.dataSubject.next(nextSnapshot.data);\n        }\n    }\n    else {\n        route.snapshot = route._futureSnapshot;\n        // this is for resolved data\n        route.dataSubject.next(route._futureSnapshot.data);\n    }\n}\nfunction equalParamsAndUrlSegments(a, b) {\n    const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n    const parentsMismatch = !a.parent !== !b.parent;\n    return (equalUrlParams &&\n        !parentsMismatch &&\n        (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent)));\n}\nfunction hasStaticTitle(config) {\n    return typeof config.title === 'string' || config.title === null;\n}\n\n/**\n * An `InjectionToken` provided by the `RouterOutlet` and can be set using the `routerOutletData`\n * input.\n *\n * When unset, this value is `null` by default.\n *\n * @usageNotes\n *\n * To set the data from the template of the component with `router-outlet`:\n * ```html\n * <router-outlet [routerOutletData]=\"{name: 'Angular'}\" />\n * ```\n *\n * To read the data in the routed component:\n * ```ts\n * data = inject(ROUTER_OUTLET_DATA) as Signal<{name: string}>;\n * ```\n *\n * @publicApi\n */\nconst ROUTER_OUTLET_DATA = new InjectionToken(ngDevMode ? 'RouterOutlet data' : '');\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```html\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```html\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see {@link RouterLink}\n * @see {@link Route}\n * @ngModule RouterModule\n *\n * @publicApi\n */\nclass RouterOutlet {\n    activated = null;\n    /** @internal */\n    get activatedComponentRef() {\n        return this.activated;\n    }\n    _activatedRoute = null;\n    /**\n     * The name of the outlet\n     *\n     */\n    name = PRIMARY_OUTLET;\n    activateEvents = new EventEmitter();\n    deactivateEvents = new EventEmitter();\n    /**\n     * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n     * previously detached subtree.\n     **/\n    attachEvents = new EventEmitter();\n    /**\n     * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n     * subtree.\n     */\n    detachEvents = new EventEmitter();\n    /**\n     * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.\n     *\n     * When unset, the value of the token is `undefined` by default.\n     */\n    routerOutletData = input(undefined, ...(ngDevMode ? [{ debugName: \"routerOutletData\" }] : []));\n    parentContexts = inject(ChildrenOutletContexts);\n    location = inject(ViewContainerRef);\n    changeDetector = inject(ChangeDetectorRef);\n    inputBinder = inject(INPUT_BINDER, { optional: true });\n    /** @docs-private */\n    supportsBindingToComponentInputs = true;\n    /** @docs-private */\n    ngOnChanges(changes) {\n        if (changes['name']) {\n            const { firstChange, previousValue } = changes['name'];\n            if (firstChange) {\n                // The first change is handled by ngOnInit. Because ngOnChanges doesn't get called when no\n                // input is set at all, we need to centrally handle the first change there.\n                return;\n            }\n            // unregister with the old name\n            if (this.isTrackedInParentContexts(previousValue)) {\n                this.deactivate();\n                this.parentContexts.onChildOutletDestroyed(previousValue);\n            }\n            // register the new name\n            this.initializeOutletWithName();\n        }\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n        // Ensure that the registered outlet is this one before removing it on the context.\n        if (this.isTrackedInParentContexts(this.name)) {\n            this.parentContexts.onChildOutletDestroyed(this.name);\n        }\n        this.inputBinder?.unsubscribeFromRouteData(this);\n    }\n    isTrackedInParentContexts(outletName) {\n        return this.parentContexts.getContext(outletName)?.outlet === this;\n    }\n    /** @docs-private */\n    ngOnInit() {\n        this.initializeOutletWithName();\n    }\n    initializeOutletWithName() {\n        this.parentContexts.onChildOutletCreated(this.name, this);\n        if (this.activated) {\n            return;\n        }\n        // If the outlet was not instantiated at the time the route got activated we need to populate\n        // the outlet when it is initialized (ie inside a NgIf)\n        const context = this.parentContexts.getContext(this.name);\n        if (context?.route) {\n            if (context.attachRef) {\n                // `attachRef` is populated when there is an existing component to mount\n                this.attach(context.attachRef, context.route);\n            }\n            else {\n                // otherwise the component defined in the configuration is created\n                this.activateWith(context.route, context.injector);\n            }\n        }\n    }\n    get isActivated() {\n        return !!this.activated;\n    }\n    /**\n     * @returns The currently activated component instance.\n     * @throws An error if the outlet is not activated.\n     */\n    get component() {\n        if (!this.activated)\n            throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n        return this.activated.instance;\n    }\n    get activatedRoute() {\n        if (!this.activated)\n            throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n        return this._activatedRoute;\n    }\n    get activatedRouteData() {\n        if (this._activatedRoute) {\n            return this._activatedRoute.snapshot.data;\n        }\n        return {};\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    detach() {\n        if (!this.activated)\n            throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n        this.location.detach();\n        const cmp = this.activated;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.detachEvents.emit(cmp.instance);\n        return cmp;\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    attach(ref, activatedRoute) {\n        this.activated = ref;\n        this._activatedRoute = activatedRoute;\n        this.location.insert(ref.hostView);\n        this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n        this.attachEvents.emit(ref.instance);\n    }\n    deactivate() {\n        if (this.activated) {\n            const c = this.component;\n            this.activated.destroy();\n            this.activated = null;\n            this._activatedRoute = null;\n            this.deactivateEvents.emit(c);\n        }\n    }\n    activateWith(activatedRoute, environmentInjector) {\n        if (this.isActivated) {\n            throw new _RuntimeError(4013 /* RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                'Cannot activate an already activated outlet');\n        }\n        this._activatedRoute = activatedRoute;\n        const location = this.location;\n        const snapshot = activatedRoute.snapshot;\n        const component = snapshot.component;\n        const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        const injector = new OutletInjector(activatedRoute, childContexts, location.injector, this.routerOutletData);\n        this.activated = location.createComponent(component, {\n            index: location.length,\n            injector,\n            environmentInjector: environmentInjector,\n        });\n        // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n        this.changeDetector.markForCheck();\n        this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n        this.activateEvents.emit(this.activated.instance);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RouterOutlet, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"17.1.0\", version: \"20.1.4\", type: RouterOutlet, isStandalone: true, selector: \"router-outlet\", inputs: { name: { classPropertyName: \"name\", publicName: \"name\", isSignal: false, isRequired: false, transformFunction: null }, routerOutletData: { classPropertyName: \"routerOutletData\", publicName: \"routerOutletData\", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { activateEvents: \"activate\", deactivateEvents: \"deactivate\", attachEvents: \"attach\", detachEvents: \"detach\" }, exportAs: [\"outlet\"], usesOnChanges: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RouterOutlet, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'router-outlet',\n                    exportAs: 'outlet',\n                }]\n        }], propDecorators: { name: [{\n                type: Input\n            }], activateEvents: [{\n                type: Output,\n                args: ['activate']\n            }], deactivateEvents: [{\n                type: Output,\n                args: ['deactivate']\n            }], attachEvents: [{\n                type: Output,\n                args: ['attach']\n            }], detachEvents: [{\n                type: Output,\n                args: ['detach']\n            }] } });\nclass OutletInjector {\n    route;\n    childContexts;\n    parent;\n    outletData;\n    constructor(route, childContexts, parent, outletData) {\n        this.route = route;\n        this.childContexts = childContexts;\n        this.parent = parent;\n        this.outletData = outletData;\n    }\n    get(token, notFoundValue) {\n        if (token === ActivatedRoute) {\n            return this.route;\n        }\n        if (token === ChildrenOutletContexts) {\n            return this.childContexts;\n        }\n        if (token === ROUTER_OUTLET_DATA) {\n            return this.outletData;\n        }\n        return this.parent.get(token, notFoundValue);\n    }\n}\nconst INPUT_BINDER = new InjectionToken('');\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\nclass RoutedComponentInputBinder {\n    outletDataSubscriptions = new Map();\n    bindActivatedRouteToOutletComponent(outlet) {\n        this.unsubscribeFromRouteData(outlet);\n        this.subscribeToRouteData(outlet);\n    }\n    unsubscribeFromRouteData(outlet) {\n        this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n        this.outletDataSubscriptions.delete(outlet);\n    }\n    subscribeToRouteData(outlet) {\n        const { activatedRoute } = outlet;\n        const dataSubscription = combineLatest([\n            activatedRoute.queryParams,\n            activatedRoute.params,\n            activatedRoute.data,\n        ])\n            .pipe(switchMap(([queryParams, params, data], index) => {\n            data = { ...queryParams, ...params, ...data };\n            // Get the first result from the data subscription synchronously so it's available to\n            // the component as soon as possible (and doesn't require a second change detection).\n            if (index === 0) {\n                return of(data);\n            }\n            // Promise.resolve is used to avoid synchronously writing the wrong data when\n            // two of the Observables in the `combineLatest` stream emit one after\n            // another.\n            return Promise.resolve(data);\n        }))\n            .subscribe((data) => {\n            // Outlet may have been deactivated or changed names to be associated with a different\n            // route\n            if (!outlet.isActivated ||\n                !outlet.activatedComponentRef ||\n                outlet.activatedRoute !== activatedRoute ||\n                activatedRoute.component === null) {\n                this.unsubscribeFromRouteData(outlet);\n                return;\n            }\n            const mirror = reflectComponentType(activatedRoute.component);\n            if (!mirror) {\n                this.unsubscribeFromRouteData(outlet);\n                return;\n            }\n            for (const { templateName } of mirror.inputs) {\n                outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n            }\n        });\n        this.outletDataSubscriptions.set(outlet, dataSubscription);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RoutedComponentInputBinder, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RoutedComponentInputBinder });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RoutedComponentInputBinder, decorators: [{\n            type: Injectable\n        }] });\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\nclass ɵEmptyOutletComponent {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: ɵEmptyOutletComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"20.1.4\", type: ɵEmptyOutletComponent, isStandalone: true, selector: \"ng-component\", exportAs: [\"emptyRouterOutlet\"], ngImport: i0, template: `<router-outlet/>`, isInline: true, dependencies: [{ kind: \"directive\", type: RouterOutlet, selector: \"router-outlet\", inputs: [\"name\", \"routerOutletData\"], outputs: [\"activate\", \"deactivate\", \"attach\", \"detach\"], exportAs: [\"outlet\"] }] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: ɵEmptyOutletComponent, decorators: [{\n            type: Component,\n            args: [{\n                    template: `<router-outlet/>`,\n                    imports: [RouterOutlet],\n                    // Used to avoid component ID collisions with user code.\n                    exportAs: 'emptyRouterOutlet',\n                }]\n        }] });\n/**\n * Makes a copy of the config and adds any default required properties.\n */\nfunction standardizeConfig(r) {\n    const children = r.children && r.children.map(standardizeConfig);\n    const c = children ? { ...r, children } : { ...r };\n    if (!c.component &&\n        !c.loadComponent &&\n        (children || c.loadChildren) &&\n        c.outlet &&\n        c.outlet !== PRIMARY_OUTLET) {\n        c.component = ɵEmptyOutletComponent;\n    }\n    return c;\n}\n\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n    const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n    return new RouterState(root, curr);\n}\nfunction createNode(routeReuseStrategy, curr, prevState) {\n    // reuse an activated route that is currently displayed on the screen\n    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n        const value = prevState.value;\n        value._futureSnapshot = curr.value;\n        const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n        return new TreeNode(value, children);\n    }\n    else {\n        if (routeReuseStrategy.shouldAttach(curr.value)) {\n            // retrieve an activated route that is used to be displayed, but is not currently displayed\n            const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n            if (detachedRouteHandle !== null) {\n                const tree = detachedRouteHandle.route;\n                tree.value._futureSnapshot = curr.value;\n                tree.children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n                return tree;\n            }\n        }\n        const value = createActivatedRoute(curr.value);\n        const children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n        return new TreeNode(value, children);\n    }\n}\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n    return curr.children.map((child) => {\n        for (const p of prevState.children) {\n            if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n                return createNode(routeReuseStrategy, child, p);\n            }\n        }\n        return createNode(routeReuseStrategy, child);\n    });\n}\nfunction createActivatedRoute(c) {\n    return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n\n/**\n * Can be returned by a `Router` guard to instruct the `Router` to redirect rather than continue\n * processing the path of the in-flight navigation. The `redirectTo` indicates _where_ the new\n * navigation should go to and the optional `navigationBehaviorOptions` can provide more information\n * about _how_ to perform the navigation.\n *\n * ```ts\n * const route: Route = {\n *   path: \"user/:userId\",\n *   component: User,\n *   canActivate: [\n *     () => {\n *       const router = inject(Router);\n *       const authService = inject(AuthenticationService);\n *\n *       if (!authService.isLoggedIn()) {\n *         const loginPath = router.parseUrl(\"/login\");\n *         return new RedirectCommand(loginPath, {\n *           skipLocationChange: true,\n *         });\n *       }\n *\n *       return true;\n *     },\n *   ],\n * };\n * ```\n * @see [Routing guide](guide/routing/common-router-tasks#preventing-unauthorized-access)\n *\n * @publicApi\n */\nclass RedirectCommand {\n    redirectTo;\n    navigationBehaviorOptions;\n    constructor(redirectTo, navigationBehaviorOptions) {\n        this.redirectTo = redirectTo;\n        this.navigationBehaviorOptions = navigationBehaviorOptions;\n    }\n}\n\nconst NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\nfunction redirectingNavigationError(urlSerializer, redirect) {\n    const { redirectTo, navigationBehaviorOptions } = isUrlTree(redirect)\n        ? { redirectTo: redirect, navigationBehaviorOptions: undefined }\n        : redirect;\n    const error = navigationCancelingError(ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`, NavigationCancellationCode.Redirect);\n    error.url = redirectTo;\n    error.navigationBehaviorOptions = navigationBehaviorOptions;\n    return error;\n}\nfunction navigationCancelingError(message, code) {\n    const error = new Error(`NavigationCancelingError: ${message || ''}`);\n    error[NAVIGATION_CANCELING_ERROR] = true;\n    error.cancellationCode = code;\n    return error;\n}\nfunction isRedirectingNavigationCancelingError(error) {\n    return (isNavigationCancelingError(error) &&\n        isUrlTree(error.url));\n}\nfunction isNavigationCancelingError(error) {\n    return !!error && error[NAVIGATION_CANCELING_ERROR];\n}\n\nlet warnedAboutUnsupportedInputBinding = false;\nconst activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t) => {\n    new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);\n    return t;\n});\nclass ActivateRoutes {\n    routeReuseStrategy;\n    futureState;\n    currState;\n    forwardEvent;\n    inputBindingEnabled;\n    constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {\n        this.routeReuseStrategy = routeReuseStrategy;\n        this.futureState = futureState;\n        this.currState = currState;\n        this.forwardEvent = forwardEvent;\n        this.inputBindingEnabled = inputBindingEnabled;\n    }\n    activate(parentContexts) {\n        const futureRoot = this.futureState._root;\n        const currRoot = this.currState ? this.currState._root : null;\n        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n        advanceActivatedRoute(this.futureState.root);\n        this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n    }\n    // De-activate the child route that are not re-used for the future state\n    deactivateChildRoutes(futureNode, currNode, contexts) {\n        const children = nodeChildrenAsMap(currNode);\n        // Recurse on the routes active in the future state to de-activate deeper children\n        futureNode.children.forEach((futureChild) => {\n            const childOutletName = futureChild.value.outlet;\n            this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n            delete children[childOutletName];\n        });\n        // De-activate the routes that will not be re-used\n        Object.values(children).forEach((v) => {\n            this.deactivateRouteAndItsChildren(v, contexts);\n        });\n    }\n    deactivateRoutes(futureNode, currNode, parentContext) {\n        const future = futureNode.value;\n        const curr = currNode ? currNode.value : null;\n        if (future === curr) {\n            // Reusing the node, check to see if the children need to be de-activated\n            if (future.component) {\n                // If we have a normal route, we need to go through an outlet.\n                const context = parentContext.getContext(future.outlet);\n                if (context) {\n                    this.deactivateChildRoutes(futureNode, currNode, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.deactivateChildRoutes(futureNode, currNode, parentContext);\n            }\n        }\n        else {\n            if (curr) {\n                // Deactivate the current route which will not be re-used\n                this.deactivateRouteAndItsChildren(currNode, parentContext);\n            }\n        }\n    }\n    deactivateRouteAndItsChildren(route, parentContexts) {\n        // If there is no component, the Route is never attached to an outlet (because there is no\n        // component to attach).\n        if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n            this.detachAndStoreRouteSubtree(route, parentContexts);\n        }\n        else {\n            this.deactivateRouteAndOutlet(route, parentContexts);\n        }\n    }\n    detachAndStoreRouteSubtree(route, parentContexts) {\n        const context = parentContexts.getContext(route.value.outlet);\n        const contexts = context && route.value.component ? context.children : parentContexts;\n        const children = nodeChildrenAsMap(route);\n        for (const treeNode of Object.values(children)) {\n            this.deactivateRouteAndItsChildren(treeNode, contexts);\n        }\n        if (context && context.outlet) {\n            const componentRef = context.outlet.detach();\n            const contexts = context.children.onOutletDeactivated();\n            this.routeReuseStrategy.store(route.value.snapshot, { componentRef, route, contexts });\n        }\n    }\n    deactivateRouteAndOutlet(route, parentContexts) {\n        const context = parentContexts.getContext(route.value.outlet);\n        // The context could be `null` if we are on a componentless route but there may still be\n        // children that need deactivating.\n        const contexts = context && route.value.component ? context.children : parentContexts;\n        const children = nodeChildrenAsMap(route);\n        for (const treeNode of Object.values(children)) {\n            this.deactivateRouteAndItsChildren(treeNode, contexts);\n        }\n        if (context) {\n            if (context.outlet) {\n                // Destroy the component\n                context.outlet.deactivate();\n                // Destroy the contexts for all the outlets that were in the component\n                context.children.onOutletDeactivated();\n            }\n            // Clear the information about the attached component on the context but keep the reference to\n            // the outlet. Clear even if outlet was not yet activated to avoid activating later with old\n            // info\n            context.attachRef = null;\n            context.route = null;\n        }\n    }\n    activateChildRoutes(futureNode, currNode, contexts) {\n        const children = nodeChildrenAsMap(currNode);\n        futureNode.children.forEach((c) => {\n            this.activateRoutes(c, children[c.value.outlet], contexts);\n            this.forwardEvent(new ActivationEnd(c.value.snapshot));\n        });\n        if (futureNode.children.length) {\n            this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n        }\n    }\n    activateRoutes(futureNode, currNode, parentContexts) {\n        const future = futureNode.value;\n        const curr = currNode ? currNode.value : null;\n        advanceActivatedRoute(future);\n        // reusing the node\n        if (future === curr) {\n            if (future.component) {\n                // If we have a normal route, we need to go through an outlet.\n                const context = parentContexts.getOrCreateContext(future.outlet);\n                this.activateChildRoutes(futureNode, currNode, context.children);\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, currNode, parentContexts);\n            }\n        }\n        else {\n            if (future.component) {\n                // if we have a normal route, we need to place the component into the outlet and recurse.\n                const context = parentContexts.getOrCreateContext(future.outlet);\n                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n                    const stored = (this.routeReuseStrategy.retrieve(future.snapshot));\n                    this.routeReuseStrategy.store(future.snapshot, null);\n                    context.children.onOutletReAttached(stored.contexts);\n                    context.attachRef = stored.componentRef;\n                    context.route = stored.route.value;\n                    if (context.outlet) {\n                        // Attach right away when the outlet has already been instantiated\n                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n                        context.outlet.attach(stored.componentRef, stored.route.value);\n                    }\n                    advanceActivatedRoute(stored.route.value);\n                    this.activateChildRoutes(futureNode, null, context.children);\n                }\n                else {\n                    context.attachRef = null;\n                    context.route = future;\n                    if (context.outlet) {\n                        // Activate the outlet when it has already been instantiated\n                        // Otherwise it will get activated from its `ngOnInit` when instantiated\n                        context.outlet.activateWith(future, context.injector);\n                    }\n                    this.activateChildRoutes(futureNode, null, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, null, parentContexts);\n            }\n        }\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const context = parentContexts.getOrCreateContext(future.outlet);\n            const outlet = context.outlet;\n            if (outlet &&\n                this.inputBindingEnabled &&\n                !outlet.supportsBindingToComponentInputs &&\n                !warnedAboutUnsupportedInputBinding) {\n                console.warn(`'withComponentInputBinding' feature is enabled but ` +\n                    `this application is using an outlet that may not support binding to component inputs.`);\n                warnedAboutUnsupportedInputBinding = true;\n            }\n        }\n    }\n}\n\nclass CanActivate {\n    path;\n    route;\n    constructor(path) {\n        this.path = path;\n        this.route = this.path[this.path.length - 1];\n    }\n}\nclass CanDeactivate {\n    component;\n    route;\n    constructor(component, route) {\n        this.component = component;\n        this.route = route;\n    }\n}\nfunction getAllRouteGuards(future, curr, parentContexts) {\n    const futureRoot = future._root;\n    const currRoot = curr ? curr._root : null;\n    return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\nfunction getCanActivateChild(p) {\n    const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n    if (!canActivateChild || canActivateChild.length === 0)\n        return null;\n    return { node: p, guards: canActivateChild };\n}\nfunction getTokenOrFunctionIdentity(tokenOrFunction, injector) {\n    const NOT_FOUND = Symbol();\n    const result = injector.get(tokenOrFunction, NOT_FOUND);\n    if (result === NOT_FOUND) {\n        if (typeof tokenOrFunction === 'function' && !_isInjectable(tokenOrFunction)) {\n            // We think the token is just a function so return it as-is\n            return tokenOrFunction;\n        }\n        else {\n            // This will throw the not found error\n            return injector.get(tokenOrFunction);\n        }\n    }\n    return result;\n}\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n}) {\n    const prevChildren = nodeChildrenAsMap(currNode);\n    // Process the children of the future route\n    futureNode.children.forEach((c) => {\n        getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n        delete prevChildren[c.value.outlet];\n    });\n    // Process any children left from the current route (not active for the future route)\n    Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));\n    return checks;\n}\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n}) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n    // reusing the node\n    if (curr && future.routeConfig === curr.routeConfig) {\n        const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);\n        if (shouldRun) {\n            checks.canActivateChecks.push(new CanActivate(futurePath));\n        }\n        else {\n            // we need to set the data\n            future.data = curr.data;\n            future._resolvedData = curr._resolvedData;\n        }\n        // If we have a component, we need to go through an outlet.\n        if (future.component) {\n            getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);\n            // if we have a componentless route, we recurse but keep the same outlet map.\n        }\n        else {\n            getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n        }\n        if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n            checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n        }\n    }\n    else {\n        if (curr) {\n            deactivateRouteAndItsChildren(currNode, context, checks);\n        }\n        checks.canActivateChecks.push(new CanActivate(futurePath));\n        // If we have a component, we need to go through an outlet.\n        if (future.component) {\n            getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n            // if we have a componentless route, we recurse but keep the same outlet map.\n        }\n        else {\n            getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n        }\n    }\n    return checks;\n}\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\n    if (typeof mode === 'function') {\n        return mode(curr, future);\n    }\n    switch (mode) {\n        case 'pathParamsChange':\n            return !equalPath(curr.url, future.url);\n        case 'pathParamsOrQueryParamsChange':\n            return (!equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams));\n        case 'always':\n            return true;\n        case 'paramsOrQueryParamsChange':\n            return (!equalParamsAndUrlSegments(curr, future) ||\n                !shallowEqual(curr.queryParams, future.queryParams));\n        case 'paramsChange':\n        default:\n            return !equalParamsAndUrlSegments(curr, future);\n    }\n}\nfunction deactivateRouteAndItsChildren(route, context, checks) {\n    const children = nodeChildrenAsMap(route);\n    const r = route.value;\n    Object.entries(children).forEach(([childName, node]) => {\n        if (!r.component) {\n            deactivateRouteAndItsChildren(node, context, checks);\n        }\n        else if (context) {\n            deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n        }\n        else {\n            deactivateRouteAndItsChildren(node, null, checks);\n        }\n    });\n    if (!r.component) {\n        checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n    }\n    else if (context && context.outlet && context.outlet.isActivated) {\n        checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n    }\n    else {\n        checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n    }\n}\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\nfunction isFunction(v) {\n    return typeof v === 'function';\n}\nfunction isBoolean(v) {\n    return typeof v === 'boolean';\n}\nfunction isCanLoad(guard) {\n    return guard && isFunction(guard.canLoad);\n}\nfunction isCanActivate(guard) {\n    return guard && isFunction(guard.canActivate);\n}\nfunction isCanActivateChild(guard) {\n    return guard && isFunction(guard.canActivateChild);\n}\nfunction isCanDeactivate(guard) {\n    return guard && isFunction(guard.canDeactivate);\n}\nfunction isCanMatch(guard) {\n    return guard && isFunction(guard.canMatch);\n}\nfunction isEmptyError(e) {\n    return e instanceof EmptyError || e?.name === 'EmptyError';\n}\n\nconst INITIAL_VALUE = /* @__PURE__ */ Symbol('INITIAL_VALUE');\nfunction prioritizedGuardValue() {\n    return switchMap((obs) => {\n        return combineLatest(obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {\n            for (const result of results) {\n                if (result === true) {\n                    // If result is true, check the next one\n                    continue;\n                }\n                else if (result === INITIAL_VALUE) {\n                    // If guard has not finished, we need to stop processing.\n                    return INITIAL_VALUE;\n                }\n                else if (result === false || isRedirect(result)) {\n                    // Result finished and was not true. Return the result.\n                    // Note that we only allow false/UrlTree/RedirectCommand. Other values are considered invalid and\n                    // ignored.\n                    return result;\n                }\n            }\n            // Everything resolved to true. Return true.\n            return true;\n        }), filter((item) => item !== INITIAL_VALUE), take(1));\n    });\n}\nfunction isRedirect(val) {\n    return isUrlTree(val) || val instanceof RedirectCommand;\n}\n\nfunction checkGuards(injector, forwardEvent) {\n    return mergeMap((t) => {\n        const { targetSnapshot, currentSnapshot, guards: { canActivateChecks, canDeactivateChecks }, } = t;\n        if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n            return of({ ...t, guardsResult: true });\n        }\n        return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {\n            return canDeactivate && isBoolean(canDeactivate)\n                ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent)\n                : of(canDeactivate);\n        }), map((guardsResult) => ({ ...t, guardsResult })));\n    });\n}\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {\n    return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first((result) => {\n        return result !== true;\n    }, true));\n}\nfunction runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {\n    return from(checks).pipe(concatMap((check) => {\n        return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));\n    }), first((result) => {\n        return result !== true;\n    }, true));\n}\n/**\n * This should fire off `ActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireActivationStart(snapshot, forwardEvent) {\n    if (snapshot !== null && forwardEvent) {\n        forwardEvent(new ActivationStart(snapshot));\n    }\n    return of(true);\n}\n/**\n * This should fire off `ChildActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireChildActivationStart(snapshot, forwardEvent) {\n    if (snapshot !== null && forwardEvent) {\n        forwardEvent(new ChildActivationStart(snapshot));\n    }\n    return of(true);\n}\nfunction runCanActivate(futureRSS, futureARS, injector) {\n    const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n    if (!canActivate || canActivate.length === 0)\n        return of(true);\n    const canActivateObservables = canActivate.map((canActivate) => {\n        return defer(() => {\n            const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n            const guard = getTokenOrFunctionIdentity(canActivate, closestInjector);\n            const guardVal = isCanActivate(guard)\n                ? guard.canActivate(futureARS, futureRSS)\n                : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n            return wrapIntoObservable(guardVal).pipe(first());\n        });\n    });\n    return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanActivateChild(futureRSS, path, injector) {\n    const futureARS = path[path.length - 1];\n    const canActivateChildGuards = path\n        .slice(0, path.length - 1)\n        .reverse()\n        .map((p) => getCanActivateChild(p))\n        .filter((_) => _ !== null);\n    const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {\n        return defer(() => {\n            const guardsMapped = d.guards.map((canActivateChild) => {\n                const closestInjector = getClosestRouteInjector(d.node) ?? injector;\n                const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);\n                const guardVal = isCanActivateChild(guard)\n                    ? guard.canActivateChild(futureARS, futureRSS)\n                    : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n                return wrapIntoObservable(guardVal).pipe(first());\n            });\n            return of(guardsMapped).pipe(prioritizedGuardValue());\n        });\n    });\n    return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {\n    const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n    if (!canDeactivate || canDeactivate.length === 0)\n        return of(true);\n    const canDeactivateObservables = canDeactivate.map((c) => {\n        const closestInjector = getClosestRouteInjector(currARS) ?? injector;\n        const guard = getTokenOrFunctionIdentity(c, closestInjector);\n        const guardVal = isCanDeactivate(guard)\n            ? guard.canDeactivate(component, currARS, currRSS, futureRSS)\n            : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));\n        return wrapIntoObservable(guardVal).pipe(first());\n    });\n    return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanLoadGuards(injector, route, segments, urlSerializer) {\n    const canLoad = route.canLoad;\n    if (canLoad === undefined || canLoad.length === 0) {\n        return of(true);\n    }\n    const canLoadObservables = canLoad.map((injectionToken) => {\n        const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n        const guardVal = isCanLoad(guard)\n            ? guard.canLoad(route, segments)\n            : runInInjectionContext(injector, () => guard(route, segments));\n        return wrapIntoObservable(guardVal);\n    });\n    return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nfunction redirectIfUrlTree(urlSerializer) {\n    return pipe(tap((result) => {\n        if (typeof result === 'boolean')\n            return;\n        throw redirectingNavigationError(urlSerializer, result);\n    }), map((result) => result === true));\n}\nfunction runCanMatchGuards(injector, route, segments, urlSerializer) {\n    const canMatch = route.canMatch;\n    if (!canMatch || canMatch.length === 0)\n        return of(true);\n    const canMatchObservables = canMatch.map((injectionToken) => {\n        const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n        const guardVal = isCanMatch(guard)\n            ? guard.canMatch(route, segments)\n            : runInInjectionContext(injector, () => guard(route, segments));\n        return wrapIntoObservable(guardVal);\n    });\n    return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n\nclass NoMatch {\n    segmentGroup;\n    constructor(segmentGroup) {\n        this.segmentGroup = segmentGroup || null;\n    }\n}\nclass AbsoluteRedirect extends Error {\n    urlTree;\n    constructor(urlTree) {\n        super();\n        this.urlTree = urlTree;\n    }\n}\nfunction noMatch$1(segmentGroup) {\n    return throwError(new NoMatch(segmentGroup));\n}\nfunction namedOutletsRedirect(redirectTo) {\n    return throwError(new _RuntimeError(4000 /* RuntimeErrorCode.NAMED_OUTLET_REDIRECT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));\n}\nfunction canLoadFails(route) {\n    return throwError(navigationCancelingError((typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`, NavigationCancellationCode.GuardRejected));\n}\nclass ApplyRedirects {\n    urlSerializer;\n    urlTree;\n    constructor(urlSerializer, urlTree) {\n        this.urlSerializer = urlSerializer;\n        this.urlTree = urlTree;\n    }\n    lineralizeSegments(route, urlTree) {\n        let res = [];\n        let c = urlTree.root;\n        while (true) {\n            res = res.concat(c.segments);\n            if (c.numberOfChildren === 0) {\n                return of(res);\n            }\n            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n                return namedOutletsRedirect(`${route.redirectTo}`);\n            }\n            c = c.children[PRIMARY_OUTLET];\n        }\n    }\n    applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {\n        return getRedirectResult(redirectTo, currentSnapshot, injector).pipe(map((redirect) => {\n            if (redirect instanceof UrlTree) {\n                throw new AbsoluteRedirect(redirect);\n            }\n            const newTree = this.applyRedirectCreateUrlTree(redirect, this.urlSerializer.parse(redirect), segments, posParams);\n            if (redirect[0] === '/') {\n                throw new AbsoluteRedirect(newTree);\n            }\n            return newTree;\n        }));\n    }\n    applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {\n        const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n    }\n    createQueryParams(redirectToParams, actualParams) {\n        const res = {};\n        Object.entries(redirectToParams).forEach(([k, v]) => {\n            const copySourceValue = typeof v === 'string' && v[0] === ':';\n            if (copySourceValue) {\n                const sourceName = v.substring(1);\n                res[k] = actualParams[sourceName];\n            }\n            else {\n                res[k] = v;\n            }\n        });\n        return res;\n    }\n    createSegmentGroup(redirectTo, group, segments, posParams) {\n        const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n        let children = {};\n        Object.entries(group.children).forEach(([name, child]) => {\n            children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n        });\n        return new UrlSegmentGroup(updatedSegments, children);\n    }\n    createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n        return redirectToSegments.map((s) => s.path[0] === ':'\n            ? this.findPosParam(redirectTo, s, posParams)\n            : this.findOrReturn(s, actualSegments));\n    }\n    findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n        const pos = posParams[redirectToUrlSegment.path.substring(1)];\n        if (!pos)\n            throw new _RuntimeError(4001 /* RuntimeErrorCode.MISSING_REDIRECT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n        return pos;\n    }\n    findOrReturn(redirectToUrlSegment, actualSegments) {\n        let idx = 0;\n        for (const s of actualSegments) {\n            if (s.path === redirectToUrlSegment.path) {\n                actualSegments.splice(idx);\n                return s;\n            }\n            idx++;\n        }\n        return redirectToUrlSegment;\n    }\n}\nfunction getRedirectResult(redirectTo, currentSnapshot, injector) {\n    if (typeof redirectTo === 'string') {\n        return of(redirectTo);\n    }\n    const redirectToFn = redirectTo;\n    const { queryParams, fragment, routeConfig, url, outlet, params, data, title } = currentSnapshot;\n    return wrapIntoObservable(runInInjectionContext(injector, () => redirectToFn({ params, data, queryParams, fragment, routeConfig, url, outlet, title })));\n}\n\nconst noMatch = {\n    matched: false,\n    consumedSegments: [],\n    remainingSegments: [],\n    parameters: {},\n    positionalParamSegments: {},\n};\nfunction matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {\n    const result = match(segmentGroup, route, segments);\n    if (!result.matched) {\n        return of(result);\n    }\n    // Only create the Route's `EnvironmentInjector` if it matches the attempted\n    // navigation\n    injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n    return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map((v) => (v === true ? result : { ...noMatch })));\n}\nfunction match(segmentGroup, route, segments) {\n    if (route.path === '**') {\n        return createWildcardMatchResult(segments);\n    }\n    if (route.path === '') {\n        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n            return { ...noMatch };\n        }\n        return {\n            matched: true,\n            consumedSegments: [],\n            remainingSegments: segments,\n            parameters: {},\n            positionalParamSegments: {},\n        };\n    }\n    const matcher = route.matcher || defaultUrlMatcher;\n    const res = matcher(segments, segmentGroup, route);\n    if (!res)\n        return { ...noMatch };\n    const posParams = {};\n    Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n        posParams[k] = v.path;\n    });\n    const parameters = res.consumed.length > 0\n        ? { ...posParams, ...res.consumed[res.consumed.length - 1].parameters }\n        : posParams;\n    return {\n        matched: true,\n        consumedSegments: res.consumed,\n        remainingSegments: segments.slice(res.consumed.length),\n        // TODO(atscott): investigate combining parameters and positionalParamSegments\n        parameters,\n        positionalParamSegments: res.posParams ?? {},\n    };\n}\nfunction createWildcardMatchResult(segments) {\n    return {\n        matched: true,\n        parameters: segments.length > 0 ? last(segments).parameters : {},\n        consumedSegments: segments,\n        remainingSegments: [],\n        positionalParamSegments: {},\n    };\n}\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n    if (slicedSegments.length > 0 &&\n        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n        const s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n        return { segmentGroup: s, slicedSegments: [] };\n    }\n    if (slicedSegments.length === 0 &&\n        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n        const s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n        return { segmentGroup: s, slicedSegments };\n    }\n    const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n    return { segmentGroup: s, slicedSegments };\n}\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n    const res = {};\n    for (const r of routes) {\n        if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n            const s = new UrlSegmentGroup([], {});\n            res[getOutlet(r)] = s;\n        }\n    }\n    return { ...children, ...res };\n}\nfunction createChildrenForEmptyPaths(routes, primarySegment) {\n    const res = {};\n    res[PRIMARY_OUTLET] = primarySegment;\n    for (const r of routes) {\n        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n            const s = new UrlSegmentGroup([], {});\n            res[getOutlet(r)] = s;\n        }\n    }\n    return res;\n}\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n    return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n    return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n        return false;\n    }\n    return r.path === '';\n}\nfunction noLeftoversInUrl(segmentGroup, segments, outlet) {\n    return segments.length === 0 && !segmentGroup.children[outlet];\n}\n\n/**\n * Class used to indicate there were no additional route config matches but that all segments of\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\n * try to match child configs in case there are empty path children.\n */\nclass NoLeftoversInUrl {\n}\nfunction recognize$1(injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = 'emptyOnly') {\n    return new Recognizer(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();\n}\nconst MAX_ALLOWED_REDIRECTS = 31;\nclass Recognizer {\n    injector;\n    configLoader;\n    rootComponentType;\n    config;\n    urlTree;\n    paramsInheritanceStrategy;\n    urlSerializer;\n    applyRedirects;\n    absoluteRedirectCount = 0;\n    allowRedirects = true;\n    constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer) {\n        this.injector = injector;\n        this.configLoader = configLoader;\n        this.rootComponentType = rootComponentType;\n        this.config = config;\n        this.urlTree = urlTree;\n        this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n        this.urlSerializer = urlSerializer;\n        this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n    }\n    noMatchError(e) {\n        return new _RuntimeError(4002 /* RuntimeErrorCode.NO_MATCH */, typeof ngDevMode === 'undefined' || ngDevMode\n            ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'`\n            : `'${e.segmentGroup}'`);\n    }\n    recognize() {\n        const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n        return this.match(rootSegmentGroup).pipe(map(({ children, rootSnapshot }) => {\n            const rootNode = new TreeNode(rootSnapshot, children);\n            const routeState = new RouterStateSnapshot('', rootNode);\n            const tree = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);\n            // https://github.com/angular/angular/issues/47307\n            // Creating the tree stringifies the query params\n            // We don't want to do this here so reassign them to the original.\n            tree.queryParams = this.urlTree.queryParams;\n            routeState.url = this.urlSerializer.serialize(tree);\n            return { state: routeState, tree };\n        }));\n    }\n    match(rootSegmentGroup) {\n        // Use Object.freeze to prevent readers of the Router state from modifying it outside\n        // of a navigation, resulting in the router being out of sync with the browser.\n        const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});\n        return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map((children) => {\n            return { children, rootSnapshot };\n        }), catchError((e) => {\n            if (e instanceof AbsoluteRedirect) {\n                this.urlTree = e.urlTree;\n                return this.match(e.urlTree.root);\n            }\n            if (e instanceof NoMatch) {\n                throw this.noMatchError(e);\n            }\n            throw e;\n        }));\n    }\n    processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return this.processChildren(injector, config, segmentGroup, parentRoute);\n        }\n        return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map((child) => (child instanceof TreeNode ? [child] : [])));\n    }\n    /**\n     * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n     * we cannot find a match for _any_ of the children.\n     *\n     * @param config - The `Routes` to match against\n     * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n     *     config.\n     */\n    processChildren(injector, config, segmentGroup, parentRoute) {\n        // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n        // because an absolute redirect from the primary outlet takes precedence.\n        const childOutlets = [];\n        for (const child of Object.keys(segmentGroup.children)) {\n            if (child === 'primary') {\n                childOutlets.unshift(child);\n            }\n            else {\n                childOutlets.push(child);\n            }\n        }\n        return from(childOutlets).pipe(concatMap((childOutlet) => {\n            const child = segmentGroup.children[childOutlet];\n            // Sort the config so that routes with outlets that match the one being activated\n            // appear first, followed by routes for other outlets, which might match if they have\n            // an empty path.\n            const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n            return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n        }), scan((children, outletChildren) => {\n            children.push(...outletChildren);\n            return children;\n        }), defaultIfEmpty(null), last$1(), mergeMap((children) => {\n            if (children === null)\n                return noMatch$1(segmentGroup);\n            // Because we may have matched two outlets to the same empty path segment, we can have\n            // multiple activated results for the same outlet. We should merge the children of\n            // these results so the final return value is only one `TreeNode` per outlet.\n            const mergedChildren = mergeEmptyPathMatches(children);\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                // This should really never happen - we are only taking the first match for each\n                // outlet and merge the empty path matches.\n                checkOutletNameUniqueness(mergedChildren);\n            }\n            sortActivatedRouteSnapshots(mergedChildren);\n            return of(mergedChildren);\n        }));\n    }\n    processSegment(injector, routes, segmentGroup, segments, outlet, allowRedirects, parentRoute) {\n        return from(routes).pipe(concatMap((r) => {\n            return this.processSegmentAgainstRoute(r._injector ?? injector, routes, r, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError((e) => {\n                if (e instanceof NoMatch) {\n                    return of(null);\n                }\n                throw e;\n            }));\n        }), first((x) => !!x), catchError((e) => {\n            if (isEmptyError(e)) {\n                if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n                    return of(new NoLeftoversInUrl());\n                }\n                return noMatch$1(segmentGroup);\n            }\n            throw e;\n        }));\n    }\n    processSegmentAgainstRoute(injector, routes, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {\n        // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n        // a config like\n        // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n        // or even\n        // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n        //\n        // The exception here is when the segment outlet is for the primary outlet. This would\n        // result in a match inside the named outlet because all children there are written as primary\n        // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n        // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n        // This should only match if the url is `/(x:b)`.\n        if (getOutlet(route) !== outlet &&\n            (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n            return noMatch$1(rawSegment);\n        }\n        if (route.redirectTo === undefined) {\n            return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);\n        }\n        if (this.allowRedirects && allowRedirects) {\n            return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes, route, segments, outlet, parentRoute);\n        }\n        return noMatch$1(rawSegment);\n    }\n    expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet, parentRoute) {\n        const { matched, parameters, consumedSegments, positionalParamSegments, remainingSegments } = match(segmentGroup, route, segments);\n        if (!matched)\n            return noMatch$1(segmentGroup);\n        // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\n        // size exceeded in production\n        if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n            this.absoluteRedirectCount++;\n            if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n                if (ngDevMode) {\n                    throw new _RuntimeError(4016 /* RuntimeErrorCode.INFINITE_REDIRECT */, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` +\n                        `This is currently a dev mode only error but will become a` +\n                        ` call stack size exceeded error in production in a future major version.`);\n                }\n                this.allowRedirects = false;\n            }\n        }\n        const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n        const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n        currentSnapshot.params = Object.freeze(inherited.params);\n        currentSnapshot.data = Object.freeze(inherited.data);\n        const newTree$ = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);\n        return newTree$.pipe(switchMap((newTree) => this.applyRedirects.lineralizeSegments(route, newTree)), mergeMap((newSegments) => {\n            return this.processSegment(injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);\n        }));\n    }\n    matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {\n        const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n        if (route.path === '**') {\n            // Prior versions of the route matching algorithm would stop matching at the wildcard route.\n            // We should investigate a better strategy for any existing children. Otherwise, these\n            // child segments are silently dropped from the navigation.\n            // https://github.com/angular/angular/issues/40089\n            rawSegment.children = {};\n        }\n        return matchResult.pipe(switchMap((result) => {\n            if (!result.matched) {\n                return noMatch$1(rawSegment);\n            }\n            // If the route has an injector created from providers, we should start using that.\n            injector = route._injector ?? injector;\n            return this.getChildConfig(injector, route, segments).pipe(switchMap(({ routes: childConfig }) => {\n                const childInjector = route._loadedInjector ?? injector;\n                const { parameters, consumedSegments, remainingSegments } = result;\n                const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n                const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n                snapshot.params = Object.freeze(inherited.params);\n                snapshot.data = Object.freeze(inherited.data);\n                const { segmentGroup, slicedSegments } = split(rawSegment, consumedSegments, remainingSegments, childConfig);\n                if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                    return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map((children) => {\n                        return new TreeNode(snapshot, children);\n                    }));\n                }\n                if (childConfig.length === 0 && slicedSegments.length === 0) {\n                    return of(new TreeNode(snapshot, []));\n                }\n                const matchedOnOutlet = getOutlet(route) === outlet;\n                // If we matched a config due to empty path match on a different outlet, we need to\n                // continue passing the current outlet for the segment rather than switch to PRIMARY.\n                // Note that we switch to primary when we have a match because outlet configs look like\n                // this: {path: 'a', outlet: 'a', children: [\n                //  {path: 'b', component: B},\n                //  {path: 'c', component: C},\n                // ]}\n                // Notice that the children of the named outlet are configured with the primary outlet\n                return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map((child) => {\n                    return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n                }));\n            }));\n        }));\n    }\n    getChildConfig(injector, route, segments) {\n        if (route.children) {\n            // The children belong to the same module\n            return of({ routes: route.children, injector });\n        }\n        if (route.loadChildren) {\n            // lazy children belong to the loaded module\n            if (route._loadedRoutes !== undefined) {\n                return of({ routes: route._loadedRoutes, injector: route._loadedInjector });\n            }\n            return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap((shouldLoadResult) => {\n                if (shouldLoadResult) {\n                    return this.configLoader.loadChildren(injector, route).pipe(tap((cfg) => {\n                        route._loadedRoutes = cfg.routes;\n                        route._loadedInjector = cfg.injector;\n                    }));\n                }\n                return canLoadFails(route);\n            }));\n        }\n        return of({ routes: [], injector });\n    }\n}\nfunction sortActivatedRouteSnapshots(nodes) {\n    nodes.sort((a, b) => {\n        if (a.value.outlet === PRIMARY_OUTLET)\n            return -1;\n        if (b.value.outlet === PRIMARY_OUTLET)\n            return 1;\n        return a.value.outlet.localeCompare(b.value.outlet);\n    });\n}\nfunction hasEmptyPathConfig(node) {\n    const config = node.value.routeConfig;\n    return config && config.path === '';\n}\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\nfunction mergeEmptyPathMatches(nodes) {\n    const result = [];\n    // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n    const mergedNodes = new Set();\n    for (const node of nodes) {\n        if (!hasEmptyPathConfig(node)) {\n            result.push(node);\n            continue;\n        }\n        const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);\n        if (duplicateEmptyPathNode !== undefined) {\n            duplicateEmptyPathNode.children.push(...node.children);\n            mergedNodes.add(duplicateEmptyPathNode);\n        }\n        else {\n            result.push(node);\n        }\n    }\n    // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n    // by also merging those children. This is necessary when there are multiple empty path configs\n    // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n    // if any of those children can be combined into a single node as well.\n    for (const mergedNode of mergedNodes) {\n        const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n        result.push(new TreeNode(mergedNode.value, mergedChildren));\n    }\n    return result.filter((n) => !mergedNodes.has(n));\n}\nfunction checkOutletNameUniqueness(nodes) {\n    const names = {};\n    nodes.forEach((n) => {\n        const routeWithSameOutletName = names[n.value.outlet];\n        if (routeWithSameOutletName) {\n            const p = routeWithSameOutletName.url.map((s) => s.toString()).join('/');\n            const c = n.value.url.map((s) => s.toString()).join('/');\n            throw new _RuntimeError(4006 /* RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n        }\n        names[n.value.outlet] = n.value;\n    });\n}\nfunction getData(route) {\n    return route.data || {};\n}\nfunction getResolve(route) {\n    return route.resolve || {};\n}\n\nfunction recognize(injector, configLoader, rootComponentType, config, serializer, paramsInheritanceStrategy) {\n    return mergeMap((t) => recognize$1(injector, configLoader, rootComponentType, config, t.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({ state: targetSnapshot, tree: urlAfterRedirects }) => {\n        return { ...t, targetSnapshot, urlAfterRedirects };\n    })));\n}\n\nfunction resolveData(paramsInheritanceStrategy, injector) {\n    return mergeMap((t) => {\n        const { targetSnapshot, guards: { canActivateChecks }, } = t;\n        if (!canActivateChecks.length) {\n            return of(t);\n        }\n        // Iterating a Set in javascript  happens in insertion order so it is safe to use a `Set` to\n        // preserve the correct order that the resolvers should run in.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#description\n        const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));\n        const routesNeedingDataUpdates = new Set();\n        for (const route of routesWithResolversToRun) {\n            if (routesNeedingDataUpdates.has(route)) {\n                continue;\n            }\n            // All children under the route with a resolver to run need to recompute inherited data.\n            for (const newRoute of flattenRouteTree(route)) {\n                routesNeedingDataUpdates.add(newRoute);\n            }\n        }\n        let routesProcessed = 0;\n        return from(routesNeedingDataUpdates).pipe(concatMap((route) => {\n            if (routesWithResolversToRun.has(route)) {\n                return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);\n            }\n            else {\n                route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n                return of(void 0);\n            }\n        }), tap(() => routesProcessed++), takeLast(1), mergeMap((_) => (routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY)));\n    });\n}\n/**\n *  Returns the `ActivatedRouteSnapshot` tree as an array, using DFS to traverse the route tree.\n */\nfunction flattenRouteTree(route) {\n    const descendants = route.children.map((child) => flattenRouteTree(child)).flat();\n    return [route, ...descendants];\n}\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {\n    const config = futureARS.routeConfig;\n    const resolve = futureARS._resolve;\n    if (config?.title !== undefined && !hasStaticTitle(config)) {\n        resolve[RouteTitleKey] = config.title;\n    }\n    return defer(() => {\n        futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n        return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {\n            futureARS._resolvedData = resolvedData;\n            futureARS.data = { ...futureARS.data, ...resolvedData };\n            return null;\n        }));\n    });\n}\nfunction resolveNode(resolve, futureARS, futureRSS, injector) {\n    const keys = getDataKeys(resolve);\n    if (keys.length === 0) {\n        return of({});\n    }\n    const data = {};\n    return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value) => {\n        if (value instanceof RedirectCommand) {\n            throw redirectingNavigationError(new DefaultUrlSerializer(), value);\n        }\n        data[key] = value;\n    }))), takeLast(1), map(() => data), catchError((e) => (isEmptyError(e) ? EMPTY : throwError(e))));\n}\nfunction getResolver(injectionToken, futureARS, futureRSS, injector) {\n    const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n    const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n    const resolverValue = resolver.resolve\n        ? resolver.resolve(futureARS, futureRSS)\n        : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\n    return wrapIntoObservable(resolverValue);\n}\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nfunction switchTap(next) {\n    return switchMap((v) => {\n        const nextResult = next(v);\n        if (nextResult) {\n            return from(nextResult).pipe(map(() => v));\n        }\n        return of(v);\n    });\n}\n\n/**\n * Provides a strategy for setting the page title after a router navigation.\n *\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\n * outlet with `title` property. Given the `Routes` below, navigating to\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\n * ```ts\n * [\n *   {path: 'base', title: 'base', children: [\n *     {path: 'child', title: 'child'},\n *   ],\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\n * ]\n * ```\n *\n * This class can be used as a base class for custom title strategies. That is, you can create your\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\n * from the named outlet is never used. However, a custom strategy might be implemented to\n * incorporate titles in named outlets.\n *\n * @publicApi\n * @see [Page title guide](guide/routing/common-router-tasks#setting-the-page-title)\n */\nclass TitleStrategy {\n    /**\n     * @returns The `title` of the deepest primary route.\n     */\n    buildTitle(snapshot) {\n        let pageTitle;\n        let route = snapshot.root;\n        while (route !== undefined) {\n            pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n            route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);\n        }\n        return pageTitle;\n    }\n    /**\n     * Given an `ActivatedRouteSnapshot`, returns the final value of the\n     * `Route.title` property, which can either be a static string or a resolved value.\n     */\n    getResolvedTitleForRoute(snapshot) {\n        return snapshot.data[RouteTitleKey];\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: TitleStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: TitleStrategy, providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy) });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: TitleStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy) }]\n        }] });\n/**\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\n */\nclass DefaultTitleStrategy extends TitleStrategy {\n    title;\n    constructor(title) {\n        super();\n        this.title = title;\n    }\n    /**\n     * Sets the title of the browser to the given value.\n     *\n     * @param title The `pageTitle` from the deepest primary route.\n     */\n    updateTitle(snapshot) {\n        const title = this.buildTitle(snapshot);\n        if (title !== undefined) {\n            this.title.setTitle(title);\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DefaultTitleStrategy, deps: [{ token: i1.Title }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DefaultTitleStrategy, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DefaultTitleStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.Title }] });\n\n/**\n * A DI token for the router service.\n *\n * @publicApi\n */\nconst ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '', {\n    providedIn: 'root',\n    factory: () => ({}),\n});\n\n/**\n * The DI token for a router configuration.\n *\n * `ROUTES` is a low level API for router configuration via dependency injection.\n *\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\n * `provideRouter`, or `Router.resetConfig()`.\n *\n * @publicApi\n */\nconst ROUTES = new InjectionToken(ngDevMode ? 'ROUTES' : '');\nclass RouterConfigLoader {\n    componentLoaders = new WeakMap();\n    childrenLoaders = new WeakMap();\n    onLoadStartListener;\n    onLoadEndListener;\n    compiler = inject(Compiler);\n    loadComponent(injector, route) {\n        if (this.componentLoaders.get(route)) {\n            return this.componentLoaders.get(route);\n        }\n        else if (route._loadedComponent) {\n            return of(route._loadedComponent);\n        }\n        if (this.onLoadStartListener) {\n            this.onLoadStartListener(route);\n        }\n        const loadRunner = wrapIntoObservable(runInInjectionContext(injector, () => route.loadComponent())).pipe(map(maybeUnwrapDefaultExport), tap((component) => {\n            if (this.onLoadEndListener) {\n                this.onLoadEndListener(route);\n            }\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                assertStandalone(route.path ?? '', component);\n            route._loadedComponent = component;\n        }), finalize(() => {\n            this.componentLoaders.delete(route);\n        }));\n        // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\n        this.componentLoaders.set(route, loader);\n        return loader;\n    }\n    loadChildren(parentInjector, route) {\n        if (this.childrenLoaders.get(route)) {\n            return this.childrenLoaders.get(route);\n        }\n        else if (route._loadedRoutes) {\n            return of({ routes: route._loadedRoutes, injector: route._loadedInjector });\n        }\n        if (this.onLoadStartListener) {\n            this.onLoadStartListener(route);\n        }\n        const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);\n        const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {\n            this.childrenLoaders.delete(route);\n        }));\n        // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\n        this.childrenLoaders.set(route, loader);\n        return loader;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RouterConfigLoader, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RouterConfigLoader, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RouterConfigLoader, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/**\n * Executes a `route.loadChildren` callback and converts the result to an array of child routes and\n * an injector if that callback returned a module.\n *\n * This function is used for the route discovery during prerendering\n * in @angular-devkit/build-angular. If there are any updates to the contract here, it will require\n * an update to the extractor.\n */\nfunction loadChildren(route, compiler, parentInjector, onLoadEndListener) {\n    return wrapIntoObservable(runInInjectionContext(parentInjector, () => route.loadChildren())).pipe(map(maybeUnwrapDefaultExport), mergeMap((t) => {\n        if (t instanceof NgModuleFactory || Array.isArray(t)) {\n            return of(t);\n        }\n        else {\n            return from(compiler.compileModuleAsync(t));\n        }\n    }), map((factoryOrRoutes) => {\n        if (onLoadEndListener) {\n            onLoadEndListener(route);\n        }\n        // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is\n        // no injector associated with lazy loading a `Route` array.\n        let injector;\n        let rawRoutes;\n        let requireStandaloneComponents = false;\n        if (Array.isArray(factoryOrRoutes)) {\n            rawRoutes = factoryOrRoutes;\n            requireStandaloneComponents = true;\n        }\n        else {\n            injector = factoryOrRoutes.create(parentInjector).injector;\n            // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n            // will get stuck in an infinite loop. The child module's Injector will look to\n            // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n            // for it's parent module instead.\n            rawRoutes = injector.get(ROUTES, [], { optional: true, self: true }).flat();\n        }\n        const routes = rawRoutes.map(standardizeConfig);\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            validateConfig(routes, route.path, requireStandaloneComponents);\n        return { routes, injector };\n    }));\n}\nfunction isWrappedDefaultExport(value) {\n    // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be\n    // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that\n    // `default` will be a renamed property.\n    return value && typeof value === 'object' && 'default' in value;\n}\nfunction maybeUnwrapDefaultExport(input) {\n    // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not\n    // subject to property renaming, so we reference it with bracket access.\n    return isWrappedDefaultExport(input) ? input['default'] : input;\n}\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\nclass UrlHandlingStrategy {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: UrlHandlingStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: UrlHandlingStrategy, providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy) });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: UrlHandlingStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy) }]\n        }] });\n/**\n * @publicApi\n */\nclass DefaultUrlHandlingStrategy {\n    shouldProcessUrl(url) {\n        return true;\n    }\n    extract(url) {\n        return url;\n    }\n    merge(newUrlPart, wholeUrl) {\n        return newUrlPart;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DefaultUrlHandlingStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DefaultUrlHandlingStrategy, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DefaultUrlHandlingStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nconst CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? 'view transition helper' : '');\nconst VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? 'view transition options' : '');\n/**\n * A helper function for using browser view transitions. This function skips the call to\n * `startViewTransition` if the browser does not support it.\n *\n * @returns A Promise that resolves when the view transition callback begins.\n */\nfunction createViewTransition(injector, from, to) {\n    const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n    const document = injector.get(DOCUMENT);\n    if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n        transitionOptions.skipNextTransition = false;\n        // The timing of `startViewTransition` is closer to a macrotask. It won't be called\n        // until the current event loop exits so we use a promise resolved in a timeout instead\n        // of Promise.resolve().\n        return new Promise((resolve) => setTimeout(resolve));\n    }\n    let resolveViewTransitionStarted;\n    const viewTransitionStarted = new Promise((resolve) => {\n        resolveViewTransitionStarted = resolve;\n    });\n    const transition = document.startViewTransition(() => {\n        resolveViewTransitionStarted();\n        // We don't actually update dom within the transition callback. The resolving of the above\n        // promise unblocks the Router navigation, which synchronously activates and deactivates\n        // routes (the DOM update). This view transition waits for the next change detection to\n        // complete (below), which includes the update phase of the routed components.\n        return createRenderPromise(injector);\n    });\n    transition.ready.catch((error) => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            console.error(error);\n        }\n    });\n    const { onViewTransitionCreated } = transitionOptions;\n    if (onViewTransitionCreated) {\n        runInInjectionContext(injector, () => onViewTransitionCreated({ transition, from, to }));\n    }\n    return viewTransitionStarted;\n}\n/**\n * Creates a promise that resolves after next render.\n */\nfunction createRenderPromise(injector) {\n    return new Promise((resolve) => {\n        // Wait for the microtask queue to empty after the next render happens (by waiting a macrotask).\n        // This ensures any follow-up renders in the microtask queue are completed before the\n        // view transition starts animating.\n        afterNextRender({ read: () => setTimeout(resolve) }, { injector });\n    });\n}\n\nconst NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');\nclass NavigationTransitions {\n    currentNavigation = null;\n    currentTransition = null;\n    lastSuccessfulNavigation = null;\n    /**\n     * These events are used to communicate back to the Router about the state of the transition. The\n     * Router wants to respond to these events in various ways. Because the `NavigationTransition`\n     * class is not public, this event subject is not publicly exposed.\n     */\n    events = new Subject();\n    /**\n     * Used to abort the current transition with an error.\n     */\n    transitionAbortWithErrorSubject = new Subject();\n    configLoader = inject(RouterConfigLoader);\n    environmentInjector = inject(EnvironmentInjector);\n    destroyRef = inject(DestroyRef);\n    urlSerializer = inject(UrlSerializer);\n    rootContexts = inject(ChildrenOutletContexts);\n    location = inject(Location);\n    inputBindingEnabled = inject(INPUT_BINDER, { optional: true }) !== null;\n    titleStrategy = inject(TitleStrategy);\n    options = inject(ROUTER_CONFIGURATION, { optional: true }) || {};\n    paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || 'emptyOnly';\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    createViewTransition = inject(CREATE_VIEW_TRANSITION, { optional: true });\n    navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, { optional: true });\n    navigationId = 0;\n    get hasRequestedNavigation() {\n        return this.navigationId !== 0;\n    }\n    transitions;\n    /**\n     * Hook that enables you to pause navigation after the preactivation phase.\n     * Used by `RouterModule`.\n     *\n     * @internal\n     */\n    afterPreactivation = () => of(void 0);\n    /** @internal */\n    rootComponentType = null;\n    destroyed = false;\n    constructor() {\n        const onLoadStart = (r) => this.events.next(new RouteConfigLoadStart(r));\n        const onLoadEnd = (r) => this.events.next(new RouteConfigLoadEnd(r));\n        this.configLoader.onLoadEndListener = onLoadEnd;\n        this.configLoader.onLoadStartListener = onLoadStart;\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    complete() {\n        this.transitions?.complete();\n    }\n    handleNavigationRequest(request) {\n        const id = ++this.navigationId;\n        this.transitions?.next({\n            ...request,\n            extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\n            targetSnapshot: null,\n            targetRouterState: null,\n            guards: { canActivateChecks: [], canDeactivateChecks: [] },\n            guardsResult: null,\n            abortController: new AbortController(),\n            id,\n        });\n    }\n    setupNavigations(router) {\n        this.transitions = new BehaviorSubject(null);\n        return this.transitions.pipe(filter((t) => t !== null), \n        // Using switchMap so we cancel executing navigations when a new one comes in\n        switchMap((overallTransitionState) => {\n            let completedOrAborted = false;\n            return of(overallTransitionState).pipe(switchMap((t) => {\n                // It is possible that `switchMap` fails to cancel previous navigations if a new one happens synchronously while the operator\n                // is processing the `next` notification of that previous navigation. This can happen when a new navigation (say 2) cancels a\n                // previous one (1) and yet another navigation (3) happens synchronously in response to the `NavigationCancel` event for (1).\n                // https://github.com/ReactiveX/rxjs/issues/7455\n                if (this.navigationId > overallTransitionState.id) {\n                    const cancellationReason = typeof ngDevMode === 'undefined' || ngDevMode\n                        ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                        : '';\n                    this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);\n                    return EMPTY;\n                }\n                this.currentTransition = overallTransitionState;\n                // Store the Navigation object\n                this.currentNavigation = {\n                    id: t.id,\n                    initialUrl: t.rawUrl,\n                    extractedUrl: t.extractedUrl,\n                    targetBrowserUrl: typeof t.extras.browserUrl === 'string'\n                        ? this.urlSerializer.parse(t.extras.browserUrl)\n                        : t.extras.browserUrl,\n                    trigger: t.source,\n                    extras: t.extras,\n                    previousNavigation: !this.lastSuccessfulNavigation\n                        ? null\n                        : {\n                            ...this.lastSuccessfulNavigation,\n                            previousNavigation: null,\n                        },\n                    abort: () => t.abortController.abort(),\n                };\n                const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n                const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n                if (!urlTransition && onSameUrlNavigation !== 'reload') {\n                    const reason = typeof ngDevMode === 'undefined' || ngDevMode\n                        ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.`\n                        : '';\n                    this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));\n                    t.resolve(false);\n                    return EMPTY;\n                }\n                if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n                    return of(t).pipe(\n                    // Fire NavigationStart event\n                    switchMap((t) => {\n                        this.events.next(new NavigationStart(t.id, this.urlSerializer.serialize(t.extractedUrl), t.source, t.restoredState));\n                        if (t.id !== this.navigationId) {\n                            return EMPTY;\n                        }\n                        // This delay is required to match old behavior that forced\n                        // navigation to always be async\n                        return Promise.resolve(t);\n                    }), \n                    // Recognize\n                    recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy), \n                    // Update URL if in `eager` update mode\n                    tap((t) => {\n                        overallTransitionState.targetSnapshot = t.targetSnapshot;\n                        overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n                        this.currentNavigation = {\n                            ...this.currentNavigation,\n                            finalUrl: t.urlAfterRedirects,\n                        };\n                        // Fire RoutesRecognized\n                        const routesRecognized = new RoutesRecognized(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n                        this.events.next(routesRecognized);\n                    }));\n                }\n                else if (urlTransition &&\n                    this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {\n                    /* When the current URL shouldn't be processed, but the previous one\n                     * was, we handle this \"error condition\" by navigating to the\n                     * previously successful URL, but leaving the URL intact.*/\n                    const { id, extractedUrl, source, restoredState, extras } = t;\n                    const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);\n                    this.events.next(navStart);\n                    const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;\n                    this.currentTransition = overallTransitionState = {\n                        ...t,\n                        targetSnapshot,\n                        urlAfterRedirects: extractedUrl,\n                        extras: { ...extras, skipLocationChange: false, replaceUrl: false },\n                    };\n                    this.currentNavigation.finalUrl = extractedUrl;\n                    return of(overallTransitionState);\n                }\n                else {\n                    /* When neither the current or previous URL can be processed, do\n                     * nothing other than update router's internal reference to the\n                     * current \"settled\" URL. This way the next navigation will be coming\n                     * from the current URL in the browser.\n                     */\n                    const reason = typeof ngDevMode === 'undefined' || ngDevMode\n                        ? `Navigation was ignored because the UrlHandlingStrategy` +\n                            ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.`\n                        : '';\n                    this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));\n                    t.resolve(false);\n                    return EMPTY;\n                }\n            }), \n            // --- GUARDS ---\n            tap((t) => {\n                const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n                this.events.next(guardsStart);\n            }), map((t) => {\n                this.currentTransition = overallTransitionState = {\n                    ...t,\n                    guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts),\n                };\n                return overallTransitionState;\n            }), checkGuards(this.environmentInjector, (evt) => this.events.next(evt)), tap((t) => {\n                overallTransitionState.guardsResult = t.guardsResult;\n                if (t.guardsResult && typeof t.guardsResult !== 'boolean') {\n                    throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n                }\n                const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);\n                this.events.next(guardsEnd);\n            }), filter((t) => {\n                if (!t.guardsResult) {\n                    this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);\n                    return false;\n                }\n                return true;\n            }), \n            // --- RESOLVE ---\n            switchTap((t) => {\n                if (t.guards.canActivateChecks.length === 0) {\n                    return undefined;\n                }\n                return of(t).pipe(tap((t) => {\n                    const resolveStart = new ResolveStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n                    this.events.next(resolveStart);\n                }), switchMap((t) => {\n                    let dataResolved = false;\n                    return of(t).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({\n                        next: () => (dataResolved = true),\n                        complete: () => {\n                            if (!dataResolved) {\n                                this.cancelNavigationTransition(t, typeof ngDevMode === 'undefined' || ngDevMode\n                                    ? `At least one route resolver didn't emit any value.`\n                                    : '', NavigationCancellationCode.NoDataFromResolver);\n                            }\n                        },\n                    }));\n                }), tap((t) => {\n                    const resolveEnd = new ResolveEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n                    this.events.next(resolveEnd);\n                }));\n            }), \n            // --- LOAD COMPONENTS ---\n            switchTap((t) => {\n                const loadComponents = (route) => {\n                    const loaders = [];\n                    if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {\n                        const injector = getClosestRouteInjector(route) ?? this.environmentInjector;\n                        loaders.push(this.configLoader.loadComponent(injector, route.routeConfig).pipe(tap((loadedComponent) => {\n                            route.component = loadedComponent;\n                        }), map(() => void 0)));\n                    }\n                    for (const child of route.children) {\n                        loaders.push(...loadComponents(child));\n                    }\n                    return loaders;\n                };\n                return combineLatest(loadComponents(t.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));\n            }), switchTap(() => this.afterPreactivation()), switchMap(() => {\n                const { currentSnapshot, targetSnapshot } = overallTransitionState;\n                const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);\n                // If view transitions are enabled, block the navigation until the view\n                // transition callback starts. Otherwise, continue immediately.\n                return viewTransitionStarted\n                    ? from(viewTransitionStarted).pipe(map(() => overallTransitionState))\n                    : of(overallTransitionState);\n            }), map((t) => {\n                const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);\n                this.currentTransition = overallTransitionState = { ...t, targetRouterState };\n                this.currentNavigation.targetRouterState = targetRouterState;\n                return overallTransitionState;\n            }), tap(() => {\n                this.events.next(new BeforeActivateRoutes());\n            }), activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled), \n            // Ensure that if some observable used to drive the transition doesn't\n            // complete, the navigation still finalizes This should never happen, but\n            // this is done as a safety measure to avoid surfacing this error (#49567).\n            take(1), takeUntil(new Observable((subscriber) => {\n                const abortSignal = overallTransitionState.abortController.signal;\n                const handler = () => subscriber.next();\n                abortSignal.addEventListener('abort', handler);\n                return () => abortSignal.removeEventListener('abort', handler);\n            }).pipe(\n            // Ignore aborts if we are already completed, canceled, or are in the activation stage (we have targetRouterState)\n            filter(() => !completedOrAborted && !overallTransitionState.targetRouterState), tap(() => {\n                this.cancelNavigationTransition(overallTransitionState, overallTransitionState.abortController.signal.reason + '', NavigationCancellationCode.Aborted);\n            }))), tap({\n                next: (t) => {\n                    completedOrAborted = true;\n                    this.lastSuccessfulNavigation = this.currentNavigation;\n                    this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));\n                    this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);\n                    t.resolve(true);\n                },\n                complete: () => {\n                    completedOrAborted = true;\n                },\n            }), \n            // There used to be a lot more logic happening directly within the\n            // transition Observable. Some of this logic has been refactored out to\n            // other places but there may still be errors that happen there. This gives\n            // us a way to cancel the transition from the outside. This may also be\n            // required in the future to support something like the abort signal of the\n            // Navigation API where the navigation gets aborted from outside the\n            // transition.\n            takeUntil(this.transitionAbortWithErrorSubject.pipe(tap((err) => {\n                throw err;\n            }))), finalize(() => {\n                /* When the navigation stream finishes either through error or success,\n                 * we set the `completed` or `errored` flag. However, there are some\n                 * situations where we could get here without either of those being set.\n                 * For instance, a redirect during NavigationStart. Therefore, this is a\n                 * catch-all to make sure the NavigationCancel event is fired when a\n                 * navigation gets cancelled but not caught by other means. */\n                if (!completedOrAborted) {\n                    const cancelationReason = typeof ngDevMode === 'undefined' || ngDevMode\n                        ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                        : '';\n                    this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);\n                }\n                // Only clear current navigation if it is still set to the one that\n                // finalized.\n                if (this.currentTransition?.id === overallTransitionState.id) {\n                    this.currentNavigation = null;\n                    this.currentTransition = null;\n                }\n            }), catchError((e) => {\n                // If the application is already destroyed, the catch block should not\n                // execute anything in practice because other resources have already\n                // been released and destroyed.\n                if (this.destroyed) {\n                    overallTransitionState.resolve(false);\n                    return EMPTY;\n                }\n                completedOrAborted = true;\n                /* This error type is issued during Redirect, and is handled as a\n                 * cancellation rather than an error. */\n                if (isNavigationCancelingError(e)) {\n                    this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));\n                    // When redirecting, we need to delay resolving the navigation\n                    // promise and push it to the redirect navigation\n                    if (!isRedirectingNavigationCancelingError(e)) {\n                        overallTransitionState.resolve(false);\n                    }\n                    else {\n                        this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\n                    }\n                    /* All other errors should reset to the router's internal URL reference\n                     * to the pre-error state. */\n                }\n                else {\n                    const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? undefined);\n                    try {\n                        const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));\n                        if (navigationErrorHandlerResult instanceof RedirectCommand) {\n                            const { message, cancellationCode } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);\n                            this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));\n                            this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));\n                        }\n                        else {\n                            this.events.next(navigationError);\n                            throw e;\n                        }\n                    }\n                    catch (ee) {\n                        // TODO(atscott): consider flipping the default behavior of\n                        // resolveNavigationPromiseOnError to be `resolve(false)` when\n                        // undefined. This is the most sane thing to do given that\n                        // applications very rarely handle the promise rejection and, as a\n                        // result, would get \"unhandled promise rejection\" console logs.\n                        // The vast majority of applications would not be affected by this\n                        // change so omitting a migration seems reasonable. Instead,\n                        // applications that rely on rejection can specifically opt-in to the\n                        // old behavior.\n                        if (this.options.resolveNavigationPromiseOnError) {\n                            overallTransitionState.resolve(false);\n                        }\n                        else {\n                            overallTransitionState.reject(ee);\n                        }\n                    }\n                }\n                return EMPTY;\n            }));\n            // casting because `pipe` returns observable({}) when called with 8+ arguments\n        }));\n    }\n    cancelNavigationTransition(t, reason, code) {\n        const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);\n        this.events.next(navCancel);\n        t.resolve(false);\n    }\n    /**\n     * @returns Whether we're navigating to somewhere that is not what the Router is\n     * currently set to.\n     */\n    isUpdatingInternalState() {\n        // TODO(atscott): The serializer should likely be used instead of\n        // `UrlTree.toString()`. Custom serializers are often written to handle\n        // things better than the default one (objects, for example will be\n        // [Object object] with the custom serializer and be \"the same\" when they\n        // aren't).\n        // (Same for isUpdatedBrowserUrl)\n        return (this.currentTransition?.extractedUrl.toString() !==\n            this.currentTransition?.currentUrlTree.toString());\n    }\n    /**\n     * @returns Whether we're updating the browser URL to something new (navigation is going\n     * to somewhere not displayed in the URL bar and we will update the URL\n     * bar if navigation succeeds).\n     */\n    isUpdatedBrowserUrl() {\n        // The extracted URL is the part of the URL that this application cares about. `extract` may\n        // return only part of the browser URL and that part may have not changed even if some other\n        // portion of the URL did.\n        const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));\n        const targetBrowserUrl = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;\n        return (currentBrowserUrl.toString() !== targetBrowserUrl?.toString() &&\n            !this.currentNavigation?.extras.skipLocationChange);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: NavigationTransitions, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: NavigationTransitions, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: NavigationTransitions, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\nfunction isBrowserTriggeredNavigation(source) {\n    return source !== IMPERATIVE_NAVIGATION;\n}\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\nclass RouteReuseStrategy {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RouteReuseStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RouteReuseStrategy, providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy) });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: RouteReuseStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy) }]\n        }] });\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the route parameters, query parameters or fragment change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nclass BaseRouteReuseStrategy {\n    /**\n     * Whether the given route should detach for later reuse.\n     * Always returns false for `BaseRouteReuseStrategy`.\n     * */\n    shouldDetach(route) {\n        return false;\n    }\n    /**\n     * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n     */\n    store(route, detachedTree) { }\n    /** Returns `false`, meaning the route (and its subtree) is never reattached */\n    shouldAttach(route) {\n        return false;\n    }\n    /** Returns `null` because this strategy does not store routes for later re-use. */\n    retrieve(route) {\n        return null;\n    }\n    /**\n     * Determines if a route should be reused.\n     * This strategy returns `true` when the future route config and current route config are\n     * identical.\n     */\n    shouldReuseRoute(future, curr) {\n        return future.routeConfig === curr.routeConfig;\n    }\n}\nclass DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DefaultRouteReuseStrategy, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DefaultRouteReuseStrategy, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: DefaultRouteReuseStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nclass StateManager {\n    urlSerializer = inject(UrlSerializer);\n    options = inject(ROUTER_CONFIGURATION, { optional: true }) || {};\n    canceledNavigationResolution = this.options.canceledNavigationResolution || 'replace';\n    location = inject(Location);\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n    currentUrlTree = new UrlTree();\n    /**\n     * Returns the currently activated `UrlTree`.\n     *\n     * This `UrlTree` shows only URLs that the `Router` is configured to handle (through\n     * `UrlHandlingStrategy`).\n     *\n     * The value is set after finding the route config tree to activate but before activating the\n     * route.\n     */\n    getCurrentUrlTree() {\n        return this.currentUrlTree;\n    }\n    rawUrlTree = this.currentUrlTree;\n    /**\n     * Returns a `UrlTree` that is represents what the browser is actually showing.\n     *\n     * In the life of a navigation transition:\n     * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being\n     * navigated to.\n     * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due\n     * to `UrlHandlingStrategy`).\n     * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the\n     * original raw URL.\n     *\n     * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and\n     * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not\n     * deviated from the raw `UrlTree`.\n     *\n     * For `extract`, a raw `UrlTree` is needed because `extract` may only return part\n     * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser\n     * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation\n     * occurs, it needs to know the _whole_ browser URL, not just the part handled by\n     * `UrlHandlingStrategy`.\n     * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but\n     * still updates the raw `UrlTree` with the assumption that the navigation was caused by the\n     * location change listener due to a URL update by the AngularJS router. In this case, the router\n     * still need to know what the browser's URL is for future navigations.\n     */\n    getRawUrlTree() {\n        return this.rawUrlTree;\n    }\n    createBrowserPath({ finalUrl, initialUrl, targetBrowserUrl }) {\n        const rawUrl = finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;\n        const url = targetBrowserUrl ?? rawUrl;\n        const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n        return path;\n    }\n    commitTransition({ targetRouterState, finalUrl, initialUrl }) {\n        // If we are committing the transition after having a final URL and target state, we're updating\n        // all pieces of the state. Otherwise, we likely skipped the transition (due to URL handling strategy)\n        // and only want to update the rawUrlTree, which represents the browser URL (and doesn't necessarily match router state).\n        if (finalUrl && targetRouterState) {\n            this.currentUrlTree = finalUrl;\n            this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);\n            this.routerState = targetRouterState;\n        }\n        else {\n            this.rawUrlTree = initialUrl;\n        }\n    }\n    routerState = createEmptyState(null);\n    /** Returns the current RouterState. */\n    getRouterState() {\n        return this.routerState;\n    }\n    stateMemento = this.createStateMemento();\n    updateStateMemento() {\n        this.stateMemento = this.createStateMemento();\n    }\n    createStateMemento() {\n        return {\n            rawUrlTree: this.rawUrlTree,\n            currentUrlTree: this.currentUrlTree,\n            routerState: this.routerState,\n        };\n    }\n    resetInternalState({ finalUrl }) {\n        this.routerState = this.stateMemento.routerState;\n        this.currentUrlTree = this.stateMemento.currentUrlTree;\n        // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\n        // configured to handle only part of the navigation URL. This means we would only want to reset\n        // the part of the navigation handled by the Angular router rather than the whole URL. In\n        // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n        // when merging, such as the query params so they are not lost on a refresh.\n        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: StateManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: StateManager, providedIn: 'root', useFactory: () => inject(HistoryStateManager) });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: StateManager, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => inject(HistoryStateManager) }]\n        }] });\nclass HistoryStateManager extends StateManager {\n    /**\n     * The id of the currently active page in the router.\n     * Updated to the transition's target id on a successful navigation.\n     *\n     * This is used to track what page the router last activated. When an attempted navigation fails,\n     * the router can then use this to compute how to restore the state back to the previously active\n     * page.\n     */\n    currentPageId = 0;\n    lastSuccessfulId = -1;\n    restoredState() {\n        return this.location.getState();\n    }\n    /**\n     * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n     * important for computing the target page id for new navigations because we need to ensure each\n     * page id in the browser history is 1 more than the previous entry.\n     */\n    get browserPageId() {\n        if (this.canceledNavigationResolution !== 'computed') {\n            return this.currentPageId;\n        }\n        return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;\n    }\n    registerNonRouterCurrentEntryChangeListener(listener) {\n        return this.location.subscribe((event) => {\n            if (event['type'] === 'popstate') {\n                // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n                // hybrid apps.\n                setTimeout(() => {\n                    listener(event['url'], event.state, 'popstate');\n                });\n            }\n        });\n    }\n    handleRouterEvent(e, currentTransition) {\n        if (e instanceof NavigationStart) {\n            this.updateStateMemento();\n        }\n        else if (e instanceof NavigationSkipped) {\n            this.commitTransition(currentTransition);\n        }\n        else if (e instanceof RoutesRecognized) {\n            if (this.urlUpdateStrategy === 'eager') {\n                if (!currentTransition.extras.skipLocationChange) {\n                    this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n                }\n            }\n        }\n        else if (e instanceof BeforeActivateRoutes) {\n            this.commitTransition(currentTransition);\n            if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\n                this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n            }\n        }\n        else if (e instanceof NavigationCancel &&\n            e.code !== NavigationCancellationCode.SupersededByNewNavigation &&\n            e.code !== NavigationCancellationCode.Redirect) {\n            this.restoreHistory(currentTransition);\n        }\n        else if (e instanceof NavigationError) {\n            this.restoreHistory(currentTransition, true);\n        }\n        else if (e instanceof NavigationEnd) {\n            this.lastSuccessfulId = e.id;\n            this.currentPageId = this.browserPageId;\n        }\n    }\n    setBrowserUrl(path, { extras, id }) {\n        const { replaceUrl, state } = extras;\n        if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {\n            // replacements do not update the target page\n            const currentBrowserPageId = this.browserPageId;\n            const newState = {\n                ...state,\n                ...this.generateNgRouterState(id, currentBrowserPageId),\n            };\n            this.location.replaceState(path, '', newState);\n        }\n        else {\n            const newState = {\n                ...state,\n                ...this.generateNgRouterState(id, this.browserPageId + 1),\n            };\n            this.location.go(path, '', newState);\n        }\n    }\n    /**\n     * Performs the necessary rollback action to restore the browser URL to the\n     * state before the transition.\n     */\n    restoreHistory(navigation, restoringFromCaughtError = false) {\n        if (this.canceledNavigationResolution === 'computed') {\n            const currentBrowserPageId = this.browserPageId;\n            const targetPagePosition = this.currentPageId - currentBrowserPageId;\n            if (targetPagePosition !== 0) {\n                this.location.historyGo(targetPagePosition);\n            }\n            else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {\n                // We got to the activation stage (where currentUrlTree is set to the navigation's\n                // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n                // We still need to reset the router state back to what it was when the navigation started.\n                this.resetInternalState(navigation);\n                this.resetUrlToCurrentUrlTree();\n            }\n            else ;\n        }\n        else if (this.canceledNavigationResolution === 'replace') {\n            // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n            // for `deferred` navigations that haven't change the internal state yet because guards\n            // reject. For 'eager' navigations, it seems like we also really should reset the state\n            // because the navigation was cancelled. Investigate if this can be done by running TGP.\n            if (restoringFromCaughtError) {\n                this.resetInternalState(navigation);\n            }\n            this.resetUrlToCurrentUrlTree();\n        }\n    }\n    resetUrlToCurrentUrlTree() {\n        this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), '', this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n    }\n    generateNgRouterState(navigationId, routerPageId) {\n        if (this.canceledNavigationResolution === 'computed') {\n            return { navigationId, ɵrouterPageId: routerPageId };\n        }\n        return { navigationId };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HistoryStateManager, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HistoryStateManager, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: HistoryStateManager, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * Performs the given action once the router finishes its next/current navigation.\n *\n * The navigation is considered complete under the following conditions:\n * - `NavigationCancel` event emits and the code is not `NavigationCancellationCode.Redirect` or\n * `NavigationCancellationCode.SupersededByNewNavigation`. In these cases, the\n * redirecting/superseding navigation must finish.\n * - `NavigationError`, `NavigationEnd`, or `NavigationSkipped` event emits\n */\nfunction afterNextNavigation(router, action) {\n    router.events\n        .pipe(filter((e) => e instanceof NavigationEnd ||\n        e instanceof NavigationCancel ||\n        e instanceof NavigationError ||\n        e instanceof NavigationSkipped), map((e) => {\n        if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\n            return 0 /* NavigationResult.COMPLETE */;\n        }\n        const redirecting = e instanceof NavigationCancel\n            ? e.code === NavigationCancellationCode.Redirect ||\n                e.code === NavigationCancellationCode.SupersededByNewNavigation\n            : false;\n        return redirecting ? 2 /* NavigationResult.REDIRECTING */ : 1 /* NavigationResult.FAILED */;\n    }), filter((result) => result !== 2 /* NavigationResult.REDIRECTING */), take(1))\n        .subscribe(() => {\n        action();\n    });\n}\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\n * (exact = true).\n */\nconst exactMatchOptions = {\n    paths: 'exact',\n    fragment: 'ignored',\n    matrixParams: 'ignored',\n    queryParams: 'exact',\n};\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\n * (exact = false).\n */\nconst subsetMatchOptions = {\n    paths: 'subset',\n    fragment: 'ignored',\n    matrixParams: 'ignored',\n    queryParams: 'subset',\n};\n/**\n * @description\n *\n * A service that facilitates navigation among views and URL manipulation capabilities.\n * This service is provided in the root scope and configured with [provideRouter](api/router/provideRouter).\n *\n * @see {@link Route}\n * @see {@link provideRouter}\n * @see [Routing and Navigation Guide](guide/routing/common-router-tasks).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nclass Router {\n    get currentUrlTree() {\n        return this.stateManager.getCurrentUrlTree();\n    }\n    get rawUrlTree() {\n        return this.stateManager.getRawUrlTree();\n    }\n    disposed = false;\n    nonRouterCurrentEntryChangeSubscription;\n    console = inject(_Console);\n    stateManager = inject(StateManager);\n    options = inject(ROUTER_CONFIGURATION, { optional: true }) || {};\n    pendingTasks = inject(_PendingTasksInternal);\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n    navigationTransitions = inject(NavigationTransitions);\n    urlSerializer = inject(UrlSerializer);\n    location = inject(Location);\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    injector = inject(EnvironmentInjector);\n    /**\n     * The private `Subject` type for the public events exposed in the getter. This is used internally\n     * to push events to. The separate field allows us to expose separate types in the public API\n     * (i.e., an Observable rather than the Subject).\n     */\n    _events = new Subject();\n    /**\n     * An event stream for routing events.\n     */\n    get events() {\n        // TODO(atscott): This _should_ be events.asObservable(). However, this change requires internal\n        // cleanup: tests are doing `(route.events as Subject<Event>).next(...)`. This isn't\n        // allowed/supported but we still have to fix these or file bugs against the teams before making\n        // the change.\n        return this._events;\n    }\n    /**\n     * The current state of routing in this NgModule.\n     */\n    get routerState() {\n        return this.stateManager.getRouterState();\n    }\n    /**\n     * True if at least one navigation event has occurred,\n     * false otherwise.\n     */\n    navigated = false;\n    /**\n     * A strategy for re-using routes.\n     *\n     * @deprecated Configure using `providers` instead:\n     *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.\n     */\n    routeReuseStrategy = inject(RouteReuseStrategy);\n    /**\n     * How to handle a navigation request to the current URL.\n     *\n     *\n     * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.\n     * @see {@link withRouterConfig}\n     * @see {@link provideRouter}\n     * @see {@link RouterModule}\n     */\n    onSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\n    config = inject(ROUTES, { optional: true })?.flat() ?? [];\n    /**\n     * Indicates whether the application has opted in to binding Router data to component inputs.\n     *\n     * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or\n     * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.\n     */\n    componentInputBindingEnabled = !!inject(INPUT_BINDER, { optional: true });\n    constructor() {\n        this.resetConfig(this.config);\n        this.navigationTransitions.setupNavigations(this).subscribe({\n            error: (e) => {\n                this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\n            },\n        });\n        this.subscribeToNavigationEvents();\n    }\n    eventsSubscription = new Subscription();\n    subscribeToNavigationEvents() {\n        const subscription = this.navigationTransitions.events.subscribe((e) => {\n            try {\n                const currentTransition = this.navigationTransitions.currentTransition;\n                const currentNavigation = this.navigationTransitions.currentNavigation;\n                if (currentTransition !== null && currentNavigation !== null) {\n                    this.stateManager.handleRouterEvent(e, currentNavigation);\n                    if (e instanceof NavigationCancel &&\n                        e.code !== NavigationCancellationCode.Redirect &&\n                        e.code !== NavigationCancellationCode.SupersededByNewNavigation) {\n                        // It seems weird that `navigated` is set to `true` when the navigation is rejected,\n                        // however it's how things were written initially. Investigation would need to be done\n                        // to determine if this can be removed.\n                        this.navigated = true;\n                    }\n                    else if (e instanceof NavigationEnd) {\n                        this.navigated = true;\n                    }\n                    else if (e instanceof RedirectRequest) {\n                        const opts = e.navigationBehaviorOptions;\n                        const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);\n                        const extras = {\n                            browserUrl: currentTransition.extras.browserUrl,\n                            info: currentTransition.extras.info,\n                            skipLocationChange: currentTransition.extras.skipLocationChange,\n                            // The URL is already updated at this point if we have 'eager' URL\n                            // updates or if the navigation was triggered by the browser (back\n                            // button, URL bar, etc). We want to replace that item in history\n                            // if the navigation is rejected.\n                            replaceUrl: currentTransition.extras.replaceUrl ||\n                                this.urlUpdateStrategy === 'eager' ||\n                                isBrowserTriggeredNavigation(currentTransition.source),\n                            // allow developer to override default options with RedirectCommand\n                            ...opts,\n                        };\n                        this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n                            resolve: currentTransition.resolve,\n                            reject: currentTransition.reject,\n                            promise: currentTransition.promise,\n                        });\n                    }\n                }\n                // Note that it's important to have the Router process the events _before_ the event is\n                // pushed through the public observable. This ensures the correct router state is in place\n                // before applications observe the events.\n                if (isPublicRouterEvent(e)) {\n                    this._events.next(e);\n                }\n            }\n            catch (e) {\n                this.navigationTransitions.transitionAbortWithErrorSubject.next(e);\n            }\n        });\n        this.eventsSubscription.add(subscription);\n    }\n    /** @internal */\n    resetRootComponentType(rootComponentType) {\n        // TODO: vsavkin router 4.0 should make the root component set to null\n        // this will simplify the lifecycle of the router.\n        this.routerState.root.component = rootComponentType;\n        this.navigationTransitions.rootComponentType = rootComponentType;\n    }\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     */\n    initialNavigation() {\n        this.setUpLocationChangeListener();\n        if (!this.navigationTransitions.hasRequestedNavigation) {\n            this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());\n        }\n    }\n    /**\n     * Sets up the location change listener. This listener detects navigations triggered from outside\n     * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n     * navigation so that the correct events, guards, etc. are triggered.\n     */\n    setUpLocationChangeListener() {\n        // Don't need to use Zone.wrap any more, because zone.js\n        // already patch onPopState, so location change callback will\n        // run into ngZone\n        this.nonRouterCurrentEntryChangeSubscription ??=\n            this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {\n                this.navigateToSyncWithBrowser(url, source, state);\n            });\n    }\n    /**\n     * Schedules a router navigation to synchronize Router state with the browser state.\n     *\n     * This is done as a response to a popstate event and the initial navigation. These\n     * two scenarios represent times when the browser URL/state has been updated and\n     * the Router needs to respond to ensure its internal state matches.\n     */\n    navigateToSyncWithBrowser(url, source, state) {\n        const extras = { replaceUrl: true };\n        // TODO: restoredState should always include the entire state, regardless\n        // of navigationId. This requires a breaking change to update the type on\n        // NavigationStart’s restoredState, which currently requires navigationId\n        // to always be present. The Router used to only restore history state if\n        // a navigationId was present.\n        // The stored navigationId is used by the RouterScroller to retrieve the scroll\n        // position for the page.\n        const restoredState = state?.navigationId ? state : null;\n        // Separate to NavigationStart.restoredState, we must also restore the state to\n        // history.state and generate a new navigationId, since it will be overwritten\n        if (state) {\n            const stateCopy = { ...state };\n            delete stateCopy.navigationId;\n            delete stateCopy.ɵrouterPageId;\n            if (Object.keys(stateCopy).length !== 0) {\n                extras.state = stateCopy;\n            }\n        }\n        const urlTree = this.parseUrl(url);\n        this.scheduleNavigation(urlTree, source, restoredState, extras).catch((e) => {\n            if (this.disposed) {\n                return;\n            }\n            this.injector.get(_INTERNAL_APPLICATION_ERROR_HANDLER)(e);\n        });\n    }\n    /** The current URL. */\n    get url() {\n        return this.serializeUrl(this.currentUrlTree);\n    }\n    /**\n     * Returns the current `Navigation` object when the router is navigating,\n     * and `null` when idle.\n     */\n    getCurrentNavigation() {\n        return this.navigationTransitions.currentNavigation;\n    }\n    /**\n     * The `Navigation` object of the most recent navigation to succeed and `null` if there\n     *     has not been a successful navigation yet.\n     */\n    get lastSuccessfulNavigation() {\n        return this.navigationTransitions.lastSuccessfulNavigation;\n    }\n    /**\n     * Resets the route configuration used for navigation and generating links.\n     *\n     * @param config The route array for the new configuration.\n     *\n     * @usageNotes\n     *\n     * ```ts\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     */\n    resetConfig(config) {\n        (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\n        this.config = config.map(standardizeConfig);\n        this.navigated = false;\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n        this.dispose();\n    }\n    /** Disposes of the router. */\n    dispose() {\n        // We call `unsubscribe()` to release observers, as users may forget to\n        // unsubscribe manually when subscribing to `router.events`. We do not call\n        // `complete()` because it is unsafe; if someone subscribes using the `first`\n        // operator and the observable completes before emitting a value,\n        // RxJS will throw an error.\n        this._events.unsubscribe();\n        this.navigationTransitions.complete();\n        if (this.nonRouterCurrentEntryChangeSubscription) {\n            this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\n            this.nonRouterCurrentEntryChangeSubscription = undefined;\n        }\n        this.disposed = true;\n        this.eventsSubscription.unsubscribe();\n    }\n    /**\n     * Appends URL segments to the current URL tree to create a new URL tree.\n     *\n     * @param commands An array of URL fragments with which to construct the new URL tree.\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n     * segments, followed by the parameters for each segment.\n     * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n     * property of the options object, if supplied.\n     * @param navigationExtras Options that control the navigation strategy.\n     * @returns The new URL tree.\n     *\n     * @usageNotes\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it,\n     * // you can do the following:\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     *\n     * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\n     * tree should be created relative to the root.\n     * ```\n     */\n    createUrlTree(commands, navigationExtras = {}) {\n        const { relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment } = navigationExtras;\n        const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n        let q = null;\n        switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\n            case 'merge':\n                q = { ...this.currentUrlTree.queryParams, ...queryParams };\n                break;\n            case 'preserve':\n                q = this.currentUrlTree.queryParams;\n                break;\n            default:\n                q = queryParams || null;\n        }\n        if (q !== null) {\n            q = this.removeEmptyProps(q);\n        }\n        let relativeToUrlSegmentGroup;\n        try {\n            const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n            relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n        }\n        catch (e) {\n            // This is strictly for backwards compatibility with tests that create\n            // invalid `ActivatedRoute` mocks.\n            // Note: the difference between having this fallback for invalid `ActivatedRoute` setups and\n            // just throwing is ~500 test failures. Fixing all of those tests by hand is not feasible at\n            // the moment.\n            if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {\n                // Navigations that were absolute in the old way of creating UrlTrees\n                // would still work because they wouldn't attempt to match the\n                // segments in the `ActivatedRoute` to the `currentUrlTree` but\n                // instead just replace the root segment with the navigation result.\n                // Non-absolute navigations would fail to apply the commands because\n                // the logic could not find the segment to replace (so they'd act like there were no\n                // commands).\n                commands = [];\n            }\n            relativeToUrlSegmentGroup = this.currentUrlTree.root;\n        }\n        return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);\n    }\n    /**\n     * Navigates to a view using an absolute route path.\n     *\n     * @param url An absolute path for a defined route. The function does not apply any delta to the\n     *     current URL.\n     * @param extras An object containing properties that modify the navigation strategy.\n     *\n     * @returns A Promise that resolves to 'true' when navigation succeeds,\n     * to 'false' when navigation fails, or is rejected on error.\n     *\n     * @usageNotes\n     *\n     * The following calls request navigation to an absolute path.\n     *\n     * ```ts\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n     *\n     */\n    navigateByUrl(url, extras = {\n        skipLocationChange: false,\n    }) {\n        const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n        const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n        return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n    }\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * @param commands An array of URL fragments with which to construct the target URL.\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n     * segments, followed by the parameters for each segment.\n     * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n     * of the options object, if supplied.\n     * @param extras An options object that determines how the URL should be constructed or\n     *     interpreted.\n     *\n     * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation\n     *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is\n     * not `true`.\n     *\n     * @usageNotes\n     *\n     * The following calls request navigation to a dynamic route path relative to the current URL.\n     *\n     * ```ts\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL, overriding the default behavior\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n     *\n     */\n    navigate(commands, extras = { skipLocationChange: false }) {\n        validateCommands(commands);\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n    }\n    /** Serializes a `UrlTree` into a string */\n    serializeUrl(url) {\n        return this.urlSerializer.serialize(url);\n    }\n    /** Parses a string into a `UrlTree` */\n    parseUrl(url) {\n        try {\n            return this.urlSerializer.parse(url);\n        }\n        catch {\n            return this.urlSerializer.parse('/');\n        }\n    }\n    isActive(url, matchOptions) {\n        let options;\n        if (matchOptions === true) {\n            options = { ...exactMatchOptions };\n        }\n        else if (matchOptions === false) {\n            options = { ...subsetMatchOptions };\n        }\n        else {\n            options = matchOptions;\n        }\n        if (isUrlTree(url)) {\n            return containsTree(this.currentUrlTree, url, options);\n        }\n        const urlTree = this.parseUrl(url);\n        return containsTree(this.currentUrlTree, urlTree, options);\n    }\n    removeEmptyProps(params) {\n        return Object.entries(params).reduce((result, [key, value]) => {\n            if (value !== null && value !== undefined) {\n                result[key] = value;\n            }\n            return result;\n        }, {});\n    }\n    scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {\n        if (this.disposed) {\n            return Promise.resolve(false);\n        }\n        let resolve;\n        let reject;\n        let promise;\n        if (priorPromise) {\n            resolve = priorPromise.resolve;\n            reject = priorPromise.reject;\n            promise = priorPromise.promise;\n        }\n        else {\n            promise = new Promise((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n        }\n        // Indicate that the navigation is happening.\n        const taskId = this.pendingTasks.add();\n        afterNextNavigation(this, () => {\n            // Remove pending task in a microtask to allow for cancelled\n            // initial navigations and redirects within the same task.\n            queueMicrotask(() => this.pendingTasks.remove(taskId));\n        });\n        this.navigationTransitions.handleNavigationRequest({\n            source,\n            restoredState,\n            currentUrlTree: this.currentUrlTree,\n            currentRawUrl: this.currentUrlTree,\n            rawUrl,\n            extras,\n            resolve: resolve,\n            reject: reject,\n            promise,\n            currentSnapshot: this.routerState.snapshot,\n            currentRouterState: this.routerState,\n        });\n        // Make sure that the error is propagated even though `processNavigations` catch\n        // handler does not rethrow\n        return promise.catch((e) => {\n            return Promise.reject(e);\n        });\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: Router, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: Router, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.1.4\", ngImport: i0, type: Router, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\nfunction validateCommands(commands) {\n    for (let i = 0; i < commands.length; i++) {\n        const cmd = commands[i];\n        if (cmd == null) {\n            throw new _RuntimeError(4008 /* RuntimeErrorCode.NULLISH_COMMAND */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `The requested path contains ${cmd} segment at index ${i}`);\n        }\n    }\n}\n\nexport { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, CREATE_VIEW_TRANSITION, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, EventType, GuardsCheckEnd, GuardsCheckStart, IMPERATIVE_NAVIGATION, INPUT_BINDER, NAVIGATION_ERROR_HANDLER, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationSkippedCode, NavigationStart, NavigationTransitions, OutletContext, PRIMARY_OUTLET, ROUTER_CONFIGURATION, ROUTER_OUTLET_DATA, ROUTES, RedirectCommand, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, RoutedComponentInputBinder, Router, RouterConfigLoader, RouterEvent, RouterOutlet, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VIEW_TRANSITION_OPTIONS, afterNextNavigation, convertToParamMap, createUrlTreeFromSnapshot, createViewTransition, defaultUrlMatcher, isUrlTree, loadChildren, stringifyEvent, ɵEmptyOutletComponent };\n\n","/**\n * @license Angular v20.1.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nexport { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, EventType, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationSkippedCode, NavigationStart, OutletContext, PRIMARY_OUTLET, ROUTER_CONFIGURATION, ROUTER_OUTLET_DATA, ROUTES, RedirectCommand, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, Router, RouterEvent, RouterOutlet, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, convertToParamMap, createUrlTreeFromSnapshot, defaultUrlMatcher, ɵEmptyOutletComponent, afterNextNavigation as ɵafterNextNavigation, loadChildren as ɵloadChildren } from './router2.mjs';\nexport { NoPreloading, PreloadAllModules, PreloadingStrategy, ROUTER_INITIALIZER, RouterLink, RouterLinkActive, RouterLink as RouterLinkWithHref, RouterModule, RouterPreloader, provideRouter, provideRoutes, withComponentInputBinding, withDebugTracing, withDisabledInitialNavigation, withEnabledBlockingInitialNavigation, withHashLocation, withInMemoryScrolling, withNavigationErrorHandler, withPreloading, withRouterConfig, withViewTransitions, ROUTER_PROVIDERS as ɵROUTER_PROVIDERS } from './router_module.mjs';\nimport { inject, Version } from '@angular/core';\nimport '@angular/common';\nimport 'rxjs';\nimport 'rxjs/operators';\nimport '@angular/platform-browser';\n\n/**\n * Maps an array of injectable classes with canMatch functions to an array of equivalent\n * `CanMatchFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToCanMatch(providers) {\n    return providers.map((provider) => (...params) => inject(provider).canMatch(...params));\n}\n/**\n * Maps an array of injectable classes with canActivate functions to an array of equivalent\n * `CanActivateFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToCanActivate(providers) {\n    return providers.map((provider) => (...params) => inject(provider).canActivate(...params));\n}\n/**\n * Maps an array of injectable classes with canActivateChild functions to an array of equivalent\n * `CanActivateChildFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToCanActivateChild(providers) {\n    return providers.map((provider) => (...params) => inject(provider).canActivateChild(...params));\n}\n/**\n * Maps an array of injectable classes with canDeactivate functions to an array of equivalent\n * `CanDeactivateFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToCanDeactivate(providers) {\n    return providers.map((provider) => (...params) => inject(provider).canDeactivate(...params));\n}\n/**\n * Maps an injectable class with a resolve function to an equivalent `ResolveFn`\n * for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='Resolve'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToResolve(provider) {\n    return (...params) => inject(provider).resolve(...params);\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the router package.\n */\n/**\n * @publicApi\n */\nconst VERSION = new Version('20.1.4');\n\nexport { VERSION, mapToCanActivate, mapToCanActivateChild, mapToCanDeactivate, mapToCanMatch, mapToResolve };\n\n","import { Component, signal } from '@angular/core';\r\nimport { RouterOutlet } from '@angular/router';\r\nimport { MatIconModule } from '@angular/material/icon';\r\nimport { MatButtonModule } from '@angular/material/button';\r\n\r\n\r\n@Component({\r\n  selector: 'app-root',\r\n  imports: [RouterOutlet, MatIconModule, MatButtonModule],\r\n  templateUrl: './app.html',\r\n  styleUrl: './app.css'\r\n})\r\nexport class App {\r\n  protected readonly title = signal('todo-app');\r\n}\r\n","import { TestBed } from '@angular/core/testing';\r\nimport { App } from './app';\r\n\r\ndescribe('App', () => {\r\n  beforeEach(async () => {\r\n    await TestBed.configureTestingModule({\r\n      imports: [App],\r\n    }).compileComponents();\r\n  });\r\n\r\n  it('should create the app', () => {\r\n    const fixture = TestBed.createComponent(App);\r\n    const app = fixture.componentInstance;\r\n    expect(app).toBeTruthy();\r\n  });\r\n});\r\n"],"mappings":"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","names":["app_default","init_app","last","match","res","commands","noMatch","node","map","tree","canActivate","s","input","EventType","NavigationCancellationCode","NavigationSkippedCode","t","c","contexts","e","App","init_app"],"x_google_ignoreList":[2,3]}